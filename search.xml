<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>动态规划</title>
    <url>/posts/a80d0031/</url>
    <content><![CDATA[<h4 id="动态规划的基本思路">动态规划的基本思路</h4>
<p><img src="/images/dp思路.png" /></p>
<h4 id="背包问题">背包问题</h4>
<h5 id="背包问题-1">01背包问题</h5>
<p><strong>概述</strong></p>
<ul>
<li>n件物品，背包体积为m，每件物品只能被拿一次或者不拿，求背包能装物品的最大价值是多少</li>
<li>用f[i][j]表示从编号为1~i的物品中拿，物品的总体积最大为j，的最大价值</li>
</ul>
<p><strong>状态计算</strong></p>
<ul>
<li>f [i][j] = max (f[i-1][j]，f[i-1][j-v[i]] + w[i])</li>
</ul>
<p><strong>优化</strong></p>
<ul>
<li>由于 i 只与 i-1 有关，所以可以将 i
作外层循环来计算，但是必须从大到小开始更新</li>
<li>因为，j - v[i] &lt; j，所以在到 f[j]之前 f [j - v[i]]
已经被更新过了，但我们需要的是未更新之前的值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化前的代码：二维数组</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= v[i]) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化后的代码：一维数组</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v[i]; j--)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">            </span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="完全背包问题">完全背包问题</h5>
<p><strong>概述</strong></p>
<ul>
<li>基本条件与01背包问题一致，只是每个物品可以不拿或者拿无限个(不超过背包容量)</li>
</ul>
<p><strong>状态计算</strong></p>
<ul>
<li><p>f [i][j] = max (f[i-1][j-k*v[i]] + w[i])</p></li>
<li><p>g[i][j]集合能被分为若干个部分，即拿 0 个 i 物品，1个 i
物品，...，k个 i 物品</p></li>
<li><p>因此f[i][j] 就为这些若干个部分的价值的最大值</p></li>
</ul>
<p><strong>优化</strong></p>
<ul>
<li>已知：f[i][j] = max (f[i-1][j]，f[i-1][j-v] + w，f [i-1][j-2 * v] +
2 * w，...)</li>
<li>令 j = j - v，则有：f[i][j-v] = max (f[i-1][j-v]，f[i-1][j-2<em>v] +
w，f[i-1][j-3</em>v] + 2*w, ...)</li>
<li>可以发现：f[i][j] = max(f[i-1][j]，f[i][j-v] + w)</li>
<li>其可以变换为与k无关的式子</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">        	<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k * v[i] &lt;= j; k++)</span><br><span class="line">                <span class="comment">//f[i][j]初始化为0，所以可以在max中与自己比</span></span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j - k * v[i]] + k * w[i]);</span><br><span class="line">           </span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化版本：去k版</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(v[i] &lt;= j)	<span class="comment">//第 i 种能放进去，</span></span><br><span class="line">            	f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j], f[i][j-v[i]] + w[i]);</span><br><span class="line">            <span class="keyword">else</span>			<span class="comment">//如果第 i 件物品不能放进去</span></span><br><span class="line">                f[i][j] = f[i<span class="number">-1</span>][j];	<span class="comment">//拿i的集合不一定存在</span></span><br><span class="line">        &#125;</span><br><span class="line">             </span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化版本：去k版 + 一维</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	在之前的去k版的优化中可以看到最终代码与01背包问题十分相似，因此在完全背包中也可以降为一维</span></span><br><span class="line"><span class="comment">	由于完全背包问题中使用的是第i层的状态而非i-1层的状态，所以不能从大到小更新，必须从小大更新</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i&lt;=n ;i++)</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> j = v[i] ; j &lt;= m ;j ++)</span><br><span class="line">        	f[j] = <span class="built_in">max</span>(f[j], f[j-v[i]] + w[i]);	<span class="comment">//必须从小大更新</span></span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="多重背包问题">多重背包问题</h5>
<p><strong>题目</strong></p>
<ul>
<li>n 个物品，每个物品最多有 s<sub>i</sub>
件，s的值可能相同也可能不相同</li>
<li>时间复杂度：O(n * m * k)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;	</span><br><span class="line"><span class="type">int</span> v[N], w[N], s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="comment">//无优化版本：二维版本</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;v[i], &amp;w[i], &amp;s[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;   f[i][j] = f[i - <span class="number">1</span>][j];	<span class="comment">//下面的拿k个的集合不一定存在</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i]; k++)</span><br><span class="line">                    <span class="keyword">if</span>(k * v[i] &lt;= j) </span><br><span class="line">                        f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i]); </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n][m]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化成一维：类似01背包问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> v[N], w[N], s[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;v[i], &amp;w[i], &amp;s[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--)	<span class="comment">//因为用到的是上一层的数据，所以需要从大到小遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i]; k++)</span><br><span class="line">                <span class="keyword">if</span>(k * v[i] &lt;= j) </span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j], f[j - k * v[i]] + k * w[i]); </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[m]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="多重背包问题ii">多重背包问题II</h5>
<p><strong>题目</strong></p>
<ul>
<li>s的数据范围比较大，用上面一种方法会超时</li>
<li>使用二进制优化法对算法进行优化</li>
<li>核心思想：任意一个数 x 可以由 1, 2, 4, 8, ... , 2<sup>k</sup>, c
这些数字组合相加而成，其中 c = x - (1 + 2 + 4 + 8 +...+
2<sup>k</sup>)</li>
<li>当n比较大时，我们就可以让 1, 2, 4, 8, ... , 2<sup>k</sup>, c
这些数字相加来表示 n，从而转化为01背包问题</li>
<li>例如：要求在一堆苹果选出n个苹果。我们传统的思维是一个一个地去选，选够n个苹果就停止。这样选择的次数就是n次
现在给出一堆苹果和10个箱子，选出n个苹果。将这一堆苹果分别按照1,2,4,8,16,.....512分到10个箱子里，那么由于任何一个数字x∈[0,1023]都可以从这10个箱子里的苹果数量表示出来，但是这样选择的次数就是
≤10次</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">11010</span>, M = <span class="number">2010</span>;	<span class="comment">//注意开辟空间，每个s最多被分为log(s)个箱子，所以小箱子的总数为n*log(s)</span></span><br><span class="line"><span class="type">int</span> v[N], w[N];					<span class="comment">//=1000 * log(2000) ≈ 11000</span></span><br><span class="line"><span class="type">int</span> f[M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;	</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)		<span class="comment">//相当于把原来的一个大箱子(每一个s都相当于一个大箱子)分成了多个小箱子，大箱子中的任意个数可以由小箱子中的数组合而成，从而转换成小箱子选哪些的问题</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b, s;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;s);	</span><br><span class="line">            <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(k &lt;= s)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                v[cnt] = a * k, w[cnt] = b * k;	<span class="comment">//第cnt堆的总体积为 a*k, 总价值为 a * k </span></span><br><span class="line">                s -= k;</span><br><span class="line">                k *= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s &gt; <span class="number">0</span>)	<span class="comment">//因为在前面每次s将k的值减去，因此若 s &gt; 0则表示其就为拆分的最后一个常数</span></span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                v[cnt] = a * s, w[cnt] = b * s;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;	</span><br><span class="line">    </span><br><span class="line">    n = cnt;	<span class="comment">//更新完后，v[]的大小变成cnt了</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//01背包问题的板子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v[i]; j--)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[m]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="分组背包问题">分组背包问题</h5>
<p><strong>题目</strong></p>
<ul>
<li>每组物品有若干个，同一组内的物品最多只能选一个，每组内的每件物品的体积和价值可能相同也可能不同</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二维版本</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="type">int</span> v[N][N], w[N][N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s[i]; j++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;v[i][j], &amp;w[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;   f[i][j] = f[i<span class="number">-1</span>][j];	<span class="comment">//下面情况所属的集合不一定存在</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i]; k++)</span><br><span class="line">                <span class="keyword">if</span>(v[i][k] &lt;= j) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j-v[i][k]] + w[i][k]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n][m]);	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化：一维版本</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="type">int</span> f[N], v[N][N], w[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s[i]; j++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;v[i][j], &amp;w[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--)	<span class="comment">//使用上一层的数据，需要从大到小更新</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i]; k++)</span><br><span class="line">                <span class="keyword">if</span>(v[i][k] &lt;= j)</span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[m]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="背包问题的小结">背包问题的小结</h5>
<ul>
<li><p>状态表示</p>
<ol type="1">
<li>01背包问题：<span
class="math inline">\(f[i][j]表示从前i个物品中挑选物品，总体积不超过j\)</span></li>
<li>完全背包问题和多重背包问题的状态表示与01背包问题一致</li>
<li>分组背包问题：<span
class="math inline">\(f[i][j]表示从前i组物品中挑选物品，总体积不超过j\)</span></li>
</ol></li>
<li><p>状态计算</p>
<ol type="1">
<li>01背包问题：<span
class="math inline">\(f[i][j]=max(f[i-1][j],f[i-1][j-v[i]])\)</span>，表示拿与不拿第i个物品</li>
<li>完全背包问题：<span
class="math inline">\(f[i][j]=max(f[i-1][j-k*v]+w)\)</span>，表示第 i
个物品拿多少个用k来表示</li>
<li>分组背包问题：<span
class="math inline">\(f[i][j]=max(f[i-1][j],f[i-1][j-k*v]+w)\)</span>，表示第
i 组中的物品拿哪一个，或者不拿第 i 组中的物品</li>
</ol></li>
<li><p>优化</p>
<ol type="1">
<li><p>降低维度</p></li>
<li><p>看利用的是上一层的数据还是同层的数据，上一层则从大到小更新；同层则从小到大更新</p></li>
</ol></li>
</ul>
<h4 id="线性dp">线性DP</h4>
<h5 id="数字三角形">数字三角形</h5>
<p><strong>题目</strong></p>
<ul>
<li>给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大</li>
</ul>
<p>​ 7</p>
<p>​ 3 8</p>
<p>8 1 8</p>
<p><strong>集合表示</strong></p>
<ul>
<li>f(i, j) 表示到点 (i,j) 的所有路径</li>
<li>f[i][j] 表示到点 (i,j) 的所有路径的中最大的数值和</li>
</ul>
<p><strong>集合划分</strong></p>
<ul>
<li><p>按照上一个点是谁来划分</p></li>
<li><p>f[i][j] = max(f[i-1][j-1], f[i-1][j]) + a[i][j]</p></li>
<li><p>每个点可以从其左上和右上的点走到，两条路径中最大数值和+点 (i, j)
的值就为最大数值和</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][N], a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="comment">//数字金字塔的读入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理边界问题，位于金字塔边缘的点可能会向上访问到f数组的边界        </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n + <span class="number">1</span>; j++)</span><br><span class="line">            f[i][j] = -INF;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先把一开始就能知道的值先赋上</span></span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从第2行开始，进行状态转移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            <span class="comment">//每次左上与右上两个点进行比较</span></span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j], f[i<span class="number">-1</span>][j<span class="number">-1</span>]) + a[i][j];</span><br><span class="line">            </span><br><span class="line">    <span class="type">int</span> res = -INF;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//要使数值和最大，则一定会到达最后一层的点，但不知道是哪一个点，所以对最后一层的点遍历取得最终答案</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res = <span class="built_in">max</span>(res, f[n][i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最长上升子序列">最长上升子序列</h5>
<p><strong>题目</strong></p>
<ul>
<li>给定一个长度为 N
的数列，求数值严格单调递增的子序列的长度最长是多少。</li>
<li><span class="math inline">\(1\le N\le 1000\)</span></li>
</ul>
<p><strong>集合表示</strong></p>
<ul>
<li>f(i) 表示以 i 结尾子序列</li>
<li>f[i] 表示以 i 结尾的子序列中的长度最大值</li>
</ul>
<p><strong>集合划分</strong></p>
<ul>
<li>依据子序列中第 i -1 个数是多少来划分</li>
<li>f[i] = max{ f[1], f[2], ... , f[i-1] }</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N], a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="comment">//数据的读入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//枚举每一个点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            <span class="comment">//a[i] &gt; a[j]时，a[i]才能接在a[j]的后面</span></span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[j])</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最长上升子序列-ii">最长上升子序列 II</h5>
<p><strong>题目</strong></p>
<ul>
<li>给定一个长度为 N
的数列，求数值严格单调递增的子序列的长度最长是多少。</li>
<li><span class="math inline">\(1\le N\le 100000\)</span></li>
</ul>
<p><strong>思路</strong></p>
<ul>
<li>由于数据范围比较大，所以用贪心+二分来做</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], q[N];	<span class="comment">//q数组中存放的就是最大上升子序列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;	<span class="comment">//表示q数组的长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line">        <span class="comment">//利用二分，从q数组中找到小于a[i]的最大的数</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(q[mid] &lt; a[i]) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//r + 1 表示加上a[i]后的q数组的长度，需要与原来长度取个最大值</span></span><br><span class="line">        len = <span class="built_in">max</span>(len, r + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将a[i]插入到q数组的末尾，注意q数组的下标是从1开始的</span></span><br><span class="line">        q[r + <span class="number">1</span>] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出q数组的长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, len);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最长公共子序列">最长公共子序列</h5>
<p><strong>题目</strong></p>
<ul>
<li>给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B
的子序列的字符串长度最长是多少</li>
</ul>
<p><strong>集合表示</strong></p>
<ul>
<li>f(i)(j) 表示既在A的前 i 个字母中，又在B的前 j 个字母中的字符串</li>
<li>f[i][j] 表示集合中的字符串的最大长度</li>
</ul>
<p><strong>集合划分</strong></p>
<ul>
<li>依据是否包含A的第 i 个字符以及是否包含B的第 j 个字符来划分</li>
<li>0表示不包含，1表示包含：则有 00， 01，10，11</li>
<li>对应的状态为：f[i-1][j- 1]、f[i-1][j]、f[i][j-1]、f[i-1][j-1] +
1</li>
<li>01,10对应的状态不一定等价于 f[i-1][j]、f[i][j-1]
但其一定包含在其中，但我们要求的是最大值，所以可以重复计算</li>
<li>11的状态不一定存在，只有当 a[i] == b[j]
时，才成立，而f[i-1][j-1]又包含在f[i-1][j]、f[i][j-1]状态中，因此只需要计算三种状态即可</li>
<li>f[i][j] = max{ f[i-1][j]、f[i][j-1]、f[i-1][j-1] + 1 }</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="comment">//因为涉及到i-1和j-1，所以从1开始读取字符串</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j], f[i][j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j])	<span class="comment">//最后一种情况只有当a[i]==b[j]的时候才成立</span></span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n][m]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最短编辑距离">最短编辑距离</h5>
<p><strong>题目</strong></p>
<ul>
<li><p>给定两个字符串 A 和 B，现在要将 A 经过若干操作变为
B，可进行的操作有：</p>
<ul>
<li>删除–将字符串 A 中的某个字符删除。</li>
<li>插入–在字符串 A 的某个位置插入某个字符。</li>
<li>替换–将字符串 A 中的某个字符替换为另一个字符。</li>
</ul>
<p>现在请你求出，将 A 变为 B 至少需要进行多少次操作。</p></li>
</ul>
<p><strong>集合表示</strong></p>
<ul>
<li>f (i)(j) 表示由 a[1~i] 转变成 b [1~i] 所需要的编辑步数</li>
<li>f [i][j] 表示由 a[1~i] 转变成 b [1~i] 所需要的最小编辑步数</li>
</ul>
<p><strong>集合划分</strong></p>
<ul>
<li><p>依据每次对最后一个字符的操作方式进行划分(增、删、改)</p></li>
<li><p>属性：min：最小值</p></li>
<li><p>增：f [i][j-1] + 1，先将a[1 ~ i] 变成 b[1 ~
j-1]，再在末尾添加一个字符就变成了b[j]</p></li>
<li><p>删：f[i-1][j] + 1，由a[1 ~ i-1] 变成
b[j]，再将a的末尾删除一个字符得到</p></li>
<li><p>改：f[i-1][j-1] + (a[i] != b [j])，由a[1 ~ i-1] 变成 b[j -
1]，如果最后一个字符相同，则不用修改；不同则需要修改</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s%d%s&quot;</span>, &amp;n, a + <span class="number">1</span>, &amp;m, b + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) f[<span class="number">0</span>][i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i<span class="number">-1</span>][j] + <span class="number">1</span>, f[i][j<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i][j], f[i<span class="number">-1</span>][j<span class="number">-1</span>] + (a[i] != b[j]));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n][m]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="区间dp">区间DP</h4>
<h5 id="石子合并">石子合并</h5>
<p>力扣原题：<a
href="https://leetcode.cn/problems/minimum-cost-to-merge-stones/">合并石头的最低成本</a></p>
<p><strong>题目</strong></p>
<ul>
<li>设有 N 堆石子排成一排，其编号为
1,2,3,…,N1,2,3,…,。每堆石子有一定的质量，可以用一个整数来描述，现在要将这
N
堆石子合并成为一堆。每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。例如有
44 堆石子分别为 <code>1 3 5 2</code>， 我们可以先合并 1、21、2
堆，代价为 44，得到 <code>4 5 2</code>， 又合并 1、21、2 堆，代价为
99，得到 <code>9 2</code> ，再合并得到 1111，总代价为
4+9+11=244+9+11=24；如果第二步是先合并 2、32、3 堆，则代价为 77，得到
<code>4 7</code>，最后一次合并代价为 1111，总代价为
4+7+11=224+7+11=22。问题是：找出一种合理的方法，使总的代价最小，输出最小代价。</li>
</ul>
<p><strong>集合表示</strong></p>
<ul>
<li>f(i)(j) 表示将第 i 堆石子到第 j 堆石子合并成一堆的所有方法</li>
<li>f[i][j] 表示将第 i 堆石子到第 j
堆石子合并成一堆所需要的最小代价</li>
</ul>
<p><strong>集合划分</strong></p>
<ul>
<li><p>区间dp的集合划分一般是以区间的边界来划分</p></li>
<li><p>以左边石堆的边界划分：先将 i ~ j 堆石子分成两堆 —— f[i][k] 和
f[k+1][j] , (i &lt;= k &lt; j)，最后再加上这两堆石子的总重量即是 合并第
i 到 j 堆石子的总重量</p></li>
<li><p>f [i][j] = min{ f[i][j], f[i][k] + f[k+1][j] + s[j] - s[i -
1]}</p></li>
<li><p>其中s[j] - s[i-1]表示第 i 堆石子到第 j 堆石子的总重量</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">        s[i] += s[i<span class="number">-1</span>];	<span class="comment">//读入数据的同时，求出所有前缀和</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);	<span class="comment">//因为求的是最小值，首先进行一个初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; len++) <span class="comment">//从长度开始遍历，因为再进行状态转移的过程中，所用到的都是已计算过的状态，因此必须依据长度开始遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++)	<span class="comment">//i表示的是左边界</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = i + len - <span class="number">1</span>;	<span class="comment">//j表示在长度	为len的情况下的右边界</span></span><br><span class="line">            <span class="keyword">if</span>(len == <span class="number">1</span>)	<span class="comment">//当len == 1 时，i = j，合并成一堆的代价为0</span></span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt; j; k++)	<span class="comment">//状态转移方程，i &lt;= k &lt; j</span></span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i][j], f[i][k] + f[k+<span class="number">1</span>][j] + s[j] - s[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[<span class="number">1</span>][n]);	<span class="comment">//f[1][n]表示将1~n堆的石子合并</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="计数类dp">计数类DP</h4>
<h5 id="数的划分">数的划分</h5>
<p><strong>题目</strong></p>
<ul>
<li>一个正整数 n 可以表示成若干个正整数之和，形如：n = n1+n2+…+nk = 1 +
2 + … + nk，其中 n1 ≥ n2 ≥ … ≥ nk, k &gt;=
1。我们将这样的一种表示称为正整数 n 的一种划分。现在给定一个正整数
n，请你求出 n 共有多少种不同的划分方法。</li>
<li>由于答案可能很大，输出结果请对 109+7109+7 取模。</li>
</ul>
<p><strong>集合表示</strong></p>
<ul>
<li>f[i][j] 表示从1 ~ i 中选，且总和等于 j 的方案总数</li>
<li>和完全背包非常相似，只是背包的体积必须为 j</li>
</ul>
<p><strong>集合划分</strong></p>
<ul>
<li><p>依据选或不选数字 i 来划分，f[i][j]的方案数等于所有
选0个i，1个i，2个i ... 的方案总数全部相加</p></li>
<li><p>f[i][j] = f[i-1][j] + f[i-1][j-i] + f[i-1][j-2i] + ... +</p></li>
<li><p>f[i][j-i] = f[i-1][j-i] + f[i-1][j-2i] + ... +</p></li>
<li><p>f[i][j] = f[i-1][j] + f[i][j-i]</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二维版本</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从1~i中选择数，且总和为0，只有一种方法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;    </span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j] % mod;	<span class="comment">//选0个i</span></span><br><span class="line">            <span class="keyword">if</span>(j &gt;= i)	<span class="comment">//j - i的集合不一定存在，当j &gt;= i的时候才存在</span></span><br><span class="line">                f[i][j] = (f[i<span class="number">-1</span>][j] + f[i][j-i]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n][n]);	<span class="comment">//从1~n中选，使总和恰好为n的方案总数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一维版本</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= n; j++)    </span><br><span class="line">            <span class="keyword">if</span>(j &gt;= i)</span><br><span class="line">                f[j] = (f[j] + f[j-i]) % mod;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="状态压缩dp">状态压缩DP</h4>
<h5 id="蒙德里安的梦想">蒙德里安的梦想</h5>
<p><strong>题目</strong></p>
<ul>
<li>求把 N × M 的棋盘分割成若干个 1×2 的长方形，有多少种方案。</li>
</ul>
<p><strong>集合表示</strong></p>
<ul>
<li><p>思路：先考虑放横着的方块，再用竖着的方块填充每一列</p></li>
<li><p>这就要求，每一列中连续空着的方块必须是偶数个，且第 i - 1
列不能伸到第 i 列的 1 的位置</p></li>
<li><p>f (i)(j)表示从第 i - 1 列伸出到第 i 列状态为 j 的方案数</p></li>
<li><p>j 的情况一共有 1 &lt;&lt; 列 种，表示
1表示当前行伸出，0则表示没有伸出</p></li>
</ul>
<p><strong>集合划分</strong></p>
<ul>
<li>由于第 i 列怎么摆放的已经由 f[i][j]中的 j 决定了，所以只需要确定第
i-1 列之前的是怎么摆的就行了</li>
<li>f[i][j] = f[i][j] + f[i-1][k]</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化版本，预处理法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12</span>, M = <span class="number">1</span> &lt;&lt; N;	<span class="comment">//N表示列数，M表示每一列的伸出情况</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[N][M];	<span class="comment">//方案数可能很大，所以用long long 来存</span></span><br><span class="line"><span class="type">bool</span> st[M];	<span class="comment">//表示当前列的状态的连续0的个数是否为偶数个</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; state[M];	<span class="comment">//记录第i行中的状态可以由哪些状态合法地转移过来：两行不冲突，且连续0的个数要为偶数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m, n || m)	<span class="comment">//连续读入多个询问</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++)	<span class="comment">//预处理st数组：枚举每一个状态</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;	<span class="comment">//记录连续0的个数</span></span><br><span class="line">            <span class="type">bool</span> is_valid = <span class="literal">true</span>;	<span class="comment">//判断标记</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)	<span class="comment">//遍历i的每一位，一共有n位</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>)	<span class="comment">//如果当前位上为1</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>)	<span class="comment">//0的个数为奇数</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        is_valid = <span class="literal">false</span>;	<span class="comment">//直接判定为false</span></span><br><span class="line">                        <span class="keyword">break</span>;	<span class="comment">//退出循环，不用在判断后面的位数了</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    cnt = <span class="number">0</span>;	<span class="comment">//cnt为偶数，则重新计算第j位后面的0的个数</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> cnt++;	<span class="comment">//否则的话cnt++</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>) is_valid = <span class="literal">false</span>;	<span class="comment">//如果j后面的0的个数为奇数，判断也是为false</span></span><br><span class="line">            st[i] = is_valid;	<span class="comment">//最终处理st[i]，表示i状态是否合法</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//预处理哪些状态能被成功转移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//有多组数据，但是只有一个数组，所以每次操作前需要对其清空</span></span><br><span class="line">            state[i].<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span>((i &amp; j) == <span class="number">0</span> &amp;&amp; st[i | j])	<span class="comment">// (i &amp; j) == 0 表示第i-1列伸出到第i后会不会与其发生冲突</span></span><br><span class="line">                    state[i].<span class="built_in">push_back</span>(j);		<span class="comment">//st[i | j] 表示第i-1列伸出后是否合法</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//有多组数据，但是只有一个数组，所以每次操作前需要对其清空</span></span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;	<span class="comment">//从第0列的前一行没有伸出到第0列的方案总数为1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//DP过程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)	<span class="comment">//枚举每一列，列数是从(0,m-1)因为厦门用到了i-1所以从1开始枚举</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; j++)	<span class="comment">//枚举每一列的状态</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> k : state[j])	<span class="comment">//枚举每一列可以由前一列的哪些状态转移过来，将他们全部相加即可</span></span><br><span class="line">                    f[i][j] += f[i<span class="number">-1</span>][k];</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; f[m][<span class="number">0</span>] &lt;&lt; endl;	<span class="comment">//f[m][0]表示从m-1列伸出到m列的块数为0，即所有棋盘划分完毕的状态</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最短hamilton路径">最短Hamilton路径</h5>
<p><strong>题目</strong></p>
<ul>
<li>给定一张 n 个点的带权无向图，点从 0∼n−1 标号，求起点 0 到终点 n−1
的最短 Hamilton 路径。Hamilton 路径的定义是从 0到 n−1
不重不漏地经过每个点恰好一次。</li>
</ul>
<p><strong>集合表示</strong></p>
<ul>
<li><p>f(i)(j) 表示当前路径为 i，最后的落脚点为 j 的路径长度，其中 i
用二进制数来表示，0 表示不走当前点，1表示走当前点</p></li>
<li><p>f[i][j] 表示当前路径为 i，最后的落脚点为 j
的最短路径长度</p></li>
</ul>
<p><strong>集合划分</strong></p>
<ul>
<li><p>i 中的任何一个点都可以由 i 中其他的点 k 走到，可以先从起点走到
k，再从 k 走到终点</p></li>
<li><p>f[i][j] = min(f[i][j], f[i-(1 &lt;&lt; j)][k] +
map[k][j])</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[M][N];	</span><br><span class="line"><span class="type">int</span> a[N][N];	<span class="comment">//存储地图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);	<span class="comment">//读入地图</span></span><br><span class="line">            </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);	<span class="comment">//求最小值，先初始化为无穷大</span></span><br><span class="line">    </span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;	<span class="comment">//从0点出发到0的路径为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++)	<span class="comment">//枚举每一个路径</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)	<span class="comment">//枚举路径中的每个点</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>)	<span class="comment">//如果j点包含在路径i中，则先走到其他点k</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)	</span><br><span class="line">                    <span class="keyword">if</span>(i &gt;&gt; k &amp; <span class="number">1</span>)	<span class="comment">//如果k包含在路径中，则先走到k，再走到j</span></span><br><span class="line">                        f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - (<span class="number">1</span> &lt;&lt; j)][k] + a[k][j]);</span><br><span class="line">    								<span class="comment">//f[i - (1 &lt;&lt; j)][k]表示新路径中不包括j这个点</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n - <span class="number">1</span>]);	<span class="comment">//f[(1 &lt;&lt; n) - 1][n - 1]表示所有点走走过(每一位均为1)，终点为n-1的最短路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="树形dp">树形DP</h4>
<h5 id="没有上司的舞会">没有上司的舞会</h5>
<p><strong>题目</strong></p>
<ul>
<li>Ural 大学有 N 名职员，编号为
1∼N。他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。每个职员有一个快乐指数，用整数
Hi 给出，其中
1≤i≤N。现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。</li>
</ul>
<p><strong>集合表示</strong></p>
<ul>
<li>f(i)(1) 表示以 i 为根节点，且 i 去的 happy 最大值</li>
<li>f(i)(0) 表示以 i 为根节点，且 i 不去的 happy 最大值</li>
</ul>
<p><strong>集合划分</strong></p>
<ul>
<li>f(i)(1) 表示上司去，则其子节点下属一定不能去 因此 f[i][1] = happy[i]
+ 其所有子节点 j 的 f[j][0]</li>
<li>f(i)(0) 表示上司不去，则其子节点下属可去可不去 因此 f[i][0] =
所有子节点 j 的max(f[j][0], f[j][1])</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> happy[N];	<span class="comment">//表示每个职员的快乐指数</span></span><br><span class="line"><span class="type">int</span> e[N], ne[N], h[N], idx;	<span class="comment">//存储树</span></span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>];	<span class="comment">//存储每一颗树的去或不去的最大值</span></span><br><span class="line"><span class="type">int</span> hf[N];	<span class="comment">//判断每个员工是否有父节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[u][<span class="number">1</span>] = happy[u];	<span class="comment">//f[u][1]在开始前先加上自己的快乐指数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])	<span class="comment">//遍历根节点的每一个子节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j);	<span class="comment">//先计算子节点的f[j][0] 和 f[j][1]</span></span><br><span class="line">        f[u][<span class="number">1</span>] += f[j][<span class="number">0</span>];		<span class="comment">//计算根节点的f[u][1]</span></span><br><span class="line">        f[u][<span class="number">0</span>] += <span class="built_in">max</span>(f[j][<span class="number">0</span>], f[j][<span class="number">1</span>]);	<span class="comment">//计算根节点的f[u][0]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;happy[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);	<span class="comment">//初始化h数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n <span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(b, a);	<span class="comment">//插入边 b -&gt; a</span></span><br><span class="line">        hf[a] = <span class="literal">true</span>;	<span class="comment">//表示a有父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> root = <span class="number">1</span>;	<span class="comment">//寻找根节点——没有父节点的节点</span></span><br><span class="line">    <span class="keyword">while</span>(hf[root]) root++;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(root);	<span class="comment">//求f[root][0] 和 f[root][1]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出最大值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">max</span>(f[root][<span class="number">0</span>], f[root][<span class="number">1</span>]));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="记忆化搜索">记忆化搜索</h4>
<h5 id="滑雪">滑雪</h5>
<p><strong>题目</strong></p>
<ul>
<li>给定一个 R 行 C 列的矩阵，表示一个矩形网格滑雪场。矩阵中第 i 行第 j
列的点表示滑雪场的第 i 行第 j
列区域的高度。一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。</li>
</ul>
<p><strong>集合表示</strong></p>
<ul>
<li>f(i)(j) 从点 (i, j) 开始滑雪的路径</li>
<li>f[i][j] 表示所有从点 (i, j) 开始滑雪的路径中的路径长度最大值</li>
</ul>
<p><strong>集合划分</strong></p>
<ul>
<li>每个路径可以依据下一步往哪走划分为四个不同的类型（上下左右）</li>
<li>f[i][j] = max(上下左右路径长度 + 1)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> map[N][N];	<span class="comment">//表示滑雪场的地图</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>	<span class="comment">//记忆化搜索的模板，返回的是f[a][b]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>&amp; v = f[a][b];	<span class="comment">//用引用来代替f[a][b]</span></span><br><span class="line">    <span class="keyword">if</span>(v != <span class="number">-1</span>) <span class="keyword">return</span> v;	<span class="comment">//如果f[a][b]已经存在，则直接返回</span></span><br><span class="line">    v = <span class="number">1</span>;	<span class="comment">//再不济，v最小也是1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)	<span class="comment">//遍历四个方向</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = a + dx[i], y = b + dy[i];	<span class="comment">//获取四个方向的行列数</span></span><br><span class="line">        <span class="comment">//四个方向的行数x必须小于等于n，列数必须小于等于m，且新坐标的高等必须小于原坐标的高度才能滑动</span></span><br><span class="line">        <span class="keyword">if</span>(x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= m &amp;&amp; map[a][b] &gt; map[x][y])</span><br><span class="line">            v = <span class="built_in">max</span>(<span class="built_in">dp</span>(x, y) + <span class="number">1</span>, v);	<span class="comment">//dp(x,y)返回新坐标的f数组值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="comment">//读入高度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;map[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义res为答案</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化f数组为-1</span></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最长路径可能从任何一个点出发，所以需要每一个点都计算一次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">dp</span>(i, j));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法</title>
    <url>/posts/b32e57d2/</url>
    <content><![CDATA[<h4 id="快速排序">快速排序</h4>
<p><strong>时间复杂度</strong></p>
<ul>
<li><span class="math inline">\(O(n\log n)\ —\ O(n^2)\)</span></li>
</ul>
<ol type="1">
<li>确定分界点：找到将数组分为两半的值</li>
<li>利用两个指针进行排序：使左指针左边的数全都小于分界值；右指针右边的数全都大于分界值</li>
<li>递归调用：重新对原数组分成的子数组进行快速排序 <span id="more"></span>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//template code</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span>	<span class="comment">//注意l和r都为数组的下标 一般l为0，r为 (数组长度-1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( l&gt;=r ) <span class="keyword">return</span>;		<span class="comment">//若数组中只有一个元素，则无需排序</span></span><br><span class="line">    <span class="type">int</span> p = q[(l+r) &gt;&gt; <span class="number">1</span>],i = l - <span class="number">1</span>,j = r + <span class="number">1</span>;	<span class="comment">//取数组中间的值作为基准值</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i]&lt;p);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j]&gt;p);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) <span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hallo world&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,l,j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,j+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="归并排序">归并排序</h4>
<p><strong>时间复杂度</strong></p>
<ul>
<li><span class="math inline">\(O(n\log n)\)</span></li>
</ul>
<ol type="1">
<li>确定分界点：找到将数组分为两半的下标</li>
<li>递归调用：对分成的两个数组进行排序</li>
<li>比较元素：迭代比较两个数组的每个元素，将较小的放入临时数组中，若相等则指定选一个放</li>
<li>收集元素：两个数组中剩下的元素插入到临时数组中</li>
<li>收集元素：将临时数组中的元素插入到目标数组中</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//template code</span></span><br><span class="line"><span class="type">int</span> q[N],temp[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;	<span class="comment">//若数组中只有一个元素，则无需排序</span></span><br><span class="line">    <span class="type">int</span> mid = l+r &gt;&gt; <span class="number">1</span>, i = l, k = <span class="number">0</span>;	</span><br><span class="line">    <span class="type">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q,l,mid);	<span class="comment">//对两段数组进行递归调用</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(q,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j &lt;= r)		<span class="comment">//两个数组的元素逐一进行比较，将较小的放置临时的数组中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i]&lt;=q[j]) temp[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span> temp[k++] = q[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) temp[k++] = q[i++];<span class="comment">//指针指到末尾，可能另一个指针没有走到，需要将剩余元素添加</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) temp[k++] = q[j++];	 <span class="comment">//到临时数组中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二分算法">二分算法</h4>
<p><strong>本质</strong></p>
<ul>
<li>求边界点：每次将区间一分为二，当区间长度等于1时，即为边界点</li>
</ul>
<p><strong>核心</strong></p>
<ul>
<li>确定一个逻辑，使其可以将整个区间一分为二，一段满足该逻辑的，另一段则不满足该逻辑</li>
</ul>
<h5 id="整数二分">整数二分</h5>
<p><strong>分类</strong></p>
<ol type="1">
<li>在满足逻辑区间内求左端点：取中间值时需要+1</li>
<li>在满足逻辑区间内求右端点：取中间值时不需要+1</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//整数二分 template code</span></span><br><span class="line"><span class="comment">//case1：求check(mid)为true区间的的左边界</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;	<span class="comment">//先取中间值</span></span><br><span class="line">        <span class="keyword">if</span>(check(mid)) r = mid;	<span class="comment">//check(mid)为判断逻辑，若为true，则r=mid(减半区间)</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;	<span class="comment">//若不满足逻辑，则目标值一定在mid的下一个位置之后</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//case2：求check(mid)为true区间的的右边界</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;	<span class="comment">//先取中间值, 特别注意：取中间值的时候需要加1</span></span><br><span class="line">        <span class="keyword">if</span>(chech(mid)) l = mid;	<span class="comment">//check(mid)为判断逻辑，若为true，则l=mid(减半区间)</span></span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;	<span class="comment">//若不满足逻辑，则目标值一定在mid的前一个位置之前</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong></p>
<ul>
<li>有些题目中 l + r 会爆int，所以可以改为 int mid = l + (r - l &gt;&gt;
1), 这样就不会爆</li>
</ul>
<h5 id="浮点数二分">浮点数二分</h5>
<p><strong>特性</strong></p>
<ul>
<li>有确定的中间值，无需像整数二分一样考虑边界问题</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//template code</span></span><br><span class="line">bool <span class="title function_">check</span><span class="params">(<span class="type">double</span> x)</span> &#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    const <span class="type">double</span> <span class="variable">eps</span> <span class="operator">=</span> <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求 一般为精度的1/100</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例题：给定一个浮点数 n求它的三次方根 -10000 &lt; n &lt; 10000</span></span><br><span class="line"><span class="type">double</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">double</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">10000</span>, r = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">while</span>((r-l) &gt;= <span class="number">1e-8</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">mid</span> <span class="operator">=</span> (r + l) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid*mid*mid &gt;= n) r = mid;	<span class="comment">//ture则从mid之前找目标值</span></span><br><span class="line">    <span class="keyword">else</span> l = mid;</span><br><span class="line">&#125;</span><br><span class="line">printf(<span class="string">&quot;%lf&quot;</span>,l);		<span class="comment">//l即为最终答案</span></span><br></pre></td></tr></table></figure>
<h4 id="高精度运算">高精度运算</h4>
<h5 id="高精度加法">高精度加法</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//template code</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span>	<span class="comment">//vector容器中从低位到高位存储数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;		<span class="comment">//用来表示进位与否</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>(); i++)	<span class="comment">//模拟现实中的加法过程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.<span class="built_in">size</span>()) t += A[i];		<span class="comment">//t相当于每个位上的临时结果</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t += B[i];		<span class="comment">//某一位上B或A没有数，相当于为0 </span></span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);	<span class="comment">//将结果t取余插入新的容器中</span></span><br><span class="line">        t /= <span class="number">10</span>;	<span class="comment">//更新t，向0取整，结果没有小数，t的最大值为9</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="高精度减法">高精度减法</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//template code</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; A, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; B)</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//使用前提：A一定要大于B</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)	<span class="comment">//模拟现实中减法的运算</span></span><br><span class="line">    &#123;	<span class="comment">//t相等于临时结果</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.<span class="built_in">size</span>()) t = A[i] - t;	<span class="comment">//t相等于借1与否			</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t -= B[i];		<span class="comment">//t = t - B[i]		</span></span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);	<span class="comment">//两种情况合并到一起</span></span><br><span class="line">        <span class="keyword">if</span>(t &gt;= <span class="number">0</span>) t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();		<span class="comment">//去除前导零</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于比较两个数的大小，关注一下比较的逻辑</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">com</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; A, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();	<span class="comment">//长度不等直接比</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span>(A[i] != B[i])	<span class="comment">//长度相等，从最高位开始比较，直到位上的数有差异</span></span><br><span class="line">                <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="高精度乘法">高精度乘法</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//template code		和加法模板相似</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;				<span class="comment">//和实际中的乘法不一样，将大的数的每一位直接与较小的数相乘，而不是较小数的每一位</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.<span class="built_in">size</span>()) t = A[i] * b + t;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);	<span class="comment">// ‘%’表示最终结果</span></span><br><span class="line">        t /= <span class="number">10</span>;		<span class="comment">// ‘/’表示进位 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*	非 ‘||t’ 的写法</span></span><br><span class="line"><span class="comment">    	while(t)</span></span><br><span class="line"><span class="comment">    	&#123;</span></span><br><span class="line"><span class="comment">    		C.push_back(t % 10);</span></span><br><span class="line"><span class="comment">    		t /= 10;</span></span><br><span class="line"><span class="comment">    	&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();	<span class="comment">//去前导零</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="高精度除法">高精度除法</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//template code		和乘法相似</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i  = A.<span class="built_in">size</span>() <span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) <span class="comment">//因为除法从高位开始算，所以i从size - 1开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        r = A[i] + r * <span class="number">10</span>;		<span class="comment">//处理高位留下来的数字，需要乘上10</span></span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);		<span class="comment">//注意这里 插入的是r / b 因为是除法</span></span><br><span class="line">        r %= b;					<span class="comment">//高位剩下的为 r % b</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());	<span class="comment">//结果需要翻转（如果打印从数组末尾开始打印）</span></span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();  </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="前缀和">前缀和</h4>
<h5 id="一维数组">一维数组</h5>
<ul>
<li>利用递推公式求an an = sn - sn-1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;		<span class="comment">//a[]数组则代表着数列	s[]数组表示an的前n项和数列</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);	<span class="comment">//注意：前缀和一般从1开始，方便处理边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s[i] = s[i<span class="number">-1</span>] + a[i];	<span class="comment">//求前缀和的公式：利用an与sn的关系</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[r] - s[l - <span class="number">1</span>]);		<span class="comment">//利用an与sn的关系</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="二维数组-矩阵">二维数组 (矩阵)</h5>
<ul>
<li>求子矩阵的和：一维数组的公式推广至二维</li>
<li>an 与 sn 的关系：a[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] +
a[i][j]</li>
<li>求子矩阵公式：左上顶点坐标 (x1, y1) 右下顶点坐标 (x2, y2)
<ul>
<li>S[x2, y2] - S[x1-1, y2] - S[x2, y1-1] + S[x1-1, y1-1]</li>
</ul></li>
</ul>
<p><img src="/images/二维前缀和.png" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)		<span class="comment">//读取an</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);		<span class="comment">//注意：前缀和一般从1开始，方便处理边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)		<span class="comment">//利用an与sn的关系求sn</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="comment">//求(1, 1)到(i, j)的矩阵的前缀和公式	想不明白就画图 —— 分成两部分相加</span></span><br><span class="line">            s[i][j] = s[i][j<span class="number">-1</span>] + s[i<span class="number">-1</span>][j] + a[i][j] - s[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">        <span class="comment">//求(x1, y1)到(x2, y2)矩阵的前缀和公式 想不明白就画图</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[x2][y2] - s[x2][y1<span class="number">-1</span>] - s[x1<span class="number">-1</span>][y2] + s[x1<span class="number">-1</span>][y1<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="差分算法">差分算法</h4>
<p><strong>定义</strong></p>
<ul>
<li>差分本质上是前缀和的逆运算 若 bn 的前缀和等于 an 则称 bn 为 an
的差分</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>当需要将给定数组an中的一段区间 [l , r] 的每一个元素都加上一个数 v
时，可以将时间复杂度从 o(n) 降至 o(1)
<ul>
<li>当b[l] + v 时，a[l] 及之后的元素都会加上一个v</li>
<li>当b[r+1] - v 时，a[r + 1]及之后的每个元素都会减上一个v</li>
<li>因此只需要同时满足 b[l] + v 和 b[r+1] - v
即能使原数组an指定区间的每个元素都加上指定值</li>
</ul></li>
</ul>
<p><strong>构造差分数组</strong></p>
<ul>
<li>假设数组a中的每个元素都是0，则数组b中的每个元素也是0</li>
<li>若a的某个位置有元素，相当于在该位置加上了一个数组：例如，a[2] = 11
等价于 b[2] += a[2]，b[2 + 1] -= a[2]</li>
<li>因此无需刻意构造差分数组，了解这个思想就行</li>
</ul>
<h5 id="一维数组差分">一维数组差分</h5>
<p><strong>核心代码</strong></p>
<ul>
<li>b[l] += v , b[r+1] -= v</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span>	<span class="comment">//核心code</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[l] += v;</span><br><span class="line">    b[r + <span class="number">1</span>] -= v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">insert</span>(i, i, a[i]);		<span class="comment">//构造差分数组</span></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;	<span class="comment">//插入过程</span></span><br><span class="line">        <span class="type">int</span> l, r, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;v);</span><br><span class="line">        <span class="built_in">insert</span>(l, r, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将差分数组转换成原数组，利用差分数组的前n项和等于原数组第n项</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) b[i] += b[i<span class="number">-1</span>];		</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二维数组差分">二维数组差分</h5>
<p><strong>核心代码</strong></p>
<ul>
<li>给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c
<ul>
<li>S[x1, y1] += c, S[x2+1, y1] -= c, S[x1, y2+1] -= c, S[x2+1, y2+1] +=
c</li>
</ul></li>
</ul>
<p><strong>图解注释</strong></p>
<p><img src="/images/差分矩阵.png" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">int</span> a[N][N], b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//想不明白的时候就画张图</span></span><br><span class="line">    b[x1][y1] += v;</span><br><span class="line">    b[x2+<span class="number">1</span>][y1] -= v;</span><br><span class="line">    b[x1][y2+<span class="number">1</span>] -= v;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);		<span class="comment">//读取原数组</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="built_in">insert</span>(i, j, i, j, a[i][j]);	<span class="comment">//构造差分数组</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;	<span class="comment">//插入过程</span></span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2, v;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; v;</span><br><span class="line">        <span class="built_in">insert</span>(x1, y1, x2, y2, v);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="comment">//求前缀和的模板</span></span><br><span class="line">            b[i][j] = b[i<span class="number">-1</span>][j] + b[i][j<span class="number">-1</span>] - b[i<span class="number">-1</span>][j<span class="number">-1</span>] + b[i][j]; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i][j]);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="双指针算法">双指针算法</h4>
<p><strong>模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= i &amp;&amp; <span class="built_in">check</span>(j, i)) j++;	<span class="comment">//check()为判定条件</span></span><br></pre></td></tr></table></figure>
<p><strong>优点</strong></p>
<ul>
<li>将需要两个for循环 转成一个for循环</li>
<li>时间复杂度由 n方 优化成 n</li>
</ul>
<p><strong>本质</strong></p>
<ul>
<li>一个指针 i 用于遍历数组的每个元素，另一个指针 j 用于遍历指针 i
之前的数据</li>
</ul>
<p><strong>例题</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求最长连续不重复子序列的长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//核心代码</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;	<span class="comment">//开辟一个新的数组用于判断是否含有重复元素</span></span><br><span class="line">        s[a[i]] ++;		<span class="comment">//记录i位置上元素的个数	</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt;= i &amp;&amp; s[a[i]] &gt; <span class="number">1</span>)	<span class="comment">//其中的j &lt;= i 此题可以省略，当j = i时s[a[i]] = 0</span></span><br><span class="line">        &#123;								<span class="comment">//条件不成立</span></span><br><span class="line">            s[a[j]]--;		<span class="comment">//j向前移动原来位置上的值的出现次数需要减1</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);	<span class="comment">//更新res</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="位运算">位运算</h4>
<h5 id="x在二进制中的第k位数">x在二进制中的第k位数</h5>
<p><strong>模板代码</strong></p>
<ul>
<li>res = (x &gt;&gt; k) &amp; 1
先将k位置上的数移动到最后一位，然后将结果位与上1即为答案</li>
</ul>
<h5 id="lowbit">lowbit</h5>
<p><strong>作用</strong></p>
<ul>
<li>求二进制数的最后一个1的位置</li>
</ul>
<p><strong>代码模板</strong></p>
<ul>
<li>x &amp; -x</li>
</ul>
<p><strong>例题</strong></p>
<ul>
<li>统计二进制数 x 中1的个数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);		<span class="comment">//返回值为X的二进制表达式中最低位的1所对应的值</span></span><br><span class="line">&#125;							<span class="comment">//例如lowbit(8)的返回值就是00001000</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x, res = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="comment">//找到x最后一个1的位置的时候就将其减去，直到x所有位置都被遍历</span></span><br><span class="line">    <span class="keyword">while</span>(x) x -= <span class="built_in">lowbit</span>(x), res++;		<span class="comment">//-=的操作相当于把x的最后一位1去掉变成0</span></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="只出现一次的数字"><strong>只出现一次的数字</strong></h5>
<p><a
href="https://leetcode.cn/problems/single-number/">原题链接</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用了异或运算的特性，0与任何一个数异或结果都是该数本身，任何数与其本身异或结果都是0</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : nums) res ^= x;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="只出现一次的数字ii">只出现一次的数字II</h5>
<p><a
href="https://leetcode.cn/problems/single-number-ii/">原题链接</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解法一：利用位运算的性质，对于数组中所有元素统计第i位(i&lt;32)位上的数的异或和，如果该异或和是三的倍数，则表示这个只出现过一次的数的第i位为0，如果不是三的倍数，则该数的第i位为1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e : nums)</span><br><span class="line">                cnt += (e &gt;&gt; i &amp; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(cnt % <span class="number">3</span>)</span><br><span class="line">                res |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//解法二：涉及数字电路设计的知识，可背下来当做模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            a = (a ^ e) &amp; ~b;</span><br><span class="line">            b = (b ^ e) &amp; ~a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//解法三：用哈希表当然可以解决，只不过效率么...</span></span><br></pre></td></tr></table></figure>
<h4 id="离散化">离散化</h4>
<p><strong>本质</strong></p>
<ul>
<li>一种映射关系</li>
</ul>
<p><strong>适用场景</strong></p>
<ul>
<li>当数据的范围很大，但是数据的集中程度很低时（数据很稀疏）</li>
</ul>
<p><strong>过程</strong></p>
<ul>
<li><p>先将数据进行去重和排序（C++的标准操作）</p>
<ul>
<li>sort(alls.begin( ), alls.end( ))</li>
<li>alls.erase(unique(alls.begin( ), alls.end( )), alls.end( ))</li>
</ul></li>
<li><p>可以将数据存放至数组中，将其真实的值映射成数组的下标索引</p></li>
<li><p>根据真实值找到映射的索引值（利用二分进行查找）</p></li>
</ul>
<h4 id="区间合并">区间合并</h4>
<p><strong>内容</strong></p>
<ul>
<li>若两个区间有交集，则将其合并为一个区间（取并集）;若没有交集则不做操作处理</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;		<span class="comment">//设定区间端点的边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> seg : segs)		<span class="comment">//segs表示所有区间</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ed &lt; seg.first)		<span class="comment">//ed &lt; seg.first 表示两个区间没有交集</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ed != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);	<span class="comment">//if语句排除第一个区间，把上一个区间插入到res中	</span></span><br><span class="line">            <span class="comment">//两个区间没有交集，则更新维护的区间</span></span><br><span class="line">            st = seg.first;		</span><br><span class="line">            ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//else有两种情况，一种是两个区间相等；另一种是两个区间有交集，且右端点大于ed</span></span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//if语句防止segs中只有一个元素时误判；当segs中只剩最后一个区间时，直接将其添加到答案容器res中</span></span><br><span class="line">    <span class="keyword">if</span>(st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="回溯算法">回溯算法</h4>
<p><strong>思路</strong></p>
<ul>
<li>它的一般思路是尝试在每一步选择一个元素或者不选择元素，直到找到合适的结果或者已经枚举完所有的可能性。在这个过程中，如果发现当前选择会导致后续无法得到可行解，就会回溯到之前的状态，重新做选择，继续探索其他可能性。</li>
</ul>
<p><strong>性质</strong></p>
<ul>
<li>深度优先搜索：回溯算法采用的是深度优先搜索的策略，即选定一个方向走到底，再返回上一层，继续搜索其他方向</li>
<li>逐步构建解：在回溯算法中，每一层递归都会添加或删除一个元素，逐步构建可行解</li>
<li>剪枝优化：在回溯算法中，可以通过剪枝操作来减少搜索空间，提高算法效率。比如，在组合问题中，如果当前已经选了
k 个数，还需要选 n - k 个数，但是数组中只剩下 m
个数可选，此时就可以直接退出循环，因为不可能选够 n - k 个数了</li>
</ul>
<p><strong>例题</strong></p>
<ol type="1">
<li><a href="https://leetcode.cn/problems/permutations/">全排列</a>
:给一个不包含重复元素数组，返回其全排列</li>
<li><a href="https://leetcode.cn/problems/permutations-ii/">全排列II</a>
:给一个可包含重复元素数组，返回其全排列</li>
<li><a href="https://leetcode.cn/problems/path-sum-ii/">路径总和II</a>
:一道二叉树的遍历，求路径</li>
<li><a href="https://leetcode.cn/problems/combinations/">组合</a>
:给定两个整数n和k，返回范围[1, n]中所有可能的k个数的组合 :
返回的每一个片段长度是一样的，都是k</li>
<li><a href="https://leetcode.cn/problems/subsets/">子集</a>
:经典的一道回溯算法题目，返回给定数组的所有子集，返回的每一个片段的长度是不一样的</li>
<li><a
href="https://leetcode.cn/problems/generate-parentheses/">括号生成</a>
:对于待插入的值有先后的要求的回溯:
优先插入左括号，当数组中右括号的数量严格小于左括号的时候才可以插入右括号</li>
</ol>
<p><strong>算法模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//x表示当前seg中元素的个数</span></span><br><span class="line">    <span class="keyword">if</span>(特定条件 通常为 x == n)</span><br><span class="line">    &#123;</span><br><span class="line">   		res.<span class="built_in">emplace_back</span>(seg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        seg.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">    	<span class="built_in">dfs</span>(x + <span class="number">1</span>, i);    </span><br><span class="line">        seg.<span class="built_in">pop_back</span>();		<span class="comment">//操作都是对称的，这样才能实现回溯，最终seg是为空的</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>求子集的模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; seg;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> start, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(seg);</span><br><span class="line">        <span class="keyword">if</span>(start == n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            seg.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(i+<span class="number">1</span>, nums);</span><br><span class="line">            seg.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数学知识</title>
    <url>/posts/374e1302/</url>
    <content><![CDATA[<h4 id="质数">质数</h4>
<h5 id="试除法判断质数">试除法判断质数</h5>
<ul>
<li>无需遍历至n-1，只需要遍历到sqrt(n)即可</li>
<li>时间复杂度：O(sqrt(n))</li>
<li>循环一定执行根号n次</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="分解质因数">分解质因数</h5>
<ul>
<li>时间复杂度最坏的情况：O(sqrt(n))</li>
<li>循环不一定执行根号n次</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">div</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>) x /= i, s++;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="质数的判定">质数的判定</h5>
<h6 id="朴素筛法">朴素筛法</h6>
<ul>
<li>用每一个数取筛掉它的倍数</li>
<li>时间复杂度：O(n * log(n))</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">filter</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + i; j &lt;= n; j += i)</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="埃氏筛法">埃氏筛法</h6>
<ul>
<li>只用质数作筛选</li>
<li>时间复杂度：O(n * log (log( n ) ) )</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断1~n中有多少个质数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">bool</span> st[N];	<span class="comment">//true表示不是质数，false表示为质数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">esift</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i]) <span class="keyword">continue</span>;</span><br><span class="line">        cnt++:</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + i; j &lt;= n; j += i)</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="欧拉筛法线性筛法">欧拉筛法（线性筛法）</h6>
<ul>
<li>作用与埃氏算法一致</li>
<li>时间复杂度：O( n )</li>
<li>之所以被称为线性是因为该算法保证了每个数只会被筛选一次：即每次用这个数的最小质因子进行筛选</li>
<li>每个数的最小质因子只有一个，所以每个数只会被筛选一次</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断1~n中有多少个质数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">bool</span> st[N];	<span class="comment">//st为1表示不为质数，为0表示为质数</span></span><br><span class="line"><span class="type">int</span> primes[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">osift</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) primes[cnt++] = i;	<span class="comment">//如果i为质数则加入质数数组中</span></span><br><span class="line">        <span class="comment">//对和数进行筛选</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)	<span class="comment">//primes[j] &lt;= n 等价于 i * primes[j] &lt;= n，待删除的数不能超过n</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//注意：质数数组中的数字是从大到小的</span></span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;	<span class="comment">//1.如果primes[j]不为i的最小质因数，但其一定为primes[j] * i 的最小质因数，可以删除</span></span><br><span class="line">            <span class="comment">//如果primes[j]是i的最小质因数，则必须退出循环，否则在下一次删除的过程中就不是靠最小质因数来删除了</span></span><br><span class="line">            <span class="comment">//假设没结束，则标记 primes[j + 1] * i 为true 但i已经有了最小质因数primes[j]了，因此必须退出循环</span></span><br><span class="line">            <span class="comment">//不退出循环的话，只会重复筛选</span></span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;	</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="约数">约数</h4>
<p><strong>概念</strong></p>
<ul>
<li>能将其整除的除数（分母），包括其本身</li>
</ul>
<h5 id="试除法求约数">试除法求约数</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">divise</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x / i; i++)	<span class="comment">//i表示x可能的约数，其中只需要枚举小于根号x的i即可，因为约数是成对存在的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            d.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(i != x / i) d.<span class="built_in">push_back</span>(x / i);	<span class="comment">//插入大于根号x的除数，但要注意判重</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());	<span class="comment">//从小到大排序</span></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="约数个数">约数个数</h5>
<p><strong>题目</strong></p>
<ul>
<li>给定 n 个数，求其相乘后得到的数的约数个数，结果对 1e9 + 7 取模</li>
</ul>
<p><strong>思路</strong></p>
<ul>
<li><p>首先我们需要得到相乘后的数的 质数的分解因式：a1<sup>p1</sup> *
a2<sup>p2</sup> * ... * an<sup>pn</sup></p></li>
<li><p>则其约数个数为：(p1 + 1) * (p2 + 1) * ... * (pn + 1)</p></li>
<li><p>任何一个数都可以被分解质因数相乘的形式，其约数就是按照这因式进行全排列</p></li>
<li><p><strong>全排列的个数就是所有因数的个数</strong></p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; primes;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整个while循环就是在做一件事，将最后相乘得到的结果进行质因数的分解，first = a表示底数，second = p表示指数</span></span><br><span class="line"><span class="keyword">while</span>(n--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++)	<span class="comment">//分解质因数的模板</span></span><br><span class="line">    	<span class="keyword">while</span>(x % i == <span class="number">0</span>) x /= i, primes[i]++;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>) primes[x]++;	<span class="comment">//插入大于根号x的质因数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;	<span class="comment">//res表示最终结果的约数个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p : primes) res = res * (p.second + <span class="number">1</span>) % mod;	<span class="comment">//套入公式，根据取模运算的性质，可以先对中间结果取模</span></span><br><span class="line">cout &lt;&lt; res &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h5 id="约数之和">约数之和</h5>
<p><strong>题目</strong></p>
<ul>
<li>给定 n 个数，求其相乘后得到的数的约数之和，结果对 1e9 + 7 取模</li>
</ul>
<p><strong>思路</strong></p>
<ul>
<li>首先我们需要得到相乘后的数的 质数的分解因式：a1<sup>p1</sup> *
a2<sup>p2</sup> * ... * an<sup>pn</sup></li>
<li>其约数之和为：(a<sub>1</sub><sup>0</sup> + a<sub>1</sub><sup>1</sup>
+ ... a<sub>1</sub><sup>p1</sup>) * ( a<sub>2</sub><sup>0</sup> +
a<sub>2</sub><sup>2</sup> + ... a<sub>2</sub><sup>p2</sup>) * ... *
(a<sub>n</sub><sup>0</sup> + a<sub>n</sub><sup>1</sup> + ...
a<sub>n</sub><sup>pn</sup>)</li>
<li>证明：任意数的约数为其质数分解因式的全排列，将所有约数相加后提取公因式就可以得到上述公式</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; primes;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先我们还是需要得到最终数的质数分解因式</span></span><br><span class="line"><span class="keyword">while</span>(n--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++)	<span class="comment">//分解质因数的模板</span></span><br><span class="line">    	<span class="keyword">while</span>(x % i == <span class="number">0</span>) x /= i, primes[i]++;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>) primes[x]++;	<span class="comment">//插入大于根号x的质因数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//求约数之和的过程</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> e : primes) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> a = e.first, p = e.second;</span><br><span class="line">    <span class="keyword">while</span>(p--) t = (t * a + <span class="number">1</span>) % mod;	<span class="comment">//求a的0次方加到a的p次方的简化写法，+1是这里最有灵魂的地方</span></span><br><span class="line">    res = res * t % mod;	<span class="comment">//同上，先对中间乘数求模不影响最终结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; res &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h5 id="最大公约数">最大公约数</h5>
<p><strong>思路</strong></p>
<ul>
<li>欧几里得算法：辗转相除法</li>
<li>算法核心：gcd(a, b) = gcd(b, a % b)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gcd函数返回a与b的最大公约数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b,a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="欧拉函数">欧拉函数</h4>
<p><strong>定义</strong></p>
<ul>
<li><p>记 φ(x) 为欧拉函数，表示 1~x 中与 x 互质的数的个数</p></li>
<li><p>求 φ(x) 的公式：φ(x) = x * (1 - 1 / p<sub>1</sub>) * (1 - 1 /
p<sub>2</sub>) * ... * (1 - 1 / p<sub>n</sub>)</p></li>
<li><p>其中 p<sub>1</sub>, p<sub>2</sub>, ... ,
p<sub>n</sub>表示x的所有质因数</p></li>
<li><p>证明：利用互斥原理证明</p></li>
</ul>
<h5 id="定义法求欧拉函数">定义法求欧拉函数</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回x对应的欧拉函数的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_ora</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = x;</span><br><span class="line">    <span class="comment">//分解质因数的模板</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x % i== <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);	<span class="comment">//注意需要先作除法后作乘法，因为在运算过程中可能会爆int</span></span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//大于根号x的质因数也要算入其中</span></span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="筛法求欧拉函数">筛法求欧拉函数</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> phi[N], primes[N], cnt;	<span class="comment">//phi[]表示欧拉函数</span></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//在之前的欧拉筛质数时，我们发现欧拉筛的过程中可以得到每个数的质因子，可以利用这一性质求欧拉函数</span></span><br><span class="line"><span class="comment">//对于求 1~n 中每个数的欧拉函数有效</span></span><br><span class="line"><span class="function">LL <span class="title">ora</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])	</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>;	<span class="comment">//如果i为质数，则i的欧拉值为 i - 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行筛选</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = i * primes[j];	<span class="comment">//为了方便阅读，现将其用t表示，无其他特殊含义</span></span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                phi[t] = phi[i] * primes[j];	<span class="comment">//如果pj是i的质因数，则phi[t]只是在原来的基础上乘上了个pj而已</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果pj不是i的质因数，则ph[t] 相对于phi[i]只是在phi[i]的基础上乘了[pj * (1 - 1 / pj)] 即 (primes[j] - 1)</span></span><br><span class="line">            phi[t] = phi[i] * (primes[j] - <span class="number">1</span>);	<span class="comment">//不能先写到前面，因为需要先判断pj是否为i的质因数	</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//对所有数的欧拉值求和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res += phi[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="欧拉定理">欧拉定理</h5>
<p><strong>内容</strong></p>
<ul>
<li><p><span class="math inline">\(a ^ {\phi(m)} \equiv 1\
mod(m)\)</span></p></li>
<li><p>其中 <span class="math inline">\(a、m \in N^+\)</span></p></li>
</ul>
<h5 id="费马小定理">费马小定理</h5>
<p><strong>内容</strong></p>
<ul>
<li><p>欧拉定理的特例：当m为质数时，<span class="math inline">\(\phi(m)
= m - 1\)</span></p></li>
<li><p><span class="math inline">\(a^{m-1} \equiv 1\
mod(m)\)</span></p></li>
</ul>
<h4 id="快速幂">快速幂</h4>
<p><strong>概念</strong></p>
<ul>
<li><p>快速幂算法用来求 <span class="math inline">\(a^k \ \% \
p\)</span></p></li>
<li><p>时间复杂度：O(logn)</p></li>
<li><p>就是先求 <span class="math inline">\(a^{2^0}、a^{2^1}...\
a^{2^n}\)</span>，这些数相乘就会得到 <span
class="math inline">\(a^{2^0+2^1+\ ...\ +2^n}\)</span></p></li>
<li><p>通过凑配让 k = 2<sup>0</sup>+ 2<sup>1</sup>+ 2<sup>2</sup>+ ... +
2<sup>n</sup> ，可以发现1,2...n就是k的用二进制表示的数</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;	<span class="comment">//起初res = 1;</span></span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果k的二进制数最后一位是1则乘上a</span></span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//a现在表示的是当移动到k的二进制的第i位时，a的(2^i)次方，此数每次必须更新，你可以不用，但我必须更新</span></span><br><span class="line">        a = (LL)a * a % p;	<span class="comment">//每次需要将i加1，即对a进行平方</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="快速幂求逆元">快速幂求逆元</h5>
<p><strong>逆元的概念</strong></p>
<ul>
<li>若 <span class="math inline">\(gcd(a,p)=1\)</span>，则一定存在一个数
x 使得 <span class="math inline">\(ax\equiv1\ mod(p)\)</span>，则记x为 a
模 p 的一个乘法逆元</li>
<li>由费马小定理知：<span class="math inline">\(p\)</span> 为质数时，有
<span class="math inline">\(a^NaN\equiv1\
mod(p)\)</span></li>
<li>因此，<span class="math inline">\(a^{p-2}\)</span>
为x的一个解，转换成了快速幂的问题</li>
<li>因为题目要求 x &lt;= p - 1，所以需要模上一个p，就构成了 <span
class="math inline">\(qmi(a,p-2,p)\)</span> 的参数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span>		<span class="comment">//快速幂的模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = (LL)a * a % p;	<span class="comment">//可以不用，但不能不更新</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, p;	<span class="comment">//a即为上文概念中的b，p即为模数m</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;p);		<span class="comment">//快速幂求逆元的前提是a，p互质</span></span><br><span class="line">        LL res = <span class="built_in">qmi</span>(a, p - <span class="number">2</span>, p);	<span class="comment">//qmi求的是 a ^ (p - 2) % p，有费马小定理可以推出</span></span><br><span class="line">        <span class="keyword">if</span>(a % p == <span class="number">0</span>)	<span class="comment">//如果a是p的倍数，则永远不可能存在a的乘数逆元</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="扩展欧几里得算法">扩展欧几里得算法</h4>
<p><strong>背景</strong></p>
<ul>
<li><p>对于任意一对正整数 <span class="math inline">\((a,b)\)</span>
一定存在一组<span class="math inline">\((x,y)\)</span> 使得 <span
class="math inline">\(ax+b×y=gcd(a,b)\)</span></p></li>
<li><p>利用欧几里得算法可以求解，因为<span
class="math inline">\(gcd(a,b)=gcd(b,a\%b)\)</span></p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span>	<span class="comment">//注意传的是引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;	<span class="comment">//当b=0时，满足a * x + 0 = a 的一组解为 (1,0)</span></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1, <span class="type">int</span> x2;	<span class="comment">//x1, x2表示递归下一级的系数</span></span><br><span class="line">        <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a%b, x1, x2);</span><br><span class="line">        <span class="comment">//上一级的系数与下一级的系数的关系，可以推导 (b, a % b) =&gt; b*x1 + (a - [a/b] * b)y1</span></span><br><span class="line">        <span class="comment">//ax + by = ay1 + b(x1 - [a/b]*y1) =&gt; x = y1, y = x1 - (a/b) * y1;</span></span><br><span class="line">        x = y1, y = x1 - (a / b) * y1;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="线性同余方程">线性同余方程</h5>
<p><strong>概念</strong></p>
<ul>
<li><p>求解同余方程的解：<span class="math inline">\(a\times x\equiv b\
(mod\ m)\)</span></p></li>
<li><p>上式等价于 <span class="math inline">\(a\times x=km+b\)</span>
等价于 <span class="math inline">\(a\times x\ +k&#39;m=b\
①\)</span></p></li>
<li><p>有拓展欧几里得原理拓算法可知一定存在 <span
class="math inline">\(a\times x+m\times y = gcd(a,m)\)</span></p></li>
<li><p>将上式两边同乘 b 再除以 gcd( a, m ) 可以得到 ①
式，前提是b必须为gcd(a, m)的倍数</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">while</span>(n--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, m, p;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;m);</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(a, b, x, y);</span><br><span class="line">    <span class="comment">//如果b不是d的倍数，则表示无解</span></span><br><span class="line">    <span class="keyword">if</span>(b % d) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);		</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (LL)x * b / d % m);	<span class="comment">//此题我们只关心x，不需要用到y，x再乘b除以d模m即为最终答案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="高斯消元">高斯消元</h4>
<p><strong>用途</strong></p>
<ul>
<li>求解n元一次方程组</li>
</ul>
<p><strong>方法</strong></p>
<ul>
<li>枚举矩阵的每一列</li>
<li>找出所有行中当前列的位置上绝对值最大的行</li>
<li>将找到的行中的所有的数换到当前的最上一行</li>
<li>将当前最高的一行的当前列的位置上的数变成1</li>
<li>将当前行下面所有行的当前列的数变成0</li>
<li>从最后一行开始，将所有解往上带</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;	</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-8</span>;	<span class="comment">//用于判断double是否为0，如果其绝对值小于eps则认为其为0</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> a[N][N];	<span class="comment">//用于存放矩阵，a[x][n]表示最终答案</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gause</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r;	<span class="comment">//! r表示遍历到了哪一行，c表示遍历到了哪一列</span></span><br><span class="line">    <span class="keyword">for</span>(c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c++)	<span class="comment">//从每一列开始枚举</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = r; i &lt; n; i++)	<span class="comment">//找到第c列上的数绝对值最大的行</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[t][c]) &lt; <span class="built_in">fabs</span>(a[i][c]))	<span class="comment">//fabs用于计算浮点数类型的绝对值</span></span><br><span class="line">                t = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[t][c]) &lt; eps) <span class="keyword">continue</span>;	<span class="comment">//如果最大值都是0，则说明整一列都是0，直接跳到r行c+1列</span></span><br><span class="line">           </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = c; i &lt;= n; i++) <span class="built_in">swap</span>(a[r][i], a[t][i]);	<span class="comment">//找到的t行与r行交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= c; i--) a[r][i] /= a[r][c];	<span class="comment">//r行的第c列变成1，必须从后往前更新，因为后面的更新需要用到a[r][c]的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; i++)	<span class="comment">//将r下面的所有行的c列变成0，整列同时减去a[r][j] * a[i][c]</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[i][c]) &gt; eps)		<span class="comment">//如果已经是0则没必要更新</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = n; j &gt;= c; j--) a[i][j] -= a[r][j] * a[i][c];	<span class="comment">//还是必须从后往前更新，理由同上</span></span><br><span class="line">        r++;	<span class="comment">//当前行处理完毕，进行下一行的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(r &lt; n)	<span class="comment">//r &lt; n说明三角形中的行数小于n</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = r; i &lt; n; i++)	<span class="comment">//此时r以及下面的行的左边全为0，如果其中的某一行右边不为0，则表示无解</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[i][n]) &gt; eps)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;	<span class="comment">//否则有多组解</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//往回带的过程，因为我们将最终结果储存在a[x][n]中，所有只需要对a[x][n]进行更新，其他的我们不关心</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)		<span class="comment">//需要把第i行的非xi的项消掉，利用其下一行可以进行相加减</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)	<span class="comment">//j表示i的下一行，i从n开始往前遍历</span></span><br><span class="line">            a[i][n] -= a[i][j] * a[j][n];	<span class="comment">//a[i][n]是由a[j][n]相加减得到的</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">//表示有唯一的解：一个完美的倒三角型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;a[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">gause</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(t == <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;No solution&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t == <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;Infinite group solutions&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, a[i][n]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="高斯消元解异或线性方程组">高斯消元解异或线性方程组</h5>
<p><strong>方法</strong></p>
<ul>
<li>方法和普通版本相同</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//题目特性：方程所有系数、常数、未知数的可能取到的值只有0或1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r;</span><br><span class="line">    <span class="keyword">for</span>(c = r = <span class="number">0</span>; c &lt; n; c++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = r; i &lt; n; i++)	<span class="comment">//我们只需要找到c列为1的行就行了，因为0和1之间的最大值只能是1</span></span><br><span class="line">            <span class="keyword">if</span>(a[i][c])</span><br><span class="line">            &#123;</span><br><span class="line">                t = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span>(!a[t][c]) <span class="keyword">continue</span>;	<span class="comment">//c列全为0时直接跳至c+1行</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) <span class="built_in">swap</span>(a[t][i], a[r][i]);	<span class="comment">//交换至最上一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span>(a[i][c])</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = c; j &lt;= n; j++)</span><br><span class="line">                    a[i][j] ^= a[r][j];	<span class="comment">//由于只有0或1两个数，所以这里的^相当于减法了</span></span><br><span class="line">        </span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(r &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = r; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][n]) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            a[i][n] ^= a[j][n] * a[i][j];	<span class="comment">//可以使用*也可以使用&amp;，此题是等价的</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">gauss</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(t == <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;No solution&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t == <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;Multiple sets of solutions&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i][n]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="求组合数">求组合数</h4>
<p><strong>模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        res *= n - i;</span><br><span class="line">        res /= i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题目</strong></p>
<ul>
<li><span class="math inline">\(给定\ a,b\ 求C_a^b\ mod\
(p)的值\)</span></li>
<li><span class="math inline">\(a,b,p\ 都有范围限制\)</span></li>
</ul>
<h5 id="查表法">查表法</h5>
<p><strong>范围</strong></p>
<ul>
<li>a, b 的范围较小，例如2000</li>
<li>时间复杂度：O ( n<sup>2</sup> )</li>
<li>核心公式：<span class="math inline">\(C_a^b\ =C_{a-1}^{b-1}\ +\
C_{a-1}^b\)</span> 值可以分为两部分：选 k 或 不选
k，<strong>不选</strong> k：<span
class="math inline">\(C_{a-1}^b\)</span> ，选 k：<span
class="math inline">\(C_{a-1}^{b-1}\)</span></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//N由a,b能取到的最大值来决定</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c[N][N];	<span class="comment">//表示Cab	</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span>		<span class="comment">//建表的过程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">            <span class="keyword">if</span>(!j) c[i][j] = <span class="number">1</span>;	</span><br><span class="line">            <span class="keyword">else</span> c[i][j] = (c[i - <span class="number">1</span>][j - <span class="number">1</span>] + c[i - <span class="number">1</span>][j]) % mod;	<span class="comment">//核心公式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c[a][b]);	<span class="comment">//直接查表就行</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="预处理法">预处理法</h5>
<p><strong>范围</strong></p>
<ul>
<li>a, b的范围较大，为 10<sup>5</sup></li>
</ul>
<p><strong>思路</strong></p>
<ul>
<li>预处理出 1 ~ n 中所有数的正元和逆元</li>
<li>核心公式：<span class="math inline">\((k!)^{-1}\equiv
(k!)^{p-2}\equiv [(k-1)!]^{p-2}\times k^{p-2}\equiv [(k-1)!]^{-1}\times
k^{-1}\ mod(p)\)</span></li>
<li>即 k的阶乘的逆元可以由 (k - 1)的阶乘的逆元得到</li>
<li>最后套入公式 <span class="math inline">\(C_a^b=a!\ /\
(b!\times(a-b)!)\)</span></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fact[N], infact[N];	<span class="comment">//fanct为正元数组，infact为逆元数组 fact(n)表示n的阶乘</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;	<span class="comment">//0的正逆元都为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fact[i] = (LL)fact[i - <span class="number">1</span>] * i % mod;	<span class="comment">//正逆元都可以由 n-1的正逆元得到</span></span><br><span class="line">        infact[i] = (LL)infact[i - <span class="number">1</span>] * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="comment">//最后代入公式即可</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (LL)fact[a] * infact[a - b] % mod * infact[b] % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="卢卡斯定理">卢卡斯定理</h5>
<p><strong>内容</strong></p>
<ul>
<li>对于质数 p， a , b 为正整数有 <span
class="math inline">\(C_a^b=C_{a\%p}^{b\%p}\ \times
C_{[a/p]}^{[b/p]}\)</span></li>
<li>题目数据范围：<span class="math inline">\(0&lt;a,b\le10^{18},\
0&lt;p\le10^5\)</span></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a,b范围超级大，但是p的范围比较小</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//这里模拟的就是 a! / (b! * (a - b)!)，和我现实中运算一致hh</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = a; i &lt;= b; i++, j--)</span><br><span class="line">    &#123;</span><br><span class="line">        res = (LL)res * j % p;</span><br><span class="line">        res = (LL)res * <span class="built_in">qmi</span>(i, p - <span class="number">2</span>, p) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lucas</span><span class="params">(LL a, LL b, <span class="type">int</span> p)</span>	<span class="comment">//注意a，b可能非常大，会爆int，必须用LL来存</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; p &amp;&amp; b &lt; p) <span class="keyword">return</span> <span class="built_in">C</span>(a, b, p);	<span class="comment">//当a &lt; p并且b &lt; p时，又卢卡斯定理公式可知，值就为 Cab</span></span><br><span class="line">    <span class="keyword">return</span> (LL)<span class="built_in">C</span>(a % p, b % p, p) * <span class="built_in">lucas</span>(a / p, b / p, p) % p; 	<span class="comment">// a / p可能还是比较大，所以继续使用卢卡斯</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        LL a, b;	<span class="comment">//注意a，b可能非常大，会爆int，必须用LL来存</span></span><br><span class="line">        <span class="type">int</span> p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%ld%ld%d&quot;</span>, &amp;a, &amp;b, &amp;p);	<span class="comment">//LL的打印格式为 %ld</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">lucas</span>(a, b, p));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="分解质因子">分解质因子</h5>
<p><strong>范围</strong></p>
<ul>
<li>题目不再要求结果模上一个数</li>
<li><span class="math inline">\(0&lt;a,b\le5000\)</span></li>
<li>需要使用高精度乘法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> primes[N], sum[N], cnt;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//欧拉筛模板</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) primes[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> p)</span>	<span class="comment">//get函数用于获取n!中含有多少个质数p</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;<span class="comment">//思路：我们只需要知道阶乘中的最大的一个数(n)，用其先找p的倍数，接着找p方的倍数、p三方倍数 ... </span></span><br><span class="line">    <span class="keyword">while</span>(n)	<span class="comment">//在找p的倍数时，p方倍数也算进去了(但只算了一次)，但由于是p方所依还要加上一个p，即再加上所有p方的倍数的个数，以此类推</span></span><br><span class="line">    &#123;			<span class="comment">//求n中p的倍数公式：cnt = n / p</span></span><br><span class="line">        res += n / p;</span><br><span class="line">        n /= p;	<span class="comment">//分子除以p，就相当于分母乘上p了hh</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//高精度乘法模板，此题不需要除去前导零</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t += a[i] * b;</span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(t)</span><br><span class="line">    &#123;</span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">get_primes</span>(a);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p = primes[i];</span><br><span class="line">        sum[i] = <span class="built_in">get</span>(a, p) - <span class="built_in">get</span>(b, p) - <span class="built_in">get</span>(a - b, p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; sum[i]; j++)</span><br><span class="line">            res = <span class="built_in">mul</span>(res, primes[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, res[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="卡特兰数">卡特兰数</h4>
<p><strong>定义</strong></p>
<ul>
<li><p>是一个数列，类似斐波那契数列的那种具有规律和实际意义的数列。
<span class="math display">\[
  通项公式:A(n)=C_{2n}^{n}-C_{2n}^{n+1}= \frac{C_{2n}^{n}}{n+1}
  \newline递推公式:A(n)=\frac{4n-2}{n+1}A(n-1),其中a_1=1
  \]</span></p></li>
<li></li>
</ul>
<p><strong>问题切入</strong></p>
<ul>
<li>在nxn的网格中，一开始在(0,0)处，每次可以向上走一格或者向右走一格，在任一时刻，向右走的次数不能少于向上走的次数，问有多少种合法路径?</li>
<li>两姐妹配合洗5个碗，姐姐洗碗，妹妹将碗放入橱柜，问一共有多少种配合方式
<ul>
<li>分析：妹妹能够放碗的前提是姐姐已经洗好碗，即任一时刻，妹妹摞碗的个数不能小于等于姐姐洗碗的个数</li>
</ul></li>
<li>以上问题的个数就是卡特兰数</li>
</ul>
<p><a
href="https://zhuanlan.zhihu.com/p/97619085">这篇文章解释得很清楚</a></p>
<p><strong>证明图解</strong></p>
<p><img src="/images/Catalan数的证明图解.jpg" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//题目：满足条件的01序列</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于计算Cab的</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//模拟现实中的计算</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = a; i &lt;= b; i++, j--)</span><br><span class="line">    &#123;</span><br><span class="line">        res = (LL)res * j % mod;</span><br><span class="line">        res = (LL)res * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> a = n * <span class="number">2</span>, b = n;</span><br><span class="line">    <span class="comment">//最后套入公式即可，中间结果可能爆int，所以需要临时强转成LL</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (LL)<span class="built_in">C</span>(a, b) * <span class="built_in">qmi</span>(n + <span class="number">1</span>, mod - <span class="number">2</span>, mod) % mod);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="容斥原理">容斥原理</h4>
<p><strong>内容</strong></p>
<ul>
<li><p><span class="math inline">\(设S(A)为集合A中元素个数，求S(A\cup
B\cup C)\)</span></p></li>
<li><p><span class="math inline">\(先求S(A)+S(B)+S(C)再减S(A\cap
B)减S(A\cap C)减S(B\cap C)最后加上S(A\cap B\cap C)\)</span></p></li>
<li><p>通俗化就是
(奇数个集合)的交集相加，(偶数个集合)的交集相减</p></li>
<li><p>组合数的一个恒等式：<span
class="math inline">\(C_n^1+C_n^2+C_n^3\dots+C_n^n=2^n\)</span></p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//能被整除的数的个数</span></span><br><span class="line"><span class="comment">//给定n和一组质数p 求1~n中至少能被一个p整除的数的个数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读取质数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;	<span class="comment">//答案</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//由于一共有2^m个项(由恒等式可知)，恰好可以用二进制来表示</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1</span> &lt;&lt; m; i++)	<span class="comment">//枚举1 到 11111...1111(m个1) 之间的数，1表示选该集合，0表示不选</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">1</span>, s = <span class="number">0</span>;	<span class="comment">//t为所有质数的最小公倍数，s表示是选奇数个集合还是选偶数个集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)	<span class="comment">//枚举所有质数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>)	<span class="comment">//表示选第j个集合(第j位上是1)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((LL)t * p[j] &gt; n)</span><br><span class="line">                &#123;</span><br><span class="line">                    t = <span class="number">-1</span>;	<span class="comment">//超过了最大值则不用再选了，n / t，t大于n时一定为0</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                t *= p[j];	<span class="comment">//质数相乘</span></span><br><span class="line">                s++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s &amp; <span class="number">1</span>) res += n / t;	<span class="comment">//奇数相加，n/p表示能够同时被多个质数整除的质数</span></span><br><span class="line">            <span class="keyword">else</span> res -= n / t;	<span class="comment">//偶数相减</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="博弈论">博弈论</h4>
<h5 id="nim游戏">nim游戏</h5>
<p><strong>题目</strong></p>
<ul>
<li><p>给定 n
堆石子，两位玩家轮流操作，每次操作可以从任意一堆石子中拿走任意数量的石子（可以拿完，但不能不拿），最后无法进行操作的人视为失败。问如果两人都采用最优策略，先手是否必胜。</p></li>
<li><p>前提：两个人都聪明绝顶，不存在失误策略</p></li>
</ul>
<p><strong>策略</strong></p>
<ul>
<li>对每堆石子的数量进行异或操作，最终结果如果是0则先手必败，非0则先手必胜</li>
<li>最终状态：a1 ^ a2 ^ ... ^ an = 0</li>
<li>若 a1 ^ a2 ^ ... ^ an = x (!0)，则一定可以从ai中取出 (ai - ai ^ x)
使得 新的异或序列为0 (交给后手)</li>
<li>若 a1 ^ a2 ^ ... ^ an = 0
则无论从哪一堆操作，都会使新的异或序列的结果不为0 (交给先手)</li>
<li>先手如何获胜：前提是最开始的状态异或结果不为0，第一次拿出 (ai - ai ^
x)
个石子使得异或结果为0，接下来只要看后手拿了多少个，先手再拿出多少个，最后先手一定获胜</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;	<span class="comment">//为什么res初始化为0：因为任意一个数与0异或都为其本身</span></span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        res ^= a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="台阶nim游戏">台阶nim游戏</h5>
<p><strong>题目</strong></p>
<ul>
<li>现在，有一个 n 级台阶的楼梯，每级台阶上都有若干个石子，其中第 i
级台阶上有 ai
个石子(i≥1)。两位玩家轮流操作，每次操作可以从任意一级台阶上拿若干个石子放到下一级台阶中（不能不拿）。已经拿到地面上的石子不能再拿，最后无法进行操作的人视为失败。问如果两人都采用最优策略，先手是否必胜。</li>
</ul>
<p><strong>特性</strong></p>
<ul>
<li>本题只需关注奇数阶梯上的石子个数，偶数阶梯上的不需要关注</li>
<li>因为当其中一个人拿了奇数的石子往偶数上放，另一个人也可以再将其放回至下一个奇数阶梯</li>
<li>如果奇数阶梯上的石子数的异或不为0则先手必胜；为0则后手必胜</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重要的是思想</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span>) res ^= a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="sg函数以及sg定理">sg函数以及sg定理</h5>
<p><strong>定义</strong></p>
<ul>
<li><span class="math inline">\(假设x状态能到\
y1,y2,y3\dots状态,则有sg(x)=mex\{sg(y1),sg(y2),sg(y3)\dots\}\)</span></li>
<li><span
class="math inline">\(mex表示一种运算:结果为不包含于集合的最小自然数\)</span></li>
</ul>
<p><strong>性质</strong></p>
<ul>
<li><span
class="math inline">\(sg(x)=0表示,x状态不能转移到0的状态\)</span></li>
<li><span class="math inline">\(sg(x)=0\ 表示先手必败，sg(x)\ne0\
表示先手必胜\)</span></li>
</ul>
<p><strong>sg定理</strong></p>
<ul>
<li><p>对于一个组合游戏，可以把游戏分成多个规则统一的局面，分治计算 sg
值。则总的 sg 值是各个分治局面的 sg 值的异或和</p></li>
<li><p><span class="math inline">\(sg(G)=sg(G1)\oplus
g(G2)\oplus\dots\oplus sg(Gn),\ \oplus表示异或运算符\)</span></p></li>
</ul>
<p><strong>固定的模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sg</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;	<span class="comment">//拓展x下一个状态</span></span><br><span class="line">    	<span class="comment">//用unordered_set记录所有x的下一个状态的sg值 </span></span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">     	<span class="comment">//对x的下一个状态进行，mex操作最终得到x的sg值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    res ^= <span class="built_in">sg</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(res) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br></pre></td></tr></table></figure>
<h5 id="集合nim游戏">集合nim游戏</h5>
<p><strong>题目</strong></p>
<ul>
<li>每次能只能拿属于 S
集合中的数的石子的个数，其余条件与经典nim游戏一致</li>
<li>用sg函数可以轻松解决</li>
<li>对于每一个石子堆，都会有一个完全状态图，每一个石子堆的sg值都可以求出来</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>, M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> s[N], f[M];	<span class="comment">//s存储的是可拿走石子的数量，f存储的是每堆石子的sg值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sg</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//记忆搜索法，保证每个数字只求一次，参数x表示，数量为x的石子堆</span></span><br><span class="line">    <span class="keyword">if</span>(f[x] != <span class="number">-1</span>) <span class="keyword">return</span> f[x];</span><br><span class="line">    </span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; S;	<span class="comment">//S用来存储每一个石子堆中所有状态的sg值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//x小于s中所有的数，则表明已经走到末状态</span></span><br><span class="line">        <span class="comment">//否则存下(x - s[i])的sg值</span></span><br><span class="line">        <span class="keyword">if</span>(x &gt;= s[i]) S.<span class="built_in">insert</span>(<span class="built_in">sg</span>(x - s[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; ;i++)	<span class="comment">//进行一个mex操作(范围是所有自然数)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!S.<span class="built_in">count</span>(i))	<span class="comment">//因为是从小到大遍历，一旦S中没有i，则i就成为了当前x的sg值</span></span><br><span class="line">            <span class="keyword">return</span> f[x] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        res ^= <span class="built_in">sg</span>(a);	<span class="comment">//对所有sg值进行异或操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(res) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="拆分nim游戏">拆分nim游戏</h5>
<p><strong>题目</strong></p>
<ul>
<li>每次拿走n堆石子中的一堆，然后放入两堆规模更小的石子堆，规模可以为0，新堆的总数可以大于原来的堆，不能操作的一方失败</li>
<li>使用sg定理，求出n堆的sg值，最后进行一个异或和操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N];	<span class="comment">//存储sg值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sg</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x] != <span class="number">-1</span>) <span class="keyword">return</span> f[x];</span><br><span class="line">    </span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; x; i++)	<span class="comment">//放入新的两堆，所以两层循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)	<span class="comment">//为了避免重复，令 j&lt;=i</span></span><br><span class="line">            S.<span class="built_in">insert</span>(<span class="built_in">sg</span>(i) ^ <span class="built_in">sg</span>(j));	<span class="comment">//sg(i) ^ sg(j)的结果就是x的下一个状态的sg值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; ;i++)	<span class="comment">//进行mex操作</span></span><br><span class="line">        <span class="keyword">if</span>(!S.<span class="built_in">count</span>(i))</span><br><span class="line">            <span class="keyword">return</span> f[x] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        res ^= <span class="built_in">sg</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(res) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数学知识</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索与图论</title>
    <url>/posts/f7a7d551/</url>
    <content><![CDATA[<h4 id="dfs">DFS</h4>
<p><strong>定义</strong></p>
<ul>
<li>深度优先算法：从根节点出发，只要到达的节点有子节点就一直走下去，直到走到没有根节点的节点为止；然后再向上回溯</li>
<li>继续从父节点的另一个子节点(平级节点)出发，直到走到最后层的最后一个节点</li>
</ul>
<p><strong>应用</strong></p>
<ul>
<li>DFS其实就是把所有可能的情况全部都模拟一遍，只是其顺序是深度搜索</li>
<li>例如求一个数的全排列：1 2 3，1 3 2，2 1 3，2 3 1，3 1 2，3 2 1</li>
</ul>
<p><strong>排列组合I</strong></p>
<ul>
<li><a
href="https://www.acwing.com/problem/content/844/">原题链接</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	输入一个数，按字典序输出其全排列，每个方案占一行。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> path[N];	<span class="comment">//表示排列方案</span></span><br><span class="line"><span class="type">bool</span> mak[N];	<span class="comment">//表示 1 ~ n 中的数是否被用过</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == n)	<span class="comment">//如果x为n，表示已经走到第n位了，因为是从0开始的，可以输出了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, path[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)	<span class="comment">//x位上可以填1 ~ n中的数</span></span><br><span class="line">        <span class="keyword">if</span>(!mak[i])</span><br><span class="line">        &#123;</span><br><span class="line">            path[x] = i;</span><br><span class="line">            mak[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(x + <span class="number">1</span>);	<span class="comment">//进行x+1的数字填写</span></span><br><span class="line">            mak[i] = <span class="literal">false</span>;	<span class="comment">//第x位要换数字了，重新洗牌</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>排列组合II</strong></p>
<ul>
<li>给定一个可包含重复数字的整数集合nums，按任意顺序返回它所有不重复的全排列。</li>
</ul>
<p><a
href="https://leetcode.cn/problems/7p8L0Z/description/">原题链接</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; hash;    <span class="comment">//放入当前位置x所对应的值,如果重复则直接跳过</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.<span class="built_in">count</span>(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            hash.<span class="built_in">emplace</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i != x)<span class="built_in">swap</span>(nums[x], nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(x + <span class="number">1</span>, nums);</span><br><span class="line">            <span class="keyword">if</span>(i != x)<span class="built_in">swap</span>(nums[x], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>例题</strong></p>
<ul>
<li>n-皇后问题：将 n个皇后放在 n×n
的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历顺序1：每个格子都遍历</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> row[N], col[N], dg[N], udg[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> s)</span>	<span class="comment">//x表示第x+1行，y表示第y+1列，s表示当前已放皇后的个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y == n)	<span class="comment">//如果y走到尽头，则将&quot;指针&quot;移动至下一行</span></span><br><span class="line">    &#123;</span><br><span class="line">        y = <span class="number">0</span>;	</span><br><span class="line">        x ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == n)	<span class="comment">//表示x已经遍历至最后一行</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == n)	<span class="comment">//当全部皇后已放完则为一种分法</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">puts</span>(g[i]);	<span class="comment">//输出char[][]中的每一行</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//每次dfs都有两个选择</span></span><br><span class="line">    <span class="comment">//1.不放皇后：直接往下一列搜索</span></span><br><span class="line">    <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.放皇后则需要满足同行同列同对角线没有皇后</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	棋盘上在同一条正对角线(斜率为正)的点满足性质：x + y = C (C为一个定值)</span></span><br><span class="line"><span class="comment">    	棋盘上在同一条反对角线(斜率为负)的点满足性质：x - y = C (C为一个定值)</span></span><br><span class="line"><span class="comment">    	可以根据此性质将其映射至数组下标表示其线上有无皇后</span></span><br><span class="line"><span class="comment">    	但x - y可能出现负数，数组中不存在负数下标，所以需要将其映射成 x - y + n = C</span></span><br><span class="line"><span class="comment">    	-n &lt;= x - y, 因此+n可以保证其为正数</span></span><br><span class="line"><span class="comment">    	</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[x - y + n])</span><br><span class="line">    &#123;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;Q&#x27;</span>;	<span class="comment">//当前位置(x, y)存放皇后</span></span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">true</span>;	<span class="comment">//标记(x, y)已放皇后</span></span><br><span class="line">        <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, s + <span class="number">1</span>);	<span class="comment">//递归进行下一列的搜索</span></span><br><span class="line">        <span class="comment">//当下一列的搜索所有的不满足的时候，需要将其原来的行数往前移动一单位，char数组中的&#x27;Q&#x27;需要还原</span></span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">false</span>;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;.&#x27;</span>;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//预处理：将char数组中所有字符都赋值成&#x27;.&#x27;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);	<span class="comment">//从(0, 0)位置开始搜索，初始存放皇后为0</span></span><br><span class="line">       </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历顺序2：优化后的版本，从每一行开始搜索，同一行或同一列只能有一个皇后</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="comment">//由于从每一行开始遍历，所以不需要row数组，注意的是对角线的最多个数是2n-1个dg,udg数组开空间的时候需要注意</span></span><br><span class="line"><span class="type">bool</span> col[N], dg[N], udg[N];	</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span>	<span class="comment">//x表示当前行(下标从0开始)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == n)	<span class="comment">//表示已经搜索到最后一层，则输出答案</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">puts</span>(g[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)	<span class="comment">//对指定一行的每一列进行遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!col[i] &amp;&amp; !udg[i + x] &amp;&amp; !dg[x - i + n])	</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//x表示的是行，i表示的是列</span></span><br><span class="line">            g[x][i] = <span class="string">&#x27;Q&#x27;</span>;	<span class="comment">//满足条件则在当前位置插入‘Q’</span></span><br><span class="line">            col[i] = udg[i + x] = dg[x - i + n] = <span class="literal">true</span>;	<span class="comment">//标记当前位置已放皇后</span></span><br><span class="line">            <span class="built_in">dfs</span>(x + <span class="number">1</span>);	<span class="comment">//继续向下一行开始搜索</span></span><br><span class="line">            <span class="comment">//如果下一行所有位置均不满足，则表明当前[x][i]的位置不能放皇后，进入到[x][i+1]开始判定</span></span><br><span class="line">            col[i] = udg[i + x] = dg[x - i + n] = <span class="literal">false</span>;  </span><br><span class="line">            g[x][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//预处理：将char数组中所有字符都赋值成&#x27;.&#x27;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bfs">BFS</h4>
<p><strong>定义</strong></p>
<ul>
<li>广度优先算法：从根节点出发，先搜索距离根节点为1的点，将所有距离为1的点搜索完后再继续搜索距离为2的点，以此类推</li>
</ul>
<p><strong>模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//bfs中没有递归调用</span></span><br><span class="line"><span class="keyword">while</span>(队列不为空)</span><br><span class="line">&#123;</span><br><span class="line">	取出对头元素</span><br><span class="line">	对对头元素进行扩展</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>例题</strong></p>
<ol type="1">
<li>走迷宫：给定一个 n×m的二维整数数组，用来表示一个迷宫，数组中只包含 0
或 1，其中 0 表示可以走的路，1
表示不可通过的墙壁。最初，有一个人位于左上角
(1,1)处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。请问，该人从左上角移动至右下角
(n,m)处，至少需要移动多少次。数据保证 (1,1)处和 (n,m)处的数字为 0
，且一定至少存在一条通路</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;	<span class="comment">//pair类型用来存储每个点的坐标</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> mp[N][N];	<span class="comment">//表示地图</span></span><br><span class="line"><span class="type">int</span> d[N][N];	<span class="comment">//表示从起点走到坐标(x, y)的步数</span></span><br><span class="line">queue&lt;PII&gt; q;	<span class="comment">//queue存储的是每一步走到的点</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);	<span class="comment">//初始化将所有点的步数为-1，表示该点没有走过</span></span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;	<span class="comment">//起始点到起始点的步数为0</span></span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);	<span class="comment">//插入起始点，从起始点开始走</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;	<span class="comment">//dx, dy组合表示当前点的上下左右的偏移量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())	<span class="comment">//bfs的一个模板</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();	</span><br><span class="line">        q.<span class="built_in">pop</span>();	<span class="comment">//取出对头元素并且对头出队</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;	</span><br><span class="line">            <span class="type">int</span> x = t.first + dx[i], y = t.second + dy[i];		<span class="comment">//(x, y)表示对头位置的下一个点</span></span><br><span class="line">            <span class="comment">//如果(x, y)没有超出边界并且mp[x][y]为0(表示可以走),且d[x][y]=-1,(表示没有走过)</span></span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; mp[x][y] == <span class="number">0</span> &amp;&amp; d[x][y] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                d[x][y] = d[t.first][t.second] + <span class="number">1</span>;	<span class="comment">//更新该点走的步数</span></span><br><span class="line">                mp[x][y] = <span class="number">1</span>;	<span class="comment">//标记当前点已经被走过</span></span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x, y&#125;);	<span class="comment">//当前点入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//(n-1, m-1)表示的是最右下角的点，d[n - 1][m - 1]则表示到达最后一个点走的步数，由于第一个到达该点后其他点不能到达，</span></span><br><span class="line"><span class="comment">//所以d[n - 1][m - 1]表示的就是从起始点到最后一个点的最短路径</span></span><br><span class="line">    <span class="keyword">return</span> d[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(mp, <span class="number">1</span>, <span class="keyword">sizeof</span> mp);	<span class="comment">//初始化地图，为地图打上边界 1 </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;mp[i][j]);		<span class="comment">//读取题目给的地图</span></span><br><span class="line">            </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">bfs</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<ol start="2" type="1">
<li>八数码：在一个 3×3 的网格中，1∼8 这 8 个数字和一个 x
恰好不重不漏地分布在这 3×3 的网格中，在游戏过程中，可以把 x
与其上、下、左、右四个方向之一的数字交换（如果存在）。我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：1
2 3 4 5 6 7 8 x</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	思路：用字符串来表示每一次字符串转换的状态，需要将字符串中的下标与矩阵中的下标进行转换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">queue&lt;string&gt; q;	<span class="comment">//维护的是每一个字符串转换后的状态</span></span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; d;	<span class="comment">//表示从初始状态到当前状态的步数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(str);	<span class="comment">//初始状态入队</span></span><br><span class="line">    d[str] = <span class="number">0</span>;		<span class="comment">//初始状态的步数为0</span></span><br><span class="line">    string res = <span class="string">&quot;12345678x&quot;</span>;	<span class="comment">//用于与对头元素判断是否到达最终目标状态</span></span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;	<span class="comment">//表示每一步的偏移量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())	</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();		</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> k = t.<span class="built_in">find</span>(<span class="string">&#x27;x&#x27;</span>);	<span class="comment">//k存储对头元素中&#x27;x&#x27;的位置</span></span><br><span class="line">        <span class="type">int</span> x = k / <span class="number">3</span>, y = k % <span class="number">3</span>;	<span class="comment">//将&#x27;x&#x27;的下标转换成矩阵中的下标</span></span><br><span class="line">        <span class="type">int</span> dist = d[t];	<span class="comment">//dist表示对头元素的步数</span></span><br><span class="line">        <span class="keyword">if</span>(t == res) <span class="keyword">return</span> dist; 	<span class="comment">//如果对头元素符合最终状态，则返回距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)	<span class="comment">//对对头元素进行偏移</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = x + dx[i], b = y + dy[i];	<span class="comment">//(a, b)表示对头元素偏移量在数组中的下标</span></span><br><span class="line">            <span class="keyword">if</span>(a &gt;= <span class="number">0</span> &amp;&amp; a &lt; <span class="number">3</span> &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; <span class="number">3</span>)	<span class="comment">//判断(a, b)是否超出矩阵边界</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(t[k], t[a * <span class="number">3</span> + b]);	<span class="comment">//未超出则交换&#x27;x&#x27;与(a, b)上的字符，矩阵坐标(a,b)映射成字符串下标：a * 3 + b</span></span><br><span class="line">                <span class="keyword">if</span>(!d.<span class="built_in">count</span>(t))		<span class="comment">//如果交换完后的字符串没有出现过</span></span><br><span class="line">                &#123;</span><br><span class="line">                    d[t] = dist + <span class="number">1</span>;	<span class="comment">//更新交换完后字符串的距离</span></span><br><span class="line">                    q.<span class="built_in">push</span>(t);		<span class="comment">//交换完后的状态入队</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">swap</span>(t[k], t[a * <span class="number">3</span> + b]);	<span class="comment">//还原后进行其余方向(上下左右)的交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//所有路都走完了，没有目标状态，则返回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>; i++)	<span class="comment">//读取字符串的初始状态</span></span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        str += op[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>(str) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="双向bfs">双向BFS</h4>
<p><strong>内容</strong></p>
<ul>
<li>针对bfs的一个优化，大大提高搜索效率和降低空间的开销</li>
</ul>
<p><strong>适用</strong></p>
<ul>
<li>从初始状态开始向目标状态开始进行深度优先遍历，两个状态相遇时即停止</li>
<li>节点数量较多时，可以大大减少空间的开销</li>
</ul>
<p><strong>模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">_Ty <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;_Ty&gt; q1, q2;</span><br><span class="line">	unordered_map&lt;_T1, _T2&gt; m1, m2; 	<span class="comment">//_T1为需要操作的每个状态，_T2表示该状态的某些属性</span></span><br><span class="line">	<span class="keyword">while</span>(q1.<span class="built_in">size</span>() &amp;&amp; q2.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">    	_Ty res = 初始值;</span><br><span class="line">        <span class="keyword">if</span>(q1.<span class="built_in">size</span>() &lt;= q2.<span class="built_in">size</span>())</span><br><span class="line">            res = <span class="built_in">operate</span>(q1);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            res = <span class="built_in">operate</span>(q2);</span><br><span class="line">       	<span class="keyword">if</span>(res != 初始值) <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> 特定的值;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">_Ty <span class="title">operate</span><span class="params">(queue&lt;_T&gt; q, unordered_map&lt;_T1, _T2&gt;&amp; cur, unordered_map&lt;_T1, _T2&gt;&amp; other)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sz = q.<span class="built_in">size</span>(); </span><br><span class="line">    <span class="keyword">while</span>(sz--)	<span class="comment">//如果对于层数有着严格的要求的，则必须逐层遍历，否则可以不用。例如求状态转移的步数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        根据题目要求，拓展对头元素 设新元素为s</span></span><br><span class="line"><span class="comment">        如果新状态入队过st[t] == true，则continue</span></span><br><span class="line"><span class="comment">        如果新状态在另一个q中入队过，则可以返回 cur[s] + 1 + other[s]</span></span><br><span class="line"><span class="comment">        否则则 cur[s] = cur[t] + 1;</span></span><br><span class="line"><span class="comment">        最后不要忘记将st[t]设为true</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有在上面的代码中返回，则表示无解</span></span><br><span class="line">    <span class="keyword">return</span> 无解对应的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="图">图</h4>
<p><strong>定义</strong></p>
<ul>
<li>用于表示多对多的关系，任意两个节点之间可以形成一条边</li>
</ul>
<p><strong>分类</strong></p>
<ul>
<li>按有无环
<ul>
<li>有环图</li>
<li>无环图</li>
</ul></li>
<li>按边的类型
<ul>
<li>有向图：规定了边的指定方向：a -&gt; b</li>
<li>无向图：边的指定方向未指定：a -&gt; b, b -&gt; a</li>
</ul></li>
</ul>
<p><strong>图的存储</strong></p>
<ol type="1">
<li>邻接表法：为每个元素开一个单链表，链表中存储的是该元素可以指到的位置，
<strong>适用于稀疏图</strong>
<ol type="1">
<li>一般使用头插法为表中添加元素</li>
</ol></li>
<li>临接矩阵法：<strong>适用于稠密图</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表的插入模板</span></span><br><span class="line"><span class="type">int</span> e[N], ne[N], h[N], idx;	<span class="comment">//h[]表示每个节点对应的头结点，初始指向-1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>	<span class="comment">//为图中添加一条a指向b的边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="树与图的深度优先遍历">树与图的深度优先遍历</h4>
<p><strong>定义</strong></p>
<ul>
<li>一条路走到尽头，函数递归调用</li>
</ul>
<p><strong>作用</strong></p>
<ul>
<li>求出树所有节点个数</li>
</ul>
<p><strong>模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>;	<span class="comment">//标记当前点已经走过</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])	<span class="comment">//对当前点进行拓展</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(st[j]) <span class="keyword">continue</span>;	<span class="comment">//如果子节点已经走过，则跳过</span></span><br><span class="line">       	<span class="built_in">dfs</span>(j);	<span class="comment">//继续遍历未走过的子节点，重复上面的流程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>例题</strong></p>
<ul>
<li>给定一颗树，树中包含 n 个结点（编号 1∼n）和
n−1条无向边。请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值</li>
<li>重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点的数量的最大值最小，那么这个节点被称为树的重心。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = N * <span class="number">2</span>;	<span class="comment">//由于是无向边，所以需要开两倍的数组</span></span><br><span class="line"><span class="type">int</span> e[M], h[N], ne[M], idx;	<span class="comment">//邻接表法</span></span><br><span class="line"><span class="type">bool</span> st[N];		<span class="comment">//判断当前点是否走过</span></span><br><span class="line"><span class="type">int</span> n, ans = N;	<span class="comment">//记录答案ans, ans的最大可能的值为N</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加边a -&gt; b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dfs()的作用是寻找以 u 为根节点，树的节点总个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>;	<span class="comment">//标记当前点已经走过</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>, res = <span class="number">0</span>;	<span class="comment">//sum表示当前树的节点个数，res表示去掉根节点u后，每个连通块的子节点的个数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])	<span class="comment">//遍历根节点u的所有子节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];	<span class="comment">//h[] 和 ne[]存储的都是下标，e[]中存储的是真实的编号</span></span><br><span class="line">        <span class="keyword">if</span>(st[j]) <span class="keyword">continue</span>;		<span class="comment">//如果j点遍历过则跳到下一个节点</span></span><br><span class="line">        <span class="type">int</span> s = <span class="built_in">dfs</span>(j);	<span class="comment">//递归调用，s接收以 j 为根节点，树的节点总个数</span></span><br><span class="line">        sum += s;	<span class="comment">//根节点 + 子树节点个数</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, s);		<span class="comment">//更新res,目的是求所有连通块的节点数的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    res = <span class="built_in">max</span>(res, n - sum);	<span class="comment">//最后res还要与出去u为根这颗树之外的树作比较，总数为n，u的节点数为sum</span></span><br><span class="line">    ans = <span class="built_in">min</span>(ans, res);	<span class="comment">//答案需要对每个节点数的最大值求最小</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum;		<span class="comment">//返回根为u的树的节点总数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);	<span class="comment">//初始化单链表</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">2</span>);	<span class="comment">//dfs(1), dfs(2)都可以，因为图是连通的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="树与图的广度优先遍历">树与图的广度优先遍历</h4>
<p><strong>定义</strong></p>
<ul>
<li><p>现将能第一层节点遍历完在遍历第二层</p></li>
<li><p>例如：a-&gt;b, a-&gt;c, b-&gt;d, d-&gt;s 先遍历 b、c 再遍历 d
最后遍历 s</p></li>
</ul>
<p><strong>作用</strong></p>
<ul>
<li>求出子节点到根节点之间的最短距离</li>
</ul>
<p><strong>模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//其实就是宽搜框架：用一个队列来维护，每次取出队头元素进行拓展</span></span><br><span class="line">    <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(d[j] == <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(j); </span><br><span class="line">        		d[j] = d[t] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>例题</strong></p>
<ul>
<li>给定一个 n 个点 m
条边的有向图，图中可能存在重边和自环。所有边的长度都是 1，点的编号为
1∼n。请你求出 1号点到 n号点的最短距离，如果从1号点无法走到n号点，输出
−1。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> e[N], ne[N], h[N], idx;	<span class="comment">//模拟单链表</span></span><br><span class="line"><span class="type">int</span> q[N], d[N];	<span class="comment">//模拟队列</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    q[++tt] = <span class="number">1</span>;	<span class="comment">//编号为1的节点入队</span></span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);	<span class="comment">//初始化d[]: 所有点到根节点的距离为-1</span></span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;	<span class="comment">//根节点到根节点的距离为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)	<span class="comment">//只要队列不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];	<span class="comment">//取出队头元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])	<span class="comment">//遍历队头子节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];	<span class="comment">//j表示编号为j的子节点</span></span><br><span class="line">            <span class="keyword">if</span>(d[j] == <span class="number">-1</span>)	<span class="comment">//子节点没有被遍历</span></span><br><span class="line">            &#123;</span><br><span class="line">                d[j] = d[t] + <span class="number">1</span>;	<span class="comment">//子节点距离+1</span></span><br><span class="line">                q[++tt] = j;	<span class="comment">//子节点入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);	<span class="comment">//单链表的初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">bfs</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="拓扑排序">拓扑排序</h4>
<p><strong>定义</strong></p>
<ul>
<li>将各个节点进行排序，每两个节点之间边的指向不能为从后往前</li>
<li>原图：1-&gt;2 , 2-&gt;3, 3-&gt;4, 1-&gt;3，拓扑序列：1 2 3 4</li>
</ul>
<p><strong>充要条件</strong></p>
<ul>
<li>原图必须是有向无环图</li>
</ul>
<p><strong>例题</strong></p>
<ul>
<li>给定一个 n 个点 m 条边的有向图，点的编号是 1 到
n，图中可能存在重边和自环。请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出
−1。若一个由图中所有点构成的序列 A 满足：对于图中的每条边 (x,y)，x 在 A
中都出现在 y 之前，则称 A 是该图的一个拓扑序列。</li>
</ul>
<p><strong>思路</strong></p>
<ul>
<li>求拓扑排序：维护一个队列 ( STL要用双端队列 deque
)，首先找到任意一个入度为0的点将其入队</li>
<li>然后删除该点 pop_front( )
以及其指向的所有节点的边删除，且各节点的入度减1，接着重复上一步的操作找入度为0的点入队。若所有节点都能被删除，则表示此图可以进行拓扑排序，否则不行</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> e[N], ne[N], h[N], idx;</span><br><span class="line"><span class="type">int</span> q[N], d[N];	<span class="comment">//d[i]表示编号为i的点的入度(有多少条边指向i)</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topo</span><span class="params">()</span>	<span class="comment">//若能够形成一个拓扑序列，则返回true，否则返回false</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;	<span class="comment">//队列的初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将所有入度为0的点入队，从它们开始突破</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(d[i] == <span class="number">0</span>)</span><br><span class="line">            q[++tt] = i; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];	<span class="comment">//取出队头元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="comment">//--d[j]操作就是将t 与 j 之间的边删掉</span></span><br><span class="line">            <span class="comment">//删除t指向j的边后如果入度为0，则入队，可能不止一个点指向j</span></span><br><span class="line">            <span class="keyword">if</span>(--d[j] == <span class="number">0</span>) q[++tt] = j;	</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果每个节点都已经入队，则表示该图可以进行拓扑排序</span></span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">        d[b]++;	<span class="comment">//a-&gt;b 的有向边，b的入度+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">topo</span>()) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最短路问题">最短路问题</h4>
<p><strong>概念</strong></p>
<ul>
<li>最短路问题即是寻找同一个网络中的两个节点之间的一条通路，使“消耗”在这条通路上的权重最小的问题，这里的权重可替换为最小距离、最短时间、最小成本等。</li>
</ul>
<p><strong>分类</strong></p>
<ul>
<li>单源最短路
<ul>
<li>所有边权都为正数
<ul>
<li>朴素Dijkstra算法：o(n ^ 2)</li>
<li>堆优化版Dijkstra算法：o(mlogn)</li>
</ul></li>
<li>存在负边
<ul>
<li>Bellman_ford算法：o(n*m)</li>
<li>SPFA算法：一般o(m), 最坏 o(n*m)</li>
</ul></li>
</ul></li>
<li>多源最短路
<ul>
<li>Floyd算法：o(n^3)</li>
</ul></li>
</ul>
<h5 id="朴素dijkstra算法">朴素Dijkstra算法</h5>
<p><strong>使用条件</strong></p>
<ul>
<li>所有边权必须为正数：如果边权为负数则违背了贪心原则</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g[N][N];	<span class="comment">//使用临接矩阵的方式来存储图，g[1][2] = 3，表示从1号点到2号点的边权为3</span></span><br><span class="line"><span class="type">int</span> n, m;	<span class="comment">//n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> dist[N];	<span class="comment">//dist[x]，表示x号点到原点的距离，其在dijkstra中是不断更新的</span></span><br><span class="line"><span class="type">bool</span> st[N];	<span class="comment">//st[x] 表示x点的状态：x点到原点的距离是否确定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);	<span class="comment">//初始化，每个点到原点的距离为 无穷大</span></span><br><span class="line">    </span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;	<span class="comment">//初次迭代，1号点到1号点的距离为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)		<span class="comment">//一共有n个点，需要遍历n次(也可以只遍历n-1次)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;		<span class="comment">//t表示当前走到的点的编号</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)	<span class="comment">//遍历编号为1~n的所有的点</span></span><br><span class="line">            <span class="comment">//if是用来寻找没有走过的点中的边权最小的点</span></span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))	</span><br><span class="line">                t = j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)	<span class="comment">//更新编号为1~n的所有的点到原点的距离 dist[j]</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + g[t][j])		<span class="comment">//需要取最短路径</span></span><br><span class="line">                dist[j] = dist[t] + g[t][j];</span><br><span class="line">                </span><br><span class="line">        st[t] = <span class="literal">true</span>;	<span class="comment">//标记t到原点的距离已经确定</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//若dist[n]没有被改动，则到达不了n这个点</span></span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        g[a][b] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dijkstra</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="堆优化版dijkstra算法">堆优化版dijkstra算法</h5>
<p><strong>优化</strong></p>
<ul>
<li>在朴素版的寻找没有走过的点中的边权最小的点的过程中，每次都需要遍历每一个点，时间复杂度较大</li>
<li>堆优化就是利用小根堆，每次能够快速的找到边权最小的点</li>
<li>使用STL中的priority_queue来优化</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;	<span class="comment">//存储(距离，编号)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[N], ne[N], h[N], w[N], idx;	<span class="comment">//稀疏图用临接表来存储，w[]用来存储边权</span></span><br><span class="line"><span class="type">int</span> dist[N];	</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span>	<span class="comment">//常规的插入操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx, w[idx++] = c;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//默认是大根堆，定义小根堆需要写全</span></span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);	<span class="comment">//dist数组初始化为0x3f3f3f3f</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    heap.<span class="built_in">emplace</span>(<span class="number">0</span>, <span class="number">1</span>);	<span class="comment">//往堆中插入一号点和距离</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())	<span class="comment">//有点像bfs的模板hh</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();	<span class="comment">//取出队头并队头出队</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> id = t.second, d = t.first;	<span class="comment">//id表示队头的编号，d表示队头到原点的距离</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(st[id]) <span class="keyword">continue</span>;	<span class="comment">//t已经确定距离，则跳到下一个点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[id]; i != <span class="number">-1</span>; i = ne[i])	<span class="comment">//更新t点能走到的点到原点的距离</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[id] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[id] + w[i];	<span class="comment">//j点入队</span></span><br><span class="line">                heap.<span class="built_in">emplace</span>(dist[j], j);	<span class="comment">//emplace(a, b) 等价于 push(&#123;a, b&#125;)，前者效率更高</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        st[id] = <span class="literal">true</span>;	<span class="comment">//t点的距离已经确定</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dijkstra</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="有边数限制的最短路问题">有边数限制的最短路问题</h5>
<h6 id="bellman_ford算法">Bellman_ford算法</h6>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;	<span class="comment">//N表示最大顶点数，M表示最大边数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">&#125;edges[M];	<span class="comment">//使用结构体数组来存储图，abc表示 a到b的边权为c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> dist[N], backup[N];	<span class="comment">//backup为dist的备份数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);	<span class="comment">//dist数组初始化为无穷大</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    	</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)	<span class="comment">//k表示 经过不超过k条边使n到1号点的距离最小</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(backup, dist, <span class="keyword">sizeof</span> dist);	<span class="comment">//每次只更新一层的边(一步), 为了防止串联而开的备份数组</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> e = edges[j];</span><br><span class="line">            dist[e.b] = <span class="built_in">min</span>(dist[e.b], backup[e.a] + e.c);	<span class="comment">//注意用的是备份数组 backup[e.a]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        edges[i] = &#123;a, b, c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bellman_ford</span>();</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//不能使用判断条件：dist[n] == 0x3f3f3f3f 因为存在负权边，例如dist[n] = 0x3f3f3f3f - 1; 虽然小于0x3f3f3f3f但该结果仍然表示无解</span></span><br><span class="line">    <span class="keyword">if</span>(dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dist[n]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="队列优化版的bellman_ford算法">队列优化版的Bellman_ford算法</h6>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[M], ne[M], h[N], w[M], idx;	</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx, w[idx++] = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">emplace</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//类似BFS的一个模板，k表示最多经过的边数</span></span><br><span class="line">    <span class="keyword">while</span>(k-- &amp;&amp; q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(n--)	<span class="comment">//类似层序遍历中对当前层的所有节点都进行一个遍历 必须这样做，while循环不能去掉</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> [x, p] = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//遍历所有对头元素所能到的点，更新它们的dist值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j = e[i]; <span class="comment">//i对应的是邻接表的下标，j对应的是节点的编号，p表示上一步操作的dist[x]</span></span><br><span class="line">                <span class="keyword">if</span>(dist[j] &gt; w[i] + p)</span><br><span class="line">                &#123;</span><br><span class="line">                    dist[j] = w[i] + p;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(j, dist[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dist[n]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="spfa算法">spfa算法</h5>
<ul>
<li>Bellman_ford算法每次对每一条边都进行修改，但其中修改不一定都是有效的</li>
<li>spfa算法则是只对修改过的边进行修改，大大提高了效率</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//spfa求最短路</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[N], ne[N], w[N], h[N], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">bool</span> st[N];		<span class="comment">//st数组用来表示当前点是否已经入队</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx, w[idx++] = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];	<span class="comment">//对队头的每一条出边进行更新</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])	<span class="comment">//如果j不在队列中且被修改过，将其入队</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不需要 &gt; 0x3f3f3f3f / 2, 因为spfa不是对每一条边进行修改，只有连通的边才会被修改到</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>() == <span class="number">0x3f3f3f3f</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">spfa</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="spfa判断负环">spfa判断负环</h5>
<ul>
<li><p>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，
边权可能为负数。请你判断图中是否存在负权回路。</p></li>
<li><p>负权回路：一个回路，并且转一圈后的边权之和为负数</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>, M = <span class="number">10010</span>;	<span class="comment">//N为点树，M为边数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> e[M], ne[M], h[N], w[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];	<span class="comment">//cnt[x] 表示走到x点所经过的边数</span></span><br><span class="line"><span class="type">bool</span> st[N];		<span class="comment">//判断点是否已经入队</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx, w[idx++] = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//dist不需要初始化为无穷大：因为dist数组不是存的最短路径，而是用来判断负权边的</span></span><br><span class="line">    <span class="comment">//首先需要将所有点入队，因为负环可能不在从起点到终点的路上</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对队头的出边进行拓展</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果t点上存在负环，则会一直在循环里面转圈</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;	<span class="comment">//到j点的边数 + 1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//t点上没有负环的情况下，cnt[j]是不会超过 n-1 的</span></span><br><span class="line">                <span class="comment">//如果cnt[j]超过了n-1则表示一定存在负环</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//若j没有入队，则将其入队</span></span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>()) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="floyd算法">floyd算法</h5>
<ul>
<li><p>一个基于动态规划原理的算法，用来求任意两点间的最短距离</p></li>
<li><p>d[k, i, j] 表示经过 1~ k 的点从 i 到 j
的最短距离，其无非就两种情况</p>
<ol type="1">
<li>不经过k这个点，从 i 到 j ：d[k-1, i, j]</li>
<li>经过k这个点，从 i 到 j：d[k-1, i, k] + d[k-1, k, j]</li>
</ol></li>
<li><p>由此得出 d[k, i, j] = min( d[k-1, i, j], d[k-1, i, k] + d[k-1, k,
j])</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>, INF = <span class="number">1e9</span>;	<span class="comment">//N表示点数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[N][N];	<span class="comment">//用一个二维数组来边权 d[a][b] = c 表示 a 到 b 的边权为 c</span></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][k] + d[k][j], d[i][j]);	<span class="comment">//这里的d[i][j] 就是d[k-1, i, j]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)	<span class="comment">//为什么不初始化为0x3f3f3f3f?：多源汇最短路问题可能需要求自己到自己的距离</span></span><br><span class="line">            <span class="keyword">if</span>(i == j) d[i][j] = <span class="number">0</span>;		<span class="comment">//d[i][j] = 0目的是干掉自环</span></span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        d[a][b] = <span class="built_in">min</span>(d[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">floyd</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="comment">//floyd算法是对每一条边进行操作，所有是有可能出现 INF - 1 的情况的，所以需要 INF / 2</span></span><br><span class="line">        <span class="keyword">if</span>(d[x][y] &gt; INF / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d[x][y]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最小生成树问题">最小生成树问题</h4>
<p><strong>概念</strong></p>
<ul>
<li>将一个图中的所有节点连接起来，并且使得所有边的边权之和最小</li>
<li>一般只用于无向图</li>
</ul>
<p><strong>实用场景</strong></p>
<ul>
<li>在若干个城市之间铺路，各个路段可以交叉，如何铺路使得铺路成本最小</li>
</ul>
<h5 id="prime算法">prime算法</h5>
<ul>
<li>与Dijkstra算法十分相似，同样也有堆优化的版本</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g[N][N];	<span class="comment">//邻接矩阵存储边</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dist[N];	<span class="comment">//dist[x]表示x到最小树集合的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];		<span class="comment">//st[x]表示x是否已经加入最小树集合中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;	<span class="comment">//挑取第一个点为起点</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;	<span class="comment">//记录最小树的边权之和</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;		<span class="comment">//t表示所有没入集合的点中距离集合最近的点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;	<span class="comment">//筛选t</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dist[t] == INF) <span class="keyword">return</span> INF;	<span class="comment">//如果距离最近的点t到集合的距离都是INF的话说明存在点不与树连通的点，一定不存在最小生成树</span></span><br><span class="line">        </span><br><span class="line">        res += dist[t];	<span class="comment">//边权加到res中</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注意要先更新res，再更新dist[j]，否则会将负的子环边更新到dist[t]中，最终导致加到res中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">            </span><br><span class="line">        st[t] = <span class="literal">true</span>;	<span class="comment">//t入集合</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">prim</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(t == INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="kruskal算法">kruskal算法</h5>
<p><strong>思路</strong></p>
<ul>
<li>先将所有边按照边权从小到大排序</li>
<li>再将所有顶点看做单独一个集合</li>
<li>再根据顺序对每个顶点进行并查集的操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Edge &amp;e) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; e.w; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[N];	<span class="comment">//结构体数组存储边</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, cnt;	<span class="comment">//cnt记录最小生成树中的边数</span></span><br><span class="line"><span class="type">int</span> p[N];	<span class="comment">//p[x] 表示x的祖宗节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>		<span class="comment">//并查集的模板	</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruscal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;	<span class="comment">//记录边权总和</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;	<span class="comment">//p数组的初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);	<span class="comment">//按照边权从小到大对每一条边进行排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)	<span class="comment">//按照顺序对每一条边进行并查集操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);	</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pa != pb)	<span class="comment">//如果两个点不在同一个集合中，则将其加入到同一集合中</span></span><br><span class="line">        &#123;				<span class="comment">//如果两个点在同一个集合中，则跳过</span></span><br><span class="line">            p[pa] = pb;</span><br><span class="line">            res += w;	<span class="comment">//边权相加</span></span><br><span class="line">            cnt++;		<span class="comment">//树的边数+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;	<span class="comment">//连通n个点，需要n-1条边，如果小于n-1 则表明所有点不连通</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        edges[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">kruscal</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(t == INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二分图">二分图</h4>
<p><strong>概念</strong></p>
<ul>
<li>二分图是一类特殊的图，它可以被划分为两个部分，每个部分内的点互不相</li>
<li>二分图的每一条边都是从一个集合指向另一个集合</li>
<li>二分图一定不存在奇数环</li>
</ul>
<h5 id="染色法判断二分图是否存在">染色法判断二分图是否存在</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[M], ne[M], h[N], idx;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> color[N];	<span class="comment">//存储当前点的颜色，值只有1和2两种情况</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span>	<span class="comment">//染色法其实就是一个深度优先遍历的过程，规定如果u节点对应的链表上存在有颜色冲突的节点</span></span></span><br><span class="line"><span class="function"></span>&#123;						<span class="comment">//则返回false，不存在则放回true</span></span><br><span class="line">    color[u] = c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])	<span class="comment">//深搜的一个过程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];	</span><br><span class="line">        <span class="keyword">if</span>(!color[j])	<span class="comment">//如果当前j节点没有染色(全局变量初始化为0),j有可能在其他树中被染过色了</span></span><br><span class="line">        &#123;</span><br><span class="line">           	<span class="comment">//因为颜色只用1和2表示，所有进行下一次染色可以用3-c表示染不同颜色</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(j, <span class="number">3</span> - c)) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//简化了代码 原：bool res = dfs(j, 3 - c);if(res == flase) return false;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果j节点的颜色与当前节点相同，则表示产生了颜色冲突，return false</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;	<span class="comment">//打个标记</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对每一条分支进行遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//i节点没染色才染色，否则不需要 i有可能在其他树中被染过色了</span></span><br><span class="line">        <span class="keyword">if</span>(!color[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(i, <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//只要有一条分支有颜色冲突，其他的不用看了，直接判定不存在二分图</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="匈牙利算法">匈牙利算法</h5>
<p><strong>用途</strong></p>
<ul>
<li>解决二分图的完全匹配的最大个数</li>
</ul>
<p><strong>例题</strong></p>
<ul>
<li>二分图的最大匹配：二分图的两个集合中 [不相同并且存在边] 的点 的数量
最大</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n1, n2, m;</span><br><span class="line"><span class="type">int</span> e[M], ne[M], h[N], idx;</span><br><span class="line"><span class="type">bool</span> st[N];		<span class="comment">//st[]表示女孩有没有被遍历过，如果没有st[]数组标记则会陷入死循环</span></span><br><span class="line"><span class="type">int</span> match[N];	<span class="comment">//match[]表示女孩的约定的男孩</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])	<span class="comment">//对x这个男孩心意的所有女孩进行遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];	<span class="comment">//j表示其中一个女孩</span></span><br><span class="line">        <span class="keyword">if</span>(!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(!match[j] || <span class="built_in">find</span>(match[j]))	<span class="comment">//如果j女孩名花无主或者女孩约定的男孩能找到其他女孩进行匹配</span></span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;	<span class="comment">//则当前女孩与当前男孩约定，则可以返回true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//实在不行就只能返回false了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n1, &amp;n2, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);	<span class="comment">//st是全局数组，每个男孩进行匹配女孩的过程所有女孩都必须先初始化为false</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(i)) res++;	<span class="comment">//男孩匹配成功则结果+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="树的直径">树的直径</h4>
<p><strong>定义</strong></p>
<ul>
<li>树上最远的两个节点之间的距离就被称为树的直径</li>
</ul>
<p><strong>构造方法</strong></p>
<ul>
<li>在树上任意取一点 a，找到距离其最远的点 b；再从 b
出发，找到距离其最远的点 c</li>
<li>此时，b 与 c 之间的距离就是树的直径</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="comment">//由于树是双向边：所以需要开两倍的空间</span></span><br><span class="line"><span class="type">int</span> e[N * <span class="number">2</span>], ne[N * <span class="number">2</span>], h[N], w[N * <span class="number">2</span>], idx;</span><br><span class="line"><span class="type">int</span> mxu, mxd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span>	<span class="comment">//邻接表存储图(树)，也叫链式向前星</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx, w[idx++] = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f, <span class="type">int</span> d)</span>	<span class="comment">//u表示当前节点，f表示其父节点，d表示当前已走距离</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//u代表的是真实的节点值，h[u]存的是树中节点的下标，e[]中存储的才是真实的节点值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])	<span class="comment">//遍历u能到的所有点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="type">int</span> v = w[i];	</span><br><span class="line">        <span class="keyword">if</span>(j == f) <span class="keyword">continue</span>;	<span class="comment">//避免死循环，因为是双向边，遇到其父节点需要直接跳过</span></span><br><span class="line">        <span class="keyword">if</span>(v + d &gt; mxd)	<span class="comment">//如果路径距离大于当前的mxd，则更新节点和最大距离值</span></span><br><span class="line">        &#123;</span><br><span class="line">            mxu = j;</span><br><span class="line">            mxd = v + d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(j, u, d + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">        <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    mxd = <span class="number">0</span>;	<span class="comment">//理论上必须重置为0， 但不重置也能ac</span></span><br><span class="line">    <span class="built_in">dfs</span>(mxu, <span class="number">-1</span>, <span class="number">0</span>);	<span class="comment">//在此次dfs完后可以求出树的直径mxd</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//求出树的直径后根据题意输出即可</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, mxd * <span class="number">10</span> + (((<span class="number">1ll</span> + mxd) * mxd) &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>搜索与图论</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/posts/79666db/</url>
    <content><![CDATA[<h4 id="单链表">单链表</h4>
<p><strong>实现方式</strong></p>
<ul>
<li>利用数组实现静态链表</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>与结构体+指针的实现方式相比，使用数组实现速度更快，效率更高（new一个节点的过程太慢）</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;		<span class="comment">//根据题目的数据范围制定数组边界</span></span><br><span class="line"><span class="type">int</span> head, idx;		<span class="comment">//head为头指针，idx为可用的数组下标索引值</span></span><br><span class="line"><span class="type">int</span> e[N], ne[N];	<span class="comment">//e[]用来存放节点的数据，ne[]用来存放下一个节点的索引值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>, idx = <span class="number">0</span>;		<span class="comment">//head类似指针，一开始指向空(-1的位置) idx为0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">head_insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;		<span class="comment">//先赋值到数组中</span></span><br><span class="line">    ne[idx] = head;	<span class="comment">//&quot;插入元素&quot;的下一个元素为头节点指向的位置（头插法）</span></span><br><span class="line">    head = idx;		<span class="comment">//head指向插入的元素</span></span><br><span class="line">    idx ++;			<span class="comment">//数组可用索引值向前移1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据插入指定位置的下一个位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">k_insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;		<span class="comment">//将数据存入数组中</span></span><br><span class="line">    ne[idx] = ne[k];<span class="comment">//数据指向k位置的下一个元素</span></span><br><span class="line">    ne[k] = idx;	<span class="comment">//k位置指向数据位置</span></span><br><span class="line">    idx ++;			<span class="comment">//索引值前移</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除指定位置上的数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="双链表">双链表</h4>
<p><strong>实现方式</strong></p>
<ul>
<li>利用 数组l[]、r[] 分别表示任意节点的上一个节点和下一个节点</li>
<li>规定，0 和 1 分别表示左边界和右边界，因此idx从2开始取</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span>		<span class="comment">//初始化操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[<span class="number">1</span>] = <span class="number">0</span>;	<span class="comment">//起始链表中无数据，0 和 1 位置是相邻的</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    idx = <span class="number">2</span>;	<span class="comment">//idx必须从2开始取</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span>	<span class="comment">//插入节点，规定从k下标的右边插入节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//理清楚操作顺序</span></span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = k;		<span class="comment">//idx的上一个节点位置为k</span></span><br><span class="line">    r[idx] = r[k];	<span class="comment">//idx的下一个节点位置为原来k位置的下一个节点</span></span><br><span class="line">    l[r[k]] = idx;	<span class="comment">//原k位置下一个节点的上一个节点位置为idx</span></span><br><span class="line">    r[k] = idx;		<span class="comment">//k位置的节点的下一个节点位置为idx</span></span><br><span class="line">    idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> k)</span>		<span class="comment">//删除k位置上的节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[l[k]] = r[k];	<span class="comment">//k位置的上一个节点指向k位置的下一个节点	</span></span><br><span class="line">    l[r[k]] = l[k];	<span class="comment">//k位置的下一个节点指向k位置的上一个节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双链表的遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = r[<span class="number">0</span>]; i != <span class="number">1</span>; i = r[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//r[0]表示 0位置的下一个节点，从其开始遍历；当r[i] = 1 时表示其到达了右边界</span></span><br></pre></td></tr></table></figure>
<h4 id="栈">栈</h4>
<p><strong>实现</strong></p>
<ul>
<li>用数据模拟栈的结构</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> stk[N], tt;</span><br><span class="line"><span class="comment">//进栈</span></span><br><span class="line">stk[++tt] = x;</span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line">tt--;</span><br><span class="line"><span class="comment">//获取栈顶元素</span></span><br><span class="line">stk[tt];</span><br><span class="line"><span class="comment">// 判断栈是否为空，如果 tt &gt; 0，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (tt &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>例题</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入一个算术表达式(只包含加减乘除运算) 输出其结果	样例：(2+2)*(1+1)  8</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="comment">/*思路，两个栈，一个栈用来存储数字，一个用来存储运算符号*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据实际运算符优先级制定运算顺序</span></span><br><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; cmp = &#123; &#123;<span class="string">&#x27;+&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;-&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;/&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;*&#x27;</span>, <span class="number">2</span>&#125; &#125;;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; num;		<span class="comment">//存储数字</span></span><br><span class="line">stack&lt;<span class="type">char</span>&gt; op;		<span class="comment">//存储运算符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟运算过程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> x = num.<span class="built_in">top</span>(); num.<span class="built_in">pop</span>();	<span class="comment">//取出后进的一个数并出栈</span></span><br><span class="line">    <span class="type">int</span> y = num.<span class="built_in">top</span>(); num.<span class="built_in">pop</span>();	<span class="comment">//取出先进的一个数并出栈</span></span><br><span class="line">    <span class="type">char</span> c = op.<span class="built_in">top</span>(); op.<span class="built_in">pop</span>();	<span class="comment">//取出运算符号</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;	<span class="comment">//表示结果</span></span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span>) res = y + x;	<span class="comment">//注意一下所有运算顺序都是先y后x，因为y先进栈</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) res = y - x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;*&#x27;</span>) res = y * x;</span><br><span class="line">    <span class="keyword">else</span> res = y / x;</span><br><span class="line">    num.<span class="built_in">push</span>(res);	<span class="comment">//将最后的结果更新至数字栈中，方便下一次的eval()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    <span class="comment">//一下都是模板代码，需要加入新的操作时只需要将新运算符的优先级加到cmp中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> c = str[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = i, x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; str.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(str[j]))	<span class="comment">//读取到下一个字符不为数字为止</span></span><br><span class="line">            &#123;</span><br><span class="line">                x = x * <span class="number">10</span> + (str[j++] - <span class="string">&#x27;0&#x27;</span>);		<span class="comment">//将字符变为十进制数字</span></span><br><span class="line">            &#125;</span><br><span class="line">            num.<span class="built_in">push</span>(x);</span><br><span class="line">            i = j - <span class="number">1</span>;	<span class="comment">//i需要从j-1的位置开始读</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>) op.<span class="built_in">push</span>(c);	<span class="comment">//如果为左括号，直接插入符号栈</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当待插入的符号为右括号时，则必定有左括号，所以必须先进行括号中的运算</span></span><br><span class="line">            <span class="keyword">while</span>(op.<span class="built_in">size</span>() &amp;&amp; op.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>) <span class="built_in">eval</span>();	</span><br><span class="line">            op.<span class="built_in">pop</span>();	<span class="comment">//左括号出栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//加减乘除的情况</span></span><br><span class="line">            <span class="comment">//当符号栈中有符号时并且待入栈的优先级小于栈顶符号时，需要先进行优先级大的运算</span></span><br><span class="line">            <span class="comment">//使用op.size()的目的是排除栈空的情况</span></span><br><span class="line">            <span class="keyword">while</span>(op.<span class="built_in">size</span>() &amp;&amp; cmp[c] &lt;= cmp[op.<span class="built_in">top</span>()]) <span class="built_in">eval</span>();</span><br><span class="line">            op.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最终符号栈中仍是有运算符的，还需要对其计算</span></span><br><span class="line">    <span class="keyword">while</span>(op.<span class="built_in">size</span>()) <span class="built_in">eval</span>();</span><br><span class="line">    cout &lt;&lt; num.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="队列">队列</h4>
<p><strong>实现</strong></p>
<ul>
<li>数组实现</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> que[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//进队列</span></span><br><span class="line">que[++tt] = x;</span><br><span class="line"><span class="comment">//出队列</span></span><br><span class="line">hh++;</span><br><span class="line"><span class="comment">//获取队头元素</span></span><br><span class="line">que[hh];</span><br><span class="line"><span class="comment">//判空，若hh小于tt，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span>(hh &lt;= tt)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单调栈和单调队列">单调栈和单调队列</h4>
<p><strong>定义</strong></p>
<ul>
<li>栈或队列中元素呈单调性</li>
</ul>
<p><strong>解题思路</strong></p>
<ul>
<li>先使用暴力方法计算</li>
<li>再从中挖掘性质，看其是否有单调的性质</li>
<li>最后使用单调栈或单调队列进行优化：O(n<sup>2</sup>) 优化至O(n)</li>
</ul>
<p><strong>单调栈使用场景</strong></p>
<ol type="1">
<li>寻找一个数左边第一个小于它的数或下标</li>
<li>寻找一个数右边第一个大于它的数或下标（与场景1的操作相似，不过对于数组是逆序遍历）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], ans[N];</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"><span class="comment">//模板代码：《寻找一个数左边第一个小于它的数或下标》，此题为找数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; stk.<span class="built_in">top</span>() &gt;= a[i]) stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!stk.<span class="built_in">empty</span>()) ans[i] = stk.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">else</span> ans[i] = <span class="number">-1</span>;</span><br><span class="line">        stk.<span class="built_in">push</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>单调队列例题</strong></p>
<p><strong>滑动窗口</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N], q[N], n, k;	<span class="comment">//q[N]用来存储数组元素下标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;	<span class="comment">//队列的初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)	<span class="comment">//输出窗口中的最小元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + <span class="number">1</span>) hh++; <span class="comment">//如果队列头对应的下标小于窗口的最左下标，则需将头指针hh前移动</span></span><br><span class="line">        										<span class="comment">//即删除队头元素</span></span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--;<span class="comment">//当队尾元素大于等于待插入元素时，需要将原队尾元素删除	</span></span><br><span class="line">        q[++tt] = i;	<span class="comment">//将下标插入队列          //hh &lt;= tt 表示的是队列不为空</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);	<span class="comment">//特判，窗口还未形成(i &lt; k - 1)无需输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);	<span class="comment">//换行</span></span><br><span class="line">    </span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;	<span class="comment">//重新初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)	<span class="comment">//输出窗口中的最大元素，只修改一处</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + <span class="number">1</span>) hh++;</span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--;	<span class="comment">//由于需要降序排列，所以是队尾元素小于等于待插入的元素</span></span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="kmp算法">kmp算法</h4>
<p><strong>起源</strong></p>
<ul>
<li>针对于字符串的匹配优化的算法</li>
</ul>
<p><strong>题目</strong></p>
<ul>
<li>给定一个字符串 S，以及一个模式串
P，所有字符串中只包含大小写英文字母以及阿拉伯数字。模式串 P 在字符串 S
中多次作为子串出现。求出模式串 P 在字符串 S
中所有出现的位置的起始下标</li>
</ul>
<p><strong>暴力解法</strong></p>
<ul>
<li>从头开始遍历匹配，若遇到不匹配的字符，则从字符串S的下一个位置开始进行比较（自字符串向后移动一位）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; n &amp;&amp; j &lt; m)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i] == p[j])</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        i = i - j + <span class="number">1</span>;	<span class="comment">//i,j均为下标，此时已经进行匹配的长度为 j+1 (因为字符串下标从0开始)</span></span><br><span class="line">        j = <span class="number">0</span>;		<span class="comment">//i需要指向起始匹配位置的下一个位置，下标为(i下标 - 长度 + 1) + 1 = [(i) - (j + 1) + 1]</span></span><br><span class="line">    &#125;				<span class="comment">//下标减长度加1就是原来位置的下标，最后加上1就是进行下一次匹配的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化</strong></p>
<ul>
<li>原来的算法只将字符串p往后一位，意味着有很多之前已经匹配过的字符，效率很低，如果能将s的指针不回退，而只让s的指针一直往前走，就可以提高执行的效率</li>
</ul>
<p><strong>代码模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将整个匹配过程分为两部分，先求p字符串的ne数组</span></span><br><span class="line"><span class="comment">//1.求ne数组</span></span><br><span class="line"><span class="comment">//n为p串长度，m为s串长度</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i++)	<span class="comment">//根据ne数组的特性，ne[1]为0，无需计算，故i初始化为2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; p[i] != p[j+<span class="number">1</span>]) j = ne[j];	<span class="comment">//递归的一种做法，假设已经求出ne数组</span></span><br><span class="line">    <span class="keyword">if</span>(p[i] == p[j+<span class="number">1</span>]) j++;</span><br><span class="line">    ne[i] = j;		<span class="comment">//执行到此，说明已满足前缀匹配后缀</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.匹配过程，两个串的下标都是从1开始，所以i初始化为1，而将i与j+1比，故将j初始化为0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span>(s[i] == p[j+<span class="number">1</span>]) j++;	<span class="comment">//如果两串元素相同，则将j移动至下一位，i在循环结束后会自动++</span></span><br><span class="line">    <span class="keyword">if</span>(j == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i - n);	<span class="comment">//匹配成功后的逻辑，此题求的是每一次匹配的位置</span></span><br><span class="line">        j = ne[j];	<span class="comment">//进行下一次的匹配</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="trie树">Trie树</h4>
<p><strong>使用场景</strong></p>
<ul>
<li>字符串存储、统计，所以又称作字典树</li>
</ul>
<p><strong>代码模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span>	<span class="comment">//str为待插入的字符串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;	<span class="comment">//根节点起始为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;	<span class="comment">//将a~z映射成[0,25]</span></span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u] = ++idx;	<span class="comment">//如果p节点没有u这个子节点，则为其创建子节点，并标号为++idx</span></span><br><span class="line">        									<span class="comment">//注意这里不能改为idx++，因为idx初始为0，根节点也为0，不能与根节点一致</span></span><br><span class="line">        p = son[p][u];	<span class="comment">//p指向子节点u</span></span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;	<span class="comment">//此时字符串已经存储完毕，需要将最后一个字符做个标记，便于以后的统计字符串的个数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> str[])</span>	<span class="comment">//返回str在树中出现的次数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;	<span class="comment">//根节点起始为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;	<span class="comment">//将a~z映射成[0,25]</span></span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">//如果p节点没有u这个子节点，则为直接返回0</span></span><br><span class="line">        p = son[p][u];	<span class="comment">////p指向子节点u</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];	<span class="comment">//此时字符串已经到达最后一个节点，由此可以判断其一共出现了多少次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>例题</strong></p>
<ul>
<li>在给定的 N 个整数 A1，A2 .... An中选出两个进行
xor（异或）运算，得到的结果最大是多少</li>
<li>其中 0 &lt; N &lt; 100000, 0 &lt;= A &lt;= 2<sup>31</sup></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">31</span> * N;	<span class="comment">//N表示一共有多少个数字，每个数字最多可能有31位，M表示所有数组位数的最大可能</span></span><br><span class="line"><span class="type">int</span> son[M][<span class="number">2</span>], idx, arr[N];		<span class="comment">//因此需要开辟M个节点，每个节点最多能有2个子节点分别为0和1</span></span><br><span class="line">								<span class="comment">//arr[]存放真实的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span>	<span class="comment">//创建字典树的过程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)	<span class="comment">//最多31位，为什么从第30位开始？ 最高位位符号位，此题规定都为正数，无需考虑</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;		<span class="comment">//获取数字x的二进制位中的第i位，参考之前的模板 “x在二进制中的第k位数”</span></span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u] = ++idx;	<span class="comment">//如果没有此子节点，则为其创建</span></span><br><span class="line">        p = son[p][u];		<span class="comment">//p指向该节点的子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> x)</span>	<span class="comment">//从数字x开始，寻找异或运算可能的最大值：从最高位开始找，两个位不相同时，才有可能使得异或结果最大</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)	<span class="comment">//等价于for(int i = 30; i &gt;= 0; i--)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;		<span class="comment">//获取数字x的二进制位中的第i位 (从最高位开始)</span></span><br><span class="line">        <span class="keyword">if</span>(son[p][!u])			<span class="comment">//如果存在!u的子节点，则说明，两个位不同，p指向该子节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            res = res + (<span class="number">1</span> &lt;&lt; i);	<span class="comment">//!u存在，则说明异或结果为1，因为从最高位开始计算，所以需要将其左移i位</span></span><br><span class="line">            						<span class="comment">//左移i位再相加，相当于把每一位异或(二进制)的结果相加</span></span><br><span class="line">            p = son[p][!u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;						<span class="comment">//如果不存在!u的子节点，则说明两个位相同，p指向该u子节点</span></span><br><span class="line">            res = res + (<span class="number">0</span> &lt;&lt; i);</span><br><span class="line">            p = son[p][u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">        <span class="built_in">insert</span>(arr[i]);	<span class="comment">//读取数组，并且创建字典树</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) res = <span class="built_in">max</span>(res, <span class="built_in">search</span>(arr[i]));	<span class="comment">//模拟随机挑选两个数进行异或的过程</span></span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="合并集合">合并集合</h4>
<p><strong>使用场景</strong></p>
<ul>
<li>多次对多个集合进行合并或判断两个数是否在同一个集合中</li>
</ul>
<p><strong>代码模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[N];	<span class="comment">//p数组存放的是某一节点的父节点的位置 例，p[2] = 3, 表示2的父节点的位置为3</span></span><br><span class="line">			<span class="comment">//使用根节点来区别不同的集合，规定：根节点的父节点为它本身，即p[根节点] = 根节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;										 <span class="comment">//当x的父节点不是根节点时，再从其父节点往上走</span></span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]); <span class="comment">//递归调用find函数，当找到其根节点时，x的所有父节点的父节点都指向了根节点，压缩了线路</span></span><br><span class="line">    <span class="keyword">return</span> p[x];					 <span class="comment">//因此，下一次查询的时候可以更快地找到相应集合的根节点</span></span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> 	<span class="comment">//将a, b两个数所在的集合合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);	<span class="comment">//a的根节点指向b的根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>例题</strong></p>
<ul>
<li>食物链 题号240</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//思路，未确定关系之前，每一个动物都在独立的一个集合中，当确定关系后，将所有动物存放在同一颗树中，因为食物链构成了一个环形，所以根据其中两个动物的之间的关系，能推出第三个动物关系，例如：A吃B，B吃C 能推出 C吃A 此时，我们就可以通过各个动物与根节点之间的关系来推断各个动物之间的关系：如果动物到根节点的距离模3相等，则表示为同类动物；如果模3相差1则为捕食关系。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N], d[N];	<span class="comment">//p[x] 表示x的父节点；d[x]表示x到其父节点的距离</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>	<span class="comment">//寻找x的根节点，并压缩路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">find</span>(p[x]);	<span class="comment">//暂存根节点，否则下面的p[x]会受到影响</span></span><br><span class="line">        d[x] += d[p[x]];	<span class="comment">//更新路径，使d[x]直接为其到根节点的距离</span></span><br><span class="line">        p[x] = t;	<span class="comment">//p[x]指向根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];	<span class="comment">//返回x的根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;	<span class="comment">//初始化：所有x的根节点都是其本身</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;t, &amp;x, &amp;y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &gt; n || y &gt; n) res ++ ;	<span class="comment">//题目判断为假的条件</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> px = <span class="built_in">find</span>(x), py = <span class="built_in">find</span>(y);		<span class="comment">//先记录x,y的根节点，防止在里面递归调用（因为有距离的累加）</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="number">1</span>)	<span class="comment">//t == 1, 表示关于同类的描述</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (px == py &amp;&amp; (d[x] - d[y]) % <span class="number">3</span>) res ++ ;	<span class="comment">//x,y在同一颗树上，且d[x] % 3 != d[y] % 3</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (px != py)	<span class="comment">//x,y不在同一颗树上，此时需要建立x,y的同类关系</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p[px] = py;		<span class="comment">//两个集合合并</span></span><br><span class="line">                    d[px] = d[y] - d[x];	<span class="comment">//为x的根节点的父节点到y的根节点赋上一个距离，其满足(d[x] + d[px]) % 3</span></span><br><span class="line">                    						<span class="comment">// == d[y] % 3, 表示同类</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;		</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//x,y在同一棵树上且为同类时，此话为假</span></span><br><span class="line">                <span class="keyword">if</span> (px == py &amp;&amp; (d[x] - d[y] - <span class="number">1</span>) % <span class="number">3</span>) res ++ ;	</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (px != py)	<span class="comment">//x,y不在同一颗树上，此时需要建立x,y的捕食关系</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p[px] = py;		<span class="comment">//两个集合合并</span></span><br><span class="line">                    d[px] = d[y] + <span class="number">1</span> - d[x];</span><br><span class="line">             <span class="comment">//为x的根节点的父节点到y的根节点赋上一个距离，其满足(d[x] + d[px]) % 3 - 1== d[y] % 3，表示x吃y</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">记录思考时遇到的问题:</span></span><br><span class="line"><span class="comment">1.d数组初始化全为0，是如何实现赋值的？ 在后文，当两个节点不在同一颗树中时，其就为两个节点建立关系，并为d数组赋值</span></span><br><span class="line"><span class="comment">2.为什么d数组存放的不是实际到根节点-的距离，而且可能会出现负数的情况?</span></span><br><span class="line"><span class="comment">  建立关系时需要d[px]需要满足的是(d[x] + d[px]) % 3 == d[y] % 3 (以建立同类关系为例，捕食关系同理)</span></span><br><span class="line"><span class="comment">  等价于(d[x]%3 + d[px])%3 - (d[y]%3) == 0 等价于 (d[x]%3 + d[px])%3 - (d[y]%3)%3 == 0</span></span><br><span class="line"><span class="comment">  等价于(d[x] + d[px] - d[y])%3 == 0 由此推出 d[x] + d[px] - d[y] = k * 3, k取整数</span></span><br><span class="line"><span class="comment">  令 k=0 可得 d[x] + d[px] - d[y] = 0; 也正因为令k等于0，所以d数组中才可能有负数  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="堆">堆</h4>
<p><strong>本质</strong></p>
<ul>
<li>一个完全二叉树：从根节点开始，除了最后一层节点，其他节点都是存在的（即当前层存满了节点才会往下存）</li>
</ul>
<p><strong>堆排序</strong></p>
<ul>
<li>小顶堆：使列表数据从小到大排序</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> h[N], n, m, cnt;	<span class="comment">//h数组用于模拟堆结构,cnt表示当前堆中节点的个数以及最后一个节点的下标            </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = x;</span><br><span class="line">    <span class="comment">//用两个if来找到(x，x的左儿子，x的右儿子)中的最小值，t表示当前最小值得下标</span></span><br><span class="line">    <span class="comment">//其中所有下标不得超过当前堆的元素个数即cnt</span></span><br><span class="line">    <span class="keyword">if</span>(x * <span class="number">2</span> &lt;= cnt &amp;&amp; h[x * <span class="number">2</span>] &lt; h[t]) t = x * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[x * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x != t)	<span class="comment">//说明父节点在三者之中不是最小的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当前t表示最小值的下标，若找到，则需要将其上的数与父节点(x)交换</span></span><br><span class="line">        <span class="built_in">swap</span>(h[x], h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);	<span class="comment">//交换完后,t位置上的节点可能不满足小于其所有子节点,需要递归向下进行排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);	<span class="comment">//读取数据</span></span><br><span class="line">    cnt = n;	<span class="comment">//必须先更新堆中元素的个数再进行down</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从最后一个有子节点的节点进行down操作</span></span><br><span class="line">    <span class="comment">//为什么是从 n/2 开始：因为规定在堆中若h[x]为父节点,则h[2x]为左儿子，h[2x+1]为右儿子，n/2满足最后一个有子节点的父节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n / <span class="number">2</span>; i ; i--) <span class="built_in">down</span>(i);</span><br><span class="line">    	</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, h[<span class="number">1</span>]);	<span class="comment">//每次输出跟节点元素</span></span><br><span class="line">        h[<span class="number">1</span>] = h[cnt--];	<span class="comment">//然后将堆中最后一个元素赋给堆根节点</span></span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>);	<span class="comment">//新的根节点可能不满足小于其所有子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>模拟堆</strong></p>
<ul>
<li>堆的增查删改操作：这些操作都是基于核心操作实现：down，up操作实现的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> h[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将x位置上的元素向下移动</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = x;</span><br><span class="line">    <span class="keyword">if</span>(x * <span class="number">2</span> &lt;= cnt &amp;&amp; h[x * <span class="number">2</span>] &lt; h[t]) t = x * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[x * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(t != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[x], h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将x位置上的元素向上移动</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x / <span class="number">2</span> &amp;&amp; h[x] &lt; h[x / <span class="number">2</span>])	<span class="comment">//h[x/2]表示的是其父节点，若子节点更小，则移到父节点上去</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[x / <span class="number">2</span>], h[x]);</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;	<span class="comment">//使用位运算实现除以2效率更高</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    h[++cnt] = x;</span><br><span class="line">    <span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除指定位置元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(h[x], h[idx]);	<span class="comment">//交换指定元素与最后一个元素，在让其idx--，使得最后一个元素永久消失</span></span><br><span class="line">    idx--;</span><br><span class="line">    <span class="built_in">down</span>(x);	<span class="comment">//down()和up()只会执行其中的一个，因为其最终目的都是实现小根堆</span></span><br><span class="line">    <span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改指定位置元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    h[x] = v;	<span class="comment">//修改完后不一定满足小根堆，要么up要么down</span></span><br><span class="line">    <span class="built_in">down</span>(x);	<span class="comment">//down()和up()只会执行其中的一个</span></span><br><span class="line">    <span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="哈希表">哈希表</h4>
<p><strong>使用场景</strong></p>
<ul>
<li>将某些复杂较大的数映射成相对较小的数：例如将0 ~ 10<sup>9</sup>
的数映射成0 ~ 10<sup>5</sup> 的数</li>
<li>其最简单的操作就是让 x mol N , N 取 10<sup>5</sup></li>
</ul>
<p><strong>哈希冲突</strong></p>
<ul>
<li>两个相同的数会映射成同一个数，此时就产生了哈希冲突：映射后的数到底指向哪一个？</li>
</ul>
<p><strong>模拟哈希表</strong></p>
<ul>
<li>两种方式构建哈希表以解决哈希冲突
<ul>
<li>链表+数组的方式构建哈希表</li>
<li>数组 + 开放寻址法</li>
</ul></li>
<li>数组的长度(即N)的要求
<ul>
<li>在进行哈希时，被取模的数一般需要为质数，且远离2的n次方</li>
<li>因为可以用数学证明此种取法出现哈希冲突的概率最小</li>
</ul></li>
</ul>
<h5 id="模板题">模板题</h5>
<ul>
<li>模拟散列表</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拉链法，链指的是单链表</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100003</span>;	<span class="comment">//取模的数最好是质数，题目数据范围是1e5,100003为1e5之后的第一个质数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;	<span class="comment">//h[N]表示散列表，e[N]表示单链表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//首先找到x映射后的下标 为什么是(x % N + N) % N，因为取模运算在c++中是会出现负数的</span></span><br><span class="line">    <span class="comment">//例如 -10 % 3 == -1 (可以先当作正数取模，最后将取模结果加上负号即可)</span></span><br><span class="line">    <span class="comment">//负数取模运算结果只能是负数或0 (c++中), 数学中取模后的结果只能为正数</span></span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;	</span><br><span class="line">    e[idx] = x;		<span class="comment">//单链表的插入操作				</span></span><br><span class="line">    ne[idx] = h[k];	<span class="comment">//头插法，h[k]理解为头结点				</span></span><br><span class="line">    h[k] = idx ++ ; <span class="comment">//h[k]实际上存储的是真实数的下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断x是否在哈希表中</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;	<span class="comment">//首先需要找到x映射后的下标</span></span><br><span class="line">    <span class="comment">//从h[k]所在的单链表开始找，最后一个元素的ne为-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="comment">//由于h[k]是头结点，所以需要先将其指向一个标记</span></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);	<span class="comment">//memset按字节设置数值，-1的二进制位上全为1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开放寻址法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与拉链法不同，开放寻址法只需要开辟一个数组，但其大小要为数组数据的2~3倍，且数组长度也最好为质数且远离2的n次方</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200003</span>, null = <span class="number">0x3f3f3f3f</span>;	<span class="comment">//null用来标识空元素，因为其稍大于int，超过了各个数字的范围</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入数据的过程：找有没有位置能够存放改元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">    <span class="comment">//如果映射位置t上有元素，则需要从其下一位开始找，直到h[t] == null</span></span><br><span class="line">    <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        t ++ ;</span><br><span class="line">        <span class="comment">//如果t走到尽头没找到有空位的位置，则从头开始找</span></span><br><span class="line">        <span class="keyword">if</span> (t == N) t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//while循环一定会结束，因为哈希表数组容量是数据范围的两倍</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//首先需要将哈希表中的所有数字全部初始化为null</span></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> h);	<span class="comment">//因为memset是按照字节来初始化的，0x3f3f3f3f的一个字节就是0x3f</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;I&#x27;</span>) h[<span class="built_in">find</span>(x)] = x; 	<span class="comment">//插入元素</span></span><br><span class="line">        <span class="keyword">else</span>	<span class="comment">//查询一个元素是否出现在哈希表中出现过</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//出现哈希冲突的概率很小，所以当h[find(x)]等于null的时候，认为x没有出现过</span></span><br><span class="line">            <span class="keyword">if</span> (h[<span class="built_in">find</span>(x)] == null) <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="字符串哈希">字符串哈希</h5>
<ul>
<li><p>一种特殊的哈希方式，对一个长字符串进行哈希处理，将其所有前缀映射成一个P进制的数，通过这个P进制的哈希值，可以很快地比较两个字符串是否相等</p></li>
<li><p>将所有前缀映射成哈希值的好处：可以快速求得下一个前缀的哈希值
例：已知"PSDI"的哈希值，可以求得"PSDIA"的哈希值</p></li>
<li><p>映射过程：P进制的每个位上表示当前字符的ASCII码值，最后对这个P进制数取余数即为该前缀的哈希值</p></li>
<li><p>注意：任意字符不能映射成0</p></li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	题目，给定一个字符串，要求判断主串中的两个子串是否相等</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, P = <span class="number">131</span>;	<span class="comment">//经验上P取 131 或 13331 Q 取2^64 次方此时冲突率最低，99.99%几率不冲突</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[N];	<span class="comment">//用于接收字符串</span></span><br><span class="line">ULL h[N], p[N];	<span class="comment">//h[1]表示str第一个字符的哈希值，以此类推；p[1]表示 p的1次方</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//计算区间子字符串哈希值的公式</span></span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];	<span class="comment">//返回区间[l, r]子字符串的哈希值</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	解释一下公式：目标字符串哈希值：[l, r]位置子字符串的哈希值</span></span><br><span class="line"><span class="comment">    	已知[1, r] 和 [1, l] 的哈希值</span></span><br><span class="line"><span class="comment">    	过程：先将短串向左移动使其与长串最高位对其，移动的位数为 (r-1) - [(l-1) - 1] = r - l + 1</span></span><br><span class="line"><span class="comment">    	相当于乘上p的(r - l + 1)次方，其中(l-1)表示的是l的前一位</span></span><br><span class="line"><span class="comment">    	取模的过程在h[]数组接收int数据将其转换为ULL时已经完成，ULL最大可表示2^64，超过其范围会自动取模</span></span><br><span class="line"><span class="comment">    	而本题的Q恰好为2^64。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;	<span class="comment">//初始化，p的0次方为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//先将P进制数h[i - 1]向左移动一位，再加上当前位的值，最后总的再取模，因为h是ULL类型数组。 </span></span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] * P + str[i];	<span class="comment">//+str[i]加的是str[i]的ASCII值 </span></span><br><span class="line">        p[i] = P * p[i - <span class="number">1</span>];	<span class="comment">//构建p数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l1, r1, l2, r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">query</span>(l1, r1) == <span class="built_in">query</span>(l2, r2)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="树状数组和线段树">树状数组和线段树</h4>
<p><strong>关系</strong></p>
<ul>
<li>线段树包含了树状数组，树状数组能解决的问题，线段树也能解决，但是线段树解决问题的范围更大</li>
</ul>
<h5 id="树状数组">树状数组</h5>
<p><strong>核心功能</strong></p>
<ol type="1">
<li><p>使数组的指定位置 x 上加上一个数 v 时间复杂度：<span
class="math inline">\(O(logn)\)</span></p></li>
<li><p>快速查询数组的某个前缀和 [1, r] 时间复杂度：<span
class="math inline">\(O(logn)\)</span></p></li>
</ol>
<p><strong>注意：树状数组，原数组的下标必须从1开始</strong></p>
<p><strong>模型介绍</strong></p>
<p><img src="/images/树状数组.png" /></p>
<ul>
<li>设树状数组为 C(n), 原数组为 A(n)</li>
<li>n 为奇数时，C(n) = a(n)</li>
<li>含义：C[x]表示的是原数组 (x - lowbit(x), x] 该区间的和</li>
</ul>
<p><strong>核心函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N];	<span class="comment">//原数组</span></span><br><span class="line"><span class="type">int</span> tr[N];	<span class="comment">//树状数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span>	<span class="comment">//返回x的最后一位1对应的数字， 例如 lowbit(3) == 1 (3)2 = 11</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>	<span class="comment">//表示向原数组的x位置上加上一个数，对应的tr数组也必须跟着改变</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// i + lowbit(i) 表示的就是i的上一级，x位置上加上了一个数，则与其关联的tr都必须相应改变</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) tr[i] += y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//定义：tr[x] 中存放的是 (x-lobit(i), x]的和</span></span><br><span class="line">    <span class="comment">//想要得到S[1, x] 则必须将所有片段都累加，才能得到S[1, x]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &gt; <span class="number">0</span>; i -= <span class="built_in">lowbit</span>(i)) res += tr[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="线段树">线段树</h5>
<p><strong>模型介绍</strong></p>
<p><img src="/images/线段树.png" /></p>
<p><strong>核心功能</strong></p>
<ol type="1">
<li>使数组指定位置 x 加上一个数 时间复杂度 <span
class="math inline">\(O(logn)\)</span></li>
<li>快速查询数组的某个区间的和 [l, r] 时间复杂度：<span
class="math inline">\(O(logn)\)</span></li>
</ol>
<p><strong>与线段数组的异同</strong></p>
<ul>
<li>功能差不多，但是线段树可以求<strong>某个区间内的最大值</strong>，树状数组做不到</li>
<li>一般来说，线段树的执行效率要比树状数组慢</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个节点存储的信息有：当前区间[l,r] 当前区间和sum</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];	<span class="comment">//一般需要开四倍的空间，总节点数 &lt;= 4n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线段树的存储与heap类似，设当前节点为u，则tr[u&lt;&lt;1]存储u的左儿子节点，tr[u&lt;&lt;1|1]存储u的右儿子节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//更新某个节点的sum：用子节点l和子节点r的和来更新</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].sum = tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//当l == r表示当前区间只有一个数，则直接赋当前节点为&#123;l, r, w[l]&#125;</span></span><br><span class="line">    <span class="keyword">if</span>(l == r) tr[u] = &#123;l, r, w[l]&#125;;	<span class="comment">//注意不是w[u]</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid);	<span class="comment">//递归建立左儿子节点</span></span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);	<span class="comment">//递归建立右儿子节点</span></span><br><span class="line">        <span class="built_in">push_up</span>(u);	<span class="comment">//建完左儿子和右儿子后需要更新当前节点的sum</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> <span class="comment">//[l, r]表示查询区间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果查询区间完全包含了当前区间，则直接返回即可</span></span><br><span class="line">    <span class="keyword">if</span>(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//否则需要判断，查询区间与当前区间的那一半边有交集</span></span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果与左半边有交集，则查询u的左儿子节点</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) sum += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="comment">//如果与右半边有交集，则查询u的右儿子节点</span></span><br><span class="line">    <span class="keyword">if</span>(r &gt;= mid + <span class="number">1</span>) sum += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l , r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span> <span class="comment">//表示向根节点为u的，x位置上的值加上一个数v</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(tr[u].l == tr[u].r) tr[u].sum += v;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果修改位置在左边，则前往左边修改</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v); 	<span class="comment">//否则修改右边</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//凡是涉及值的变动，都需要更新一下当前节点的父节点</span></span><br><span class="line">        <span class="built_in">push_up</span>(u);	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);	<span class="comment">//建树的过程</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;k, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, x, y));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="number">1</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/posts/a4ce31d2/</url>
    <content><![CDATA[<span id="more"></span>
<h4 id="区间问题">区间问题</h4>
<h5 id="区间选点">区间选点</h5>
<p><strong>题目</strong></p>
<ul>
<li>给定 N 个闭区间
[ai,bi]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。输出选择的点的最小数量。位于区间端点上的点也算作区间内。</li>
</ul>
<p><strong>贪心解法</strong></p>
<ul>
<li>先将每个区间按照右端点进行一个排序，然后依次遍历每一个区间，只有当该区间的左端点严格大于末尾位置ed时，才需要新选择一个点</li>
<li>为什么要按照右端点进行排序：当某个区间的左端点严格大于末尾位置ed时，我们就一定可以判断出其与前面的区间不会有交集，因此选择按照右端点进行排序。有交集的两个区间属于同一个分组里面，每当一个区间与分组里的第一个区间没有交集，则需要重新选择一个点</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span>	</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Range &amp;e) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; e.r;		<span class="comment">//重载小于号，依据右端点进行排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;ranges[N];	<span class="comment">//存储每一条边</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        ranges[i] = &#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(ranges, ranges + n);	<span class="comment">//排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, ed = <span class="number">-2e9</span>;		<span class="comment">//ed表示末端点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> e = ranges[i];</span><br><span class="line">        <span class="keyword">if</span>(e.l &gt; ed)</span><br><span class="line">        &#123;</span><br><span class="line">            res++;</span><br><span class="line">            ed = e.r;	<span class="comment">//用新区间的右端点替换ed</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最大不相交区间数量">最大不相交区间数量</h5>
<p><strong>题目</strong></p>
<ul>
<li>给定 N 个闭区间
[ai,bi]，请你在数轴上选择若干区间，使得选中的区间之间互不相交（包括端点）。输出可选取区间的最大数量。</li>
</ul>
<p><strong>贪心解法</strong></p>
<ul>
<li>与区间选点的思路是一致的：先将区间按照右端点进行排序，再从第一个区间开始遍历，如果某个区间的左端点严格大于末端点，则选择区间的数量+1，依此选法，选到最后不相交的区间数量一定是最大的。</li>
<li>代码与区间选点是完全一致的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span>	</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Range &amp;e) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; e.r;		<span class="comment">//重载小于号，依据右端点进行排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;ranges[N];	<span class="comment">//存储每一条边</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        ranges[i] = &#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(ranges, ranges + n);	<span class="comment">//排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, ed = <span class="number">-2e9</span>;		<span class="comment">//ed表示末端点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> e = ranges[i];</span><br><span class="line">        <span class="keyword">if</span>(e.l &gt; ed)</span><br><span class="line">        &#123;</span><br><span class="line">            res++;</span><br><span class="line">            ed = e.r;	<span class="comment">//用新区间的右端点替换ed</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="区间分组">区间分组</h5>
<p><strong>题目</strong></p>
<ul>
<li>给定 N 个闭区间
[ai,bi]，请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。输出最小组数。</li>
</ul>
<p><strong>贪心思路</strong></p>
<ul>
<li>对于每一个区间，我们都要往前找有无能容纳它的分组，且如果有两个以上的分组，则任意选择一个组添加</li>
<li>在选择分组的时候，我们只需要找到任意一个组中区间右端点 r
的最大值，使新区间的左端点严格大于 r ，就表示该组能够容纳当前区间</li>
<li>既然是存在性问题，则我们只需要让新区间的左端点 &gt; 各个分组中 r
的最小值即可</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Range &amp;e) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; e.l;	<span class="comment">//依据区间左端点，从小到大进行排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;ranges[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        ranges[i] = &#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(ranges, ranges + n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//小根堆存储每个分组的最大右端点</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; heap;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> e = ranges[i];</span><br><span class="line">        <span class="comment">//当堆为空时 或者 新区间与分组中的任何一个区间都有交集的时候(连最有可能容纳它的分组都没办法容纳它)，则需要为其新开辟一个分组</span></span><br><span class="line">        <span class="comment">//heap中存储的是每个分组的最大右端点，top()中存的就是这些右端点中的最小值，其为开辟新分组的临界条件</span></span><br><span class="line">        <span class="keyword">if</span>(heap.<span class="built_in">empty</span>() || e.l &lt;= heap.<span class="built_in">top</span>()) heap.<span class="built_in">push</span>(e.r);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//该区间的左端点与分组右边界无交点，则表示可以加入该分组</span></span><br><span class="line">            <span class="comment">//由于事先对每个区间的左端点进行了排序，所以后来的r一定大于分组的右边界，因为左边界都比它大了</span></span><br><span class="line">            heap.<span class="built_in">pop</span>();</span><br><span class="line">            heap.<span class="built_in">push</span>(e.r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//heap中有几个元素就有几个分组</span></span><br><span class="line">    cout &lt;&lt; heap.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="区间覆盖">区间覆盖</h5>
<p><strong>题目</strong></p>
<ul>
<li>给定 N 个闭区间 [ai,bi] 以及一个线段区间
[s,t]，请你选择尽量少的区间，将指定线段区间完全覆盖。输出最少区间数，如果无法完全覆盖则输出
−1。</li>
</ul>
<p><strong>贪心思路</strong></p>
<ul>
<li>首先对区间按照左端点从小到大进行排序，对于线段区间的开头
st，我们先在各个区间中找到所有左端点小于等于 st
的区间，再计算他们中的最大右端点 max_r，当 max_r 小于 st
时，则表示无法覆盖；当 max_r 大于 ed
时，则表示可以完成覆盖，每次找完所有左端点小于等于 st 的区间后计数结果
+1，st 更新为 max_r</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Range &amp;e) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; e.l;		<span class="comment">//按照左端点从小到大进行排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;ranges[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> st, ed;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;st, &amp;ed);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        ranges[i] = &#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(ranges, ranges + n);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;	<span class="comment">//判断是否能覆盖</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = i, mr = <span class="number">-2e9</span>;	<span class="comment">//双指针算法</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt; n &amp;&amp; ranges[j].l &lt;= st)</span><br><span class="line">        &#123;</span><br><span class="line">            mr = <span class="built_in">max</span>(mr, ranges[j].r);	<span class="comment">//找到max_r</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mr &lt; st)		<span class="comment">//max_r &lt; st说明无法完成覆盖</span></span><br><span class="line">        &#123;</span><br><span class="line">            res = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res++;	<span class="comment">//找完max_r后计数+1</span></span><br><span class="line">        <span class="keyword">if</span>(mr &gt;= ed)	<span class="comment">//max_r &gt;= ed 则已经完成覆盖，提前结束</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i = j - <span class="number">1</span>;	<span class="comment">//由于j++，因此i = j - 1</span></span><br><span class="line">        st = mr;	<span class="comment">//用max_r更新st</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) res = <span class="number">-1</span>; <span class="comment">//特判</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="huffman树">Huffman树</h4>
<h5 id="合并果子">合并果子</h5>
<p><strong>题目</strong></p>
<ul>
<li>在一个果园里，达达已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。达达决定把所有的果子合成一堆。每一次合并，达达可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过
n−1
次合并之后，就只剩下一堆了。达达在合并果子时总共消耗的体力等于每次合并所耗体力之和。因为还要花大力气把这些果子搬回家，所以达达在合并果子时要尽可能地节省体力。假定每个果子重量都为
1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使达达耗费的体力最少，并输出这个最小的体力耗费值。</li>
</ul>
<p><strong>贪心思路</strong></p>
<ul>
<li>只要保证我们每一次合并的代价最小，则合并到最后我们所付出的总代价一定是最小的</li>
<li>由于每个果子重量都是1，则我们每次只需挑重量最小的两堆进行合并即可</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//需要每次都排序，可以采用优先队列——来存储每一堆的重量，在插入时就会默认排好序了</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; heap;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        heap.<span class="built_in">push</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//n堆果子只需要n-1此合并操作就能合并成一堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> f = heap.<span class="built_in">top</span>(); heap.<span class="built_in">pop</span>();	<span class="comment">//重量最小的一堆，取出后删除</span></span><br><span class="line">        <span class="type">int</span> s = heap.<span class="built_in">top</span>(); heap.<span class="built_in">pop</span>();	<span class="comment">//重量第二小的一堆，取出后删除</span></span><br><span class="line">        res += f + s;	<span class="comment">//结果加上最轻两堆的重量之和</span></span><br><span class="line">        heap.<span class="built_in">push</span>(f + s);	<span class="comment">//再将合并之后的新果子堆插入堆heap中</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="排序不等式">排序不等式</h4>
<h5 id="排队打水">排队打水</h5>
<p><strong>题目</strong></p>
<ul>
<li>有 n 个人排队到 1 个水龙头处打水，第 i 个人装满水桶所需的时间是 t
<sub>i</sub>，请问如何安排他们的打水顺序才能使所有人的等待时间之和最小？</li>
</ul>
<p><strong>贪心思路</strong></p>
<ul>
<li>假设当 t
是按照从大到小开始安排打水，则对于任意两个人，交换其打水顺序，交换后均能减少等待总时间</li>
<li>因此，按照 t 从小到大安排打水，能使最终的等待时间之和最小</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t[i]);</span><br><span class="line">    <span class="built_in">sort</span>(t + <span class="number">1</span>, t + n + <span class="number">1</span>);		<span class="comment">//由于下标从1开始，相比于sort(t, t + n) 起始位置与终点位置都要+1</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;		<span class="comment">//结果可能很大，必须用long long来存</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res += t[i] * (n - i);	<span class="comment">//计算总等待时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="绝对值不等式">绝对值不等式</h4>
<h5 id="货仓选址">货仓选址</h5>
<p><strong>题目</strong></p>
<ul>
<li>在一条数轴上有 N 家商店，它们的坐标分别为
A1∼AN。现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。</li>
</ul>
<p><strong>贪心思路</strong></p>
<ul>
<li><p>不妨设货仓地址为 x，f (x) 为距离之和</p></li>
<li><p>则有<span
class="math inline">\(f(x)=|x-x_1|+|x-x_2|+|x-x_3|+\dots+|x-x_n|\)</span></p></li>
<li><p>​ <span
class="math inline">\(f(x)=(|x-x_1|+|x-x_n|)+(|x-x_2|+|x-x_{n-1}|)+\dots\)</span></p></li>
<li><p>当<span class="math inline">\(f(x)\)</span>想要取得最小值时，x 到
x<sub>n</sub> 与 x<sub>1</sub> 的距离之和要取得最小值，x 到
x<sub>n-1</sub> 与 x<sub>2</sub>
的距离之和要取得最小值，依次类推</p></li>
<li><p>两点之间距离之和最短，当x位于两点之间即成立</p></li>
<li><p>当n为偶数时，恰好可以两两配对，x 下标取 n / 2 符合条件</p></li>
<li><p>当n为奇数时，会多出一个中间的点，x 下标取 n /
2也符合条件，综上，x 下标取 n / 2符合题意</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);	<span class="comment">//读入每一个点</span></span><br><span class="line">    <span class="built_in">sort</span>(a, a + n);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, x = n / <span class="number">2</span>;		<span class="comment">//x的下标取n/2符合题意</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res += <span class="built_in">abs</span>(a[x] - a[i]);	<span class="comment">//取绝对值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);	<span class="comment">//输出最短距离</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="推公式">推公式</h4>
<h5 id="耍杂技的牛">耍杂技的牛</h5>
<p><strong>题目</strong></p>
<ul>
<li>农民约翰的 N 头奶牛（编号为
1..N）计划逃跑并加入马戏团，为此它们决定练习表演杂技。奶牛们不是非常有创意，只提出了一个杂技表演：叠罗汉，表演时，奶牛们站在彼此的身上，形成一个高高的垂直堆叠。奶牛们正在试图找到自己在这个堆叠中应该所处的位置顺序。这
N 头奶牛中的每一头都有着自己的重量 W<sub>i</sub> 以及自己的强壮程度
S<sub>i</sub>。一头牛支撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。您的任务是确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。</li>
</ul>
<p><strong>贪心思路</strong></p>
<ul>
<li><table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">交换前的风险值</th>
<th style="text-align: center;">交换后风险值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">第 i 头牛</td>
<td style="text-align: center;">w(1~ i-1) - si</td>
<td style="text-align: center;">w(1~i - 1) + w(i+1) - si</td>
</tr>
<tr class="even">
<td style="text-align: center;">第 i + 1 头牛</td>
<td style="text-align: center;">w(1~i) - s(i+1)</td>
<td style="text-align: center;">w(1~ i-1) - s(i+1)</td>
</tr>
</tbody>
</table></li>
<li><p>由表可知，当 w(1~i - 1) + w(i+1) - si &lt; w(1~i) - s(i+1)
时，交换第 i 头和第 i +
1头牛是有效交换的(交换后的奶牛风险最大值减小)</p></li>
<li><p>即 w(i + 1) + s(i+1) &lt; w(i) + s(i)
时，交换是有效的，所以当我们按照 w + s
从小到大排序就是一组最优解</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;	</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">PII cows[N];	<span class="comment">//pair数组存储每一头牛</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> w, s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;w, &amp;s);</span><br><span class="line">        cows[i] = &#123;w + s, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(cows, cows + n);	<span class="comment">//按照w+s从小到大进行排序</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, res = <span class="number">-2e9</span>;	<span class="comment">//sum记录肩膀上所有牛的重量，res表示最大风险值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> w = cows[i].second, s = cows[i].first - w;</span><br><span class="line">        res = <span class="built_in">max</span>(res, sum - s);	<span class="comment">//sum - s表示当前牛的风险值</span></span><br><span class="line">        sum += w;	<span class="comment">//更新sum的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
</search>
