<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/red-32x32.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/red-16x16.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"在这里输入你要搜索的内容","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="单链表、双链表、栈、队列、单调栈和单调队列、kmp算法、Trie树、合并集合、堆、哈希表、树状数组和线段树">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="http://example.com/posts/79666db/index.html">
<meta property="og:site_name" content="Alcatraz Island">
<meta property="og:description" content="单链表、双链表、栈、队列、单调栈和单调队列、kmp算法、Trie树、合并集合、堆、哈希表、树状数组和线段树">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84.png">
<meta property="og:image" content="http://example.com/images/%E7%BA%BF%E6%AE%B5%E6%A0%91.png">
<meta property="article:published_time" content="2023-11-05T14:07:16.000Z">
<meta property="article:modified_time" content="2023-11-30T03:31:51.112Z">
<meta property="article:author" content="sabersnt">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84.png">


<link rel="canonical" href="http://example.com/posts/79666db/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/posts/79666db/","path":"posts/79666db/","title":"数据结构"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>数据结构 | Alcatraz Island</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Alcatraz Island</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="在这里输入你要搜索的内容" spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-text">单链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="nav-text">双链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88"><span class="nav-text">栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-text">队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="nav-text">单调栈和单调队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#kmp%E7%AE%97%E6%B3%95"><span class="nav-text">kmp算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#trie%E6%A0%91"><span class="nav-text">Trie树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E9%9B%86%E5%90%88"><span class="nav-text">合并集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86"><span class="nav-text">堆</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E6%B1%82%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-text">无序数组求中位数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-text">哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E6%95%A3%E5%88%97%E8%A1%A8"><span class="nav-text">模拟散列表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C"><span class="nav-text">字符串哈希</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="nav-text">树状数组和线段树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="nav-text">树状数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="nav-text">线段树</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="sabersnt"
      src="/images/ygyt.png">
  <p class="site-author-name" itemprop="name">sabersnt</p>
  <div class="site-description" itemprop="description">莫听穿林打叶声，何妨吟啸且徐行</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/79666db/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ygyt.png">
      <meta itemprop="name" content="sabersnt">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alcatraz Island">
      <meta itemprop="description" content="莫听穿林打叶声，何妨吟啸且徐行">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="数据结构 | Alcatraz Island">
      <meta itemprop="description" content="单链表、双链表、栈、队列、单调栈和单调队列、kmp算法、Trie树、合并集合、堆、哈希表、树状数组和线段树">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-05 22:07:16" itemprop="dateCreated datePublished" datetime="2023-11-05T22:07:16+08:00">2023-11-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-30 11:31:51" itemprop="dateModified" datetime="2023-11-30T11:31:51+08:00">2023-11-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">单链表、双链表、栈、队列、单调栈和单调队列、kmp算法、Trie树、合并集合、堆、哈希表、树状数组和线段树</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h4 id="单链表">单链表</h4>
<p><strong>实现方式</strong></p>
<ul>
<li>利用数组实现静态链表</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>与结构体+指针的实现方式相比，使用数组实现速度更快，效率更高（new一个节点的过程太慢）</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;		<span class="comment">//根据题目的数据范围制定数组边界</span></span><br><span class="line"><span class="type">int</span> head, idx;		<span class="comment">//head为头指针，idx为可用的数组下标索引值</span></span><br><span class="line"><span class="type">int</span> e[N], ne[N];	<span class="comment">//e[]用来存放节点的数据，ne[]用来存放下一个节点的索引值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>, idx = <span class="number">0</span>;		<span class="comment">//head类似指针，一开始指向空(-1的位置) idx为0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">head_insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;		<span class="comment">//先赋值到数组中</span></span><br><span class="line">    ne[idx] = head;	<span class="comment">//&quot;插入元素&quot;的下一个元素为头节点指向的位置（头插法）</span></span><br><span class="line">    head = idx;		<span class="comment">//head指向插入的元素</span></span><br><span class="line">    idx ++;			<span class="comment">//数组可用索引值向前移1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据插入指定位置的下一个位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">k_insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;		<span class="comment">//将数据存入数组中</span></span><br><span class="line">    ne[idx] = ne[k];<span class="comment">//数据指向k位置的下一个元素</span></span><br><span class="line">    ne[k] = idx;	<span class="comment">//k位置指向数据位置</span></span><br><span class="line">    idx ++;			<span class="comment">//索引值前移</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除指定位置上的数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="双链表">双链表</h4>
<p><strong>实现方式</strong></p>
<ul>
<li>利用 数组l[]、r[] 分别表示任意节点的上一个节点和下一个节点</li>
<li>规定，0 和 1 分别表示左边界和右边界，因此 idx 从 2 开始取</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span>		<span class="comment">//初始化操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[<span class="number">1</span>] = <span class="number">0</span>;	<span class="comment">//起始链表中无数据，0 和 1 位置是相邻的</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    idx = <span class="number">2</span>;	<span class="comment">//idx必须从2开始取</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span>	<span class="comment">//插入节点，规定从k下标的右边插入节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//理清楚操作顺序</span></span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = k;		<span class="comment">//idx的上一个节点位置为k</span></span><br><span class="line">    r[idx] = r[k];	<span class="comment">//idx的下一个节点位置为原来k位置的下一个节点</span></span><br><span class="line">    l[r[k]] = idx;	<span class="comment">//原k位置下一个节点的上一个节点位置为idx</span></span><br><span class="line">    r[k] = idx;		<span class="comment">//k位置的节点的下一个节点位置为idx</span></span><br><span class="line">    idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> k)</span>		<span class="comment">//删除k位置上的节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[l[k]] = r[k];	<span class="comment">//k位置的上一个节点指向k位置的下一个节点	</span></span><br><span class="line">    l[r[k]] = l[k];	<span class="comment">//k位置的下一个节点指向k位置的上一个节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双链表的遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = r[<span class="number">0</span>]; i != <span class="number">1</span>; i = r[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//r[0]表示 0位置的下一个节点，从其开始遍历；当r[i] = 1 时表示其到达了右边界</span></span><br></pre></td></tr></table></figure>
<h4 id="栈">栈</h4>
<p><strong>实现</strong></p>
<ul>
<li>用数据模拟栈的结构</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> stk[N], tt;</span><br><span class="line"><span class="comment">//进栈</span></span><br><span class="line">stk[++tt] = x;</span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line">tt--;</span><br><span class="line"><span class="comment">//获取栈顶元素</span></span><br><span class="line">stk[tt];</span><br><span class="line"><span class="comment">// 判断栈是否为空，如果 tt &gt; 0，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (tt &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>例题</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入一个算术表达式(只包含加减乘除运算) 输出其结果	样例：(2+2)*(1+1)  8</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="comment">/*思路，两个栈，一个栈用来存储数字，一个用来存储运算符号*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据实际运算符优先级制定运算顺序</span></span><br><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; cmp = &#123; &#123;<span class="string">&#x27;+&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;-&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;/&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;*&#x27;</span>, <span class="number">2</span>&#125; &#125;;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; num;		<span class="comment">//存储数字</span></span><br><span class="line">stack&lt;<span class="type">char</span>&gt; op;		<span class="comment">//存储运算符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟运算过程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> x = num.<span class="built_in">top</span>(); num.<span class="built_in">pop</span>();	<span class="comment">//取出后进的一个数并出栈</span></span><br><span class="line">    <span class="type">int</span> y = num.<span class="built_in">top</span>(); num.<span class="built_in">pop</span>();	<span class="comment">//取出先进的一个数并出栈</span></span><br><span class="line">    <span class="type">char</span> c = op.<span class="built_in">top</span>(); op.<span class="built_in">pop</span>();	<span class="comment">//取出运算符号</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;	<span class="comment">//表示结果</span></span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span>) res = y + x;	<span class="comment">//注意一下所有运算顺序都是先y后x，因为y先进栈</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) res = y - x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;*&#x27;</span>) res = y * x;</span><br><span class="line">    <span class="keyword">else</span> res = y / x;</span><br><span class="line">    num.<span class="built_in">push</span>(res);	<span class="comment">//将最后的结果更新至数字栈中，方便下一次的eval()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    <span class="comment">//一下都是模板代码，需要加入新的操作时只需要将新运算符的优先级加到cmp中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> c = str[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = i, x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; str.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(str[j]))	<span class="comment">//读取到下一个字符不为数字为止</span></span><br><span class="line">            &#123;</span><br><span class="line">                x = x * <span class="number">10</span> + (str[j++] - <span class="string">&#x27;0&#x27;</span>);		<span class="comment">//将字符变为十进制数字</span></span><br><span class="line">            &#125;</span><br><span class="line">            num.<span class="built_in">push</span>(x);</span><br><span class="line">            i = j - <span class="number">1</span>;	<span class="comment">//i需要从j-1的位置开始读</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>) op.<span class="built_in">push</span>(c);	<span class="comment">//如果为左括号，直接插入符号栈</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当待插入的符号为右括号时，则必定有左括号，所以必须先进行括号中的运算</span></span><br><span class="line">            <span class="keyword">while</span>(op.<span class="built_in">size</span>() &amp;&amp; op.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>) <span class="built_in">eval</span>();	</span><br><span class="line">            op.<span class="built_in">pop</span>();	<span class="comment">//左括号出栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//加减乘除的情况</span></span><br><span class="line">            <span class="comment">//当符号栈中有符号时并且待入栈的优先级小于栈顶符号时，需要先进行优先级大的运算</span></span><br><span class="line">            <span class="comment">//使用op.size()的目的是排除栈空的情况</span></span><br><span class="line">            <span class="keyword">while</span>(op.<span class="built_in">size</span>() &amp;&amp; cmp[c] &lt;= cmp[op.<span class="built_in">top</span>()]) <span class="built_in">eval</span>();</span><br><span class="line">            op.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最终符号栈中仍是有运算符的，还需要对其计算</span></span><br><span class="line">    <span class="keyword">while</span>(op.<span class="built_in">size</span>()) <span class="built_in">eval</span>();</span><br><span class="line">    cout &lt;&lt; num.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="队列">队列</h4>
<p><strong>实现</strong></p>
<ul>
<li>数组实现</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> que[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//进队列</span></span><br><span class="line">que[++tt] = x;</span><br><span class="line"><span class="comment">//出队列</span></span><br><span class="line">hh++;</span><br><span class="line"><span class="comment">//获取队头元素</span></span><br><span class="line">que[hh];</span><br><span class="line"><span class="comment">//判空，若hh小于tt，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span>(hh &lt;= tt)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单调栈和单调队列">单调栈和单调队列</h4>
<p><strong>定义</strong></p>
<ul>
<li>栈或队列中元素呈单调性</li>
</ul>
<p><strong>解题思路</strong></p>
<ul>
<li>先使用暴力方法计算</li>
<li>再从中挖掘性质，看其是否有单调的性质</li>
<li>最后使用单调栈或单调队列进行优化：O(n<sup>2</sup>) 优化至O(n)</li>
</ul>
<p><strong>单调栈使用场景</strong></p>
<ol type="1">
<li>寻找一个数左边第一个小于它的数或下标</li>
<li>寻找一个数右边第一个大于它的数或下标（与场景1的操作相似，不过对于数组是逆序遍历）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//题目：求无序数组中每一个数的左边第一个小于它的数（若有序，则用二分来做）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N], tt;	<span class="comment">//q[]模拟栈，tt表示栈顶元素下标，当然也可以用STL中的stack</span></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//若栈顶元素比当前元素k大，则后面的数中的左边第一个小于它的数一定是k，所以可以将栈中所有大于</span></span><br><span class="line">        <span class="comment">//等于k的元素删除</span></span><br><span class="line">        <span class="keyword">while</span>(tt &amp;&amp; q[tt] &gt;= a[i]) tt--;</span><br><span class="line">        <span class="keyword">if</span>(tt == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="number">-1</span>);	<span class="comment">//若不存在，则输出-1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[tt]);  <span class="comment">//栈顶元素就是答案</span></span><br><span class="line">        q[++tt] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>单调队列例题</strong></p>
<p><strong>滑动窗口</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N], q[N], n, k;	<span class="comment">//q[N]用来存储数组元素下标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;	<span class="comment">//队列的初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)	<span class="comment">//输出窗口中的最小元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + <span class="number">1</span>) hh++; <span class="comment">//如果队列头对应的下标小于窗口的最左下标，则需将头指针hh前移动</span></span><br><span class="line">        										<span class="comment">//即删除队头元素</span></span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--;<span class="comment">//当队尾元素大于等于待插入元素时，需要将原队尾元素删除	</span></span><br><span class="line">        q[++tt] = i;	<span class="comment">//将下标插入队列          //hh &lt;= tt 表示的是队列不为空</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);	<span class="comment">//特判，窗口还未形成(i &lt; k - 1)无需输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);	<span class="comment">//换行</span></span><br><span class="line">    </span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;	<span class="comment">//重新初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)	<span class="comment">//输出窗口中的最大元素，只修改一处</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + <span class="number">1</span>) hh++;</span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--;	<span class="comment">//由于需要降序排列，所以是队尾元素小于等于待插入的元素</span></span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="kmp算法">kmp算法</h4>
<p><strong>起源</strong></p>
<ul>
<li>针对于字符串的匹配优化的算法</li>
</ul>
<p><strong>题目</strong></p>
<ul>
<li>给定一个字符串 S，以及一个模式串
P，所有字符串中只包含大小写英文字母以及阿拉伯数字。模式串 P 在字符串 S
中多次作为子串出现。求出模式串 P 在字符串 S
中所有出现的位置的起始下标</li>
</ul>
<p><strong>暴力解法</strong></p>
<ul>
<li>从头开始遍历匹配，若遇到不匹配的字符，则从字符串S的下一个位置开始进行比较（自字符串向后移动一位）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; n &amp;&amp; j &lt; m)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i] == p[j])</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        i = i - j + <span class="number">1</span>;	<span class="comment">//i,j均为下标，此时已经进行匹配的长度为 j+1 (因为字符串下标从0开始)</span></span><br><span class="line">        j = <span class="number">0</span>;		<span class="comment">//i需要指向起始匹配位置的下一个位置，下标为(i下标 - 长度 + 1) + 1 = [(i) - (j + 1) + 1]</span></span><br><span class="line">    &#125;				<span class="comment">//下标减长度加1就是原来位置的下标，最后加上1就是进行下一次匹配的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化</strong></p>
<ul>
<li>原来的算法只将字符串p往后一位，意味着有很多之前已经匹配过的字符，效率很低，如果能将s的指针不回退，而只让s的指针一直往前走，就可以提高执行的效率</li>
</ul>
<p><strong>代码模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将整个匹配过程分为两部分，先求p字符串的ne数组</span></span><br><span class="line"><span class="comment">//1.求ne数组</span></span><br><span class="line"><span class="comment">//n为p串长度，m为s串长度</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i++)	<span class="comment">//根据ne数组的特性，ne[1]为0，无需计算，故i初始化为2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; p[i] != p[j+<span class="number">1</span>]) j = ne[j];	<span class="comment">//递归的一种做法，假设已经求出ne数组</span></span><br><span class="line">    <span class="keyword">if</span>(p[i] == p[j+<span class="number">1</span>]) j++;</span><br><span class="line">    ne[i] = j;		<span class="comment">//执行到此，说明已满足前缀匹配后缀</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.匹配过程，两个串的下标都是从1开始，所以i初始化为1，而将i与j+1比，故将j初始化为0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span>(s[i] == p[j+<span class="number">1</span>]) j++;	<span class="comment">//如果两串元素相同，则将j移动至下一位，i在循环结束后会自动++</span></span><br><span class="line">    <span class="keyword">if</span>(j == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i - n);	<span class="comment">//匹配成功后的逻辑，此题求的是每一次匹配的位置</span></span><br><span class="line">        j = ne[j];	<span class="comment">//进行下一次的匹配</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="trie树">Trie树</h4>
<p><strong>使用场景</strong></p>
<ul>
<li>字符串存储、统计，所以又称作字典树</li>
</ul>
<p><strong>代码模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span>	<span class="comment">//str为待插入的字符串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;	<span class="comment">//根节点起始为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;	<span class="comment">//将a~z映射成[0,25]</span></span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u] = ++idx;	<span class="comment">//如果p节点没有u这个子节点，则为其创建子节点，并标号为++idx</span></span><br><span class="line">        									<span class="comment">//注意这里不能改为idx++，因为idx初始为0，根节点也为0，不能与根节点一致</span></span><br><span class="line">        p = son[p][u];	<span class="comment">//p指向子节点u</span></span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;	<span class="comment">//此时字符串已经存储完毕，需要将最后一个字符做个标记，便于以后的统计字符串的个数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> str[])</span>	<span class="comment">//返回str在树中出现的次数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;	<span class="comment">//根节点起始为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;	<span class="comment">//将a~z映射成[0,25]</span></span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">//如果p节点没有u这个子节点，则为直接返回0</span></span><br><span class="line">        p = son[p][u];	<span class="comment">////p指向子节点u</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];	<span class="comment">//此时字符串已经到达最后一个节点，由此可以判断其一共出现了多少次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>例题</strong></p>
<ul>
<li>在给定的 N 个整数 A1，A2 .... An中选出两个进行
xor（异或）运算，得到的结果最大是多少</li>
<li>其中 0 &lt; N &lt; 100000, 0 &lt;= A &lt;= 2<sup>31</sup></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">31</span> * N;	<span class="comment">//N表示一共有多少个数字，每个数字最多可能有31位，M表示所有数组位数的最大可能</span></span><br><span class="line"><span class="type">int</span> son[M][<span class="number">2</span>], idx, arr[N];		<span class="comment">//因此需要开辟M个节点，每个节点最多能有2个子节点分别为0和1</span></span><br><span class="line">								<span class="comment">//arr[]存放真实的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span>	<span class="comment">//创建字典树的过程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)	<span class="comment">//最多31位，为什么从第30位开始？ 最高位位符号位，此题规定都为正数，无需考虑</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;		<span class="comment">//获取数字x的二进制位中的第i位，参考之前的模板 “x在二进制中的第k位数”</span></span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u] = ++idx;	<span class="comment">//如果没有此子节点，则为其创建</span></span><br><span class="line">        p = son[p][u];		<span class="comment">//p指向该节点的子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> x)</span>	<span class="comment">//从数字x开始，寻找异或运算可能的最大值：从最高位开始找，两个位不相同时，才有可能使得异或结果最大</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)	<span class="comment">//等价于for(int i = 30; i &gt;= 0; i--)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;		<span class="comment">//获取数字x的二进制位中的第i位 (从最高位开始)</span></span><br><span class="line">        <span class="keyword">if</span>(son[p][!u])			<span class="comment">//如果存在!u的子节点，则说明，两个位不同，p指向该子节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            res = res + (<span class="number">1</span> &lt;&lt; i);	<span class="comment">//!u存在，则说明异或结果为1，因为从最高位开始计算，所以需要将其左移i位</span></span><br><span class="line">            						<span class="comment">//左移i位再相加，相当于把每一位异或(二进制)的结果相加</span></span><br><span class="line">            p = son[p][!u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;						<span class="comment">//如果不存在!u的子节点，则说明两个位相同，p指向该u子节点</span></span><br><span class="line">            res = res + (<span class="number">0</span> &lt;&lt; i);</span><br><span class="line">            p = son[p][u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">        <span class="built_in">insert</span>(arr[i]);	<span class="comment">//读取数组，并且创建字典树</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) res = <span class="built_in">max</span>(res, <span class="built_in">search</span>(arr[i]));	<span class="comment">//模拟随机挑选两个数进行异或的过程</span></span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="合并集合">合并集合</h4>
<p><strong>使用场景</strong></p>
<ul>
<li>多次对多个集合进行合并或判断两个数是否在同一个集合中</li>
</ul>
<p><strong>代码模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[N];	<span class="comment">//p数组存放的是某一节点的父节点的位置 例，p[2] = 3, 表示2的父节点的位置为3</span></span><br><span class="line">			<span class="comment">//使用根节点来区别不同的集合，规定：根节点的父节点为它本身，即p[根节点] = 根节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;										 <span class="comment">//当x的父节点不是根节点时，再从其父节点往上走</span></span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]); <span class="comment">//递归调用find函数，当找到其根节点时，x的所有父节点的父节点都指向了根节点，压缩了线路</span></span><br><span class="line">    <span class="keyword">return</span> p[x];					 <span class="comment">//因此，下一次查询的时候可以更快地找到相应集合的根节点</span></span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> 	<span class="comment">//将a, b两个数所在的集合合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);	<span class="comment">//a的根节点指向b的根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>例题</strong></p>
<ul>
<li>食物链 题号240</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//思路，未确定关系之前，每一个动物都在独立的一个集合中，当确定关系后，将所有动物存放在同一颗树中，因为食物链构成了一个环形，所以根据其中两个动物的之间的关系，能推出第三个动物关系，例如：A吃B，B吃C 能推出 C吃A 此时，我们就可以通过各个动物与根节点之间的关系来推断各个动物之间的关系：如果动物到根节点的距离模3相等，则表示为同类动物；如果模3相差1则为捕食关系。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N], d[N];	<span class="comment">//p[x] 表示x的父节点；d[x]表示x到其父节点的距离</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>	<span class="comment">//寻找x的根节点，并压缩路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">find</span>(p[x]);	<span class="comment">//暂存根节点，否则下面的p[x]会受到影响</span></span><br><span class="line">        d[x] += d[p[x]];	<span class="comment">//更新路径，使d[x]直接为其到根节点的距离</span></span><br><span class="line">        p[x] = t;	<span class="comment">//p[x]指向根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];	<span class="comment">//返回x的根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;	<span class="comment">//初始化：所有x的根节点都是其本身</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;t, &amp;x, &amp;y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &gt; n || y &gt; n) res ++ ;	<span class="comment">//题目判断为假的条件</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> px = <span class="built_in">find</span>(x), py = <span class="built_in">find</span>(y);		<span class="comment">//先记录x,y的根节点，防止在里面递归调用（因为有距离的累加）</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="number">1</span>)	<span class="comment">//t == 1, 表示关于同类的描述</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (px == py &amp;&amp; (d[x] - d[y]) % <span class="number">3</span>) res ++ ;	<span class="comment">//x,y在同一颗树上，且d[x] % 3 != d[y] % 3</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (px != py)	<span class="comment">//x,y不在同一颗树上，此时需要建立x,y的同类关系</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p[px] = py;		<span class="comment">//两个集合合并</span></span><br><span class="line">                    d[px] = d[y] - d[x];	<span class="comment">//为x的根节点的父节点到y的根节点赋上一个距离，其满足(d[x] + d[px]) % 3</span></span><br><span class="line">                    						<span class="comment">// == d[y] % 3, 表示同类</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;		</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//x,y在同一棵树上且为同类时，此话为假</span></span><br><span class="line">                <span class="keyword">if</span> (px == py &amp;&amp; (d[x] - d[y] - <span class="number">1</span>) % <span class="number">3</span>) res ++ ;	</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (px != py)	<span class="comment">//x,y不在同一颗树上，此时需要建立x,y的捕食关系</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p[px] = py;		<span class="comment">//两个集合合并</span></span><br><span class="line">                    d[px] = d[y] + <span class="number">1</span> - d[x];</span><br><span class="line">             <span class="comment">//为x的根节点的父节点到y的根节点赋上一个距离，其满足(d[x] + d[px]) % 3 - 1== d[y] % 3，表示x吃y</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">记录思考时遇到的问题:</span></span><br><span class="line"><span class="comment">1.d数组初始化全为0，是如何实现赋值的？ 在后文，当两个节点不在同一颗树中时，其就为两个节点建立关系，并为d数组赋值</span></span><br><span class="line"><span class="comment">2.为什么d数组存放的不是实际到根节点-的距离，而且可能会出现负数的情况?</span></span><br><span class="line"><span class="comment">  建立关系时需要d[px]需要满足的是(d[x] + d[px]) % 3 == d[y] % 3 (以建立同类关系为例，捕食关系同理)</span></span><br><span class="line"><span class="comment">  等价于(d[x]%3 + d[px])%3 - (d[y]%3) == 0 等价于 (d[x]%3 + d[px])%3 - (d[y]%3)%3 == 0</span></span><br><span class="line"><span class="comment">  等价于(d[x] + d[px] - d[y])%3 == 0 由此推出 d[x] + d[px] - d[y] = k * 3, k取整数</span></span><br><span class="line"><span class="comment">  令 k=0 可得 d[x] + d[px] - d[y] = 0; 也正因为令k等于0，所以d数组中才可能有负数  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="堆">堆</h4>
<p><strong>本质</strong></p>
<ul>
<li>一个完全二叉树：从根节点开始，除了最后一层节点，其他节点都是存在的（即当前层存满了节点才会往下存）</li>
</ul>
<p><strong>堆排序</strong></p>
<ul>
<li>小顶堆：使列表数据从小到大排序</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> h[N], n, m, cnt;	<span class="comment">//h数组用于模拟堆结构,cnt表示当前堆中节点的个数以及最后一个节点的下标            </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = x;</span><br><span class="line">    <span class="comment">//用两个if来找到(x，x的左儿子，x的右儿子)中的最小值，t表示当前最小值得下标</span></span><br><span class="line">    <span class="comment">//其中所有下标不得超过当前堆的元素个数即cnt</span></span><br><span class="line">    <span class="keyword">if</span>(x * <span class="number">2</span> &lt;= cnt &amp;&amp; h[x * <span class="number">2</span>] &lt; h[t]) t = x * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[x * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x != t)	<span class="comment">//说明父节点在三者之中不是最小的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当前t表示最小值的下标，若找到，则需要将其上的数与父节点(x)交换</span></span><br><span class="line">        <span class="built_in">swap</span>(h[x], h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);	<span class="comment">//交换完后,t位置上的节点可能不满足小于其所有子节点,需要递归向下进行排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);	<span class="comment">//读取数据</span></span><br><span class="line">    cnt = n;	<span class="comment">//必须先更新堆中元素的个数再进行down</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从最后一个有子节点的节点进行down操作</span></span><br><span class="line">    <span class="comment">//为什么是从 n/2 开始：因为规定在堆中若h[x]为父节点,则h[2x]为左儿子，h[2x+1]为右儿子，n/2满足最后一个有子节点的父节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n / <span class="number">2</span>; i ; i--) <span class="built_in">down</span>(i);</span><br><span class="line">    	</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, h[<span class="number">1</span>]);	<span class="comment">//每次输出跟节点元素</span></span><br><span class="line">        h[<span class="number">1</span>] = h[cnt--];	<span class="comment">//然后将堆中最后一个元素赋给堆根节点</span></span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>);	<span class="comment">//新的根节点可能不满足小于其所有子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>模拟堆</strong></p>
<ul>
<li>堆的增查删改操作：这些操作都是基于核心操作实现：down，up操作实现的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> h[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将x位置上的元素向下移动</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = x;</span><br><span class="line">    <span class="keyword">if</span>(x * <span class="number">2</span> &lt;= cnt &amp;&amp; h[x * <span class="number">2</span>] &lt; h[t]) t = x * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[x * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(t != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[x], h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将x位置上的元素向上移动</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x / <span class="number">2</span> &amp;&amp; h[x] &lt; h[x / <span class="number">2</span>])	<span class="comment">//h[x/2]表示的是其父节点，若子节点更小，则移到父节点上去</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[x / <span class="number">2</span>], h[x]);</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;	<span class="comment">//使用位运算实现除以2效率更高</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    h[++cnt] = x;</span><br><span class="line">    <span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除指定位置元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(h[x], h[idx]);	<span class="comment">//交换指定元素与最后一个元素，在让其idx--，使得最后一个元素永久消失</span></span><br><span class="line">    idx--;</span><br><span class="line">    <span class="built_in">down</span>(x);	<span class="comment">//down()和up()只会执行其中的一个，因为其最终目的都是实现小根堆</span></span><br><span class="line">    <span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改指定位置元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    h[x] = v;	<span class="comment">//修改完后不一定满足小根堆，要么up要么down</span></span><br><span class="line">    <span class="built_in">down</span>(x);	<span class="comment">//down()和up()只会执行其中的一个</span></span><br><span class="line">    <span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="无序数组求中位数">无序数组求中位数</h5>
<ol type="1">
<li>对于一个无序数组，如何快速求得每个子数组的中位数呢</li>
<li>维护两个堆，一个是大根堆一个是小根堆，大根堆放中位数左边的数，小根堆放中位数右边的数，这样两个堆的堆顶就是中位数的相邻元素</li>
<li>每次插入数x，若x大于大根堆的堆顶，则插入小根堆中；否则插入大根堆中</li>
<li>插入结束后，需要保证两个堆的元素数量之差不大于1，若大于一，则将较多元素的堆顶移到较少元素的堆顶</li>
<li>维护结束后，元素较多的堆顶就是当前子数组的中位数；如果元素数量相同，则取两堆顶元素的和的一半</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, x;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q1;	 <span class="comment">//c++优先队列默认大根堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q2;  <span class="comment">//手动定义小根堆</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">    q1.<span class="built_in">push</span>(x);	 <span class="comment">//第一个数加入大根堆</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="comment">//如果待插入值大于大根堆的堆顶，则放入小根堆中；否则放入大根堆中</span></span><br><span class="line">        <span class="keyword">if</span>(x &gt; q1.<span class="built_in">top</span>()) q2.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">else</span> q1.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="comment">//记得强转一下size，否则可能报错</span></span><br><span class="line">        <span class="comment">//维护两个堆的元素个数的差值小于1：将元素较多的堆的堆顶放入元素较少的堆顶即可</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">abs</span>((<span class="type">int</span>)q1.<span class="built_in">size</span>() - (<span class="type">int</span>)q2.<span class="built_in">size</span>()) &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q1.<span class="built_in">size</span>() &gt; q2.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                q2.<span class="built_in">push</span>(q1.<span class="built_in">top</span>());</span><br><span class="line">                q1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                q1.<span class="built_in">push</span>(q2.<span class="built_in">top</span>());</span><br><span class="line">                q2.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为偶数的时候，输出两个堆顶的平均值；为奇数时，直接输出元素数量较大的堆顶</span></span><br><span class="line">        <span class="keyword">if</span>((i &amp; <span class="number">1</span>) == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, (q1.<span class="built_in">top</span>() + q2.<span class="built_in">top</span>()) * <span class="number">1.0</span> / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, q1.<span class="built_in">size</span>() &gt; q2.<span class="built_in">size</span>() ? q1.<span class="built_in">top</span>() : q2.<span class="built_in">top</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="哈希表">哈希表</h4>
<p><strong>使用场景</strong></p>
<ul>
<li>将某些复杂较大的数映射成相对较小的数：例如将0 ~ 10<sup>9</sup>
的数映射成0 ~ 10<sup>5</sup> 的数</li>
<li>其最简单的操作就是让 x mol N , N 取 10<sup>5</sup></li>
</ul>
<p><strong>哈希冲突</strong></p>
<ul>
<li>两个相同的数会映射成同一个数，此时就产生了哈希冲突：映射后的数到底指向哪一个？</li>
</ul>
<p><strong>模拟哈希表</strong></p>
<ul>
<li>两种方式构建哈希表以解决哈希冲突
<ul>
<li>链表+数组的方式构建哈希表</li>
<li>数组 + 开放寻址法</li>
</ul></li>
<li>数组的长度(即N)的要求
<ul>
<li>在进行哈希时，被取模的数一般需要为质数，且远离2的n次方</li>
<li>因为可以用数学证明此种取法出现哈希冲突的概率最小</li>
</ul></li>
</ul>
<h5 id="模拟散列表">模拟散列表</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拉链法，链指的是单链表</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100003</span>;	<span class="comment">//取模的数最好是质数，题目数据范围是1e5,100003为1e5之后的第一个质数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;	<span class="comment">//h[N]表示散列表，e[N]表示单链表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//首先找到x映射后的下标 为什么是(x % N + N) % N，因为取模运算在c++中是会出现负数的</span></span><br><span class="line">    <span class="comment">//例如 -10 % 3 == -1 (可以先当作正数取模，最后将取模结果加上负号即可)</span></span><br><span class="line">    <span class="comment">//负数取模运算结果只能是负数或0 (c++中), 数学中取模后的结果只能为正数</span></span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;	</span><br><span class="line">    e[idx] = x;		<span class="comment">//单链表的插入操作				</span></span><br><span class="line">    ne[idx] = h[k];	<span class="comment">//头插法，h[k]理解为头结点				</span></span><br><span class="line">    h[k] = idx ++ ; <span class="comment">//h[k]实际上存储的是真实数的下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断x是否在哈希表中</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;	<span class="comment">//首先需要找到x映射后的下标</span></span><br><span class="line">    <span class="comment">//从h[k]所在的单链表开始找，最后一个元素的ne为-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="comment">//由于h[k]是头结点，所以需要先将其指向一个标记</span></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);	<span class="comment">//memset按字节设置数值，-1的二进制位上全为1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开放寻址法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与拉链法不同，开放寻址法只需要开辟一个数组，但其大小要为数组数据的2~3倍，且数组长度也最好为质数且远离2的n次方</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200003</span>, null = <span class="number">0x3f3f3f3f</span>;	<span class="comment">//null用来标识空元素，因为其稍大于int，超过了各个数字的范围</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入数据的过程：找有没有位置能够存放改元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">    <span class="comment">//如果映射位置t上有元素，则需要从其下一位开始找，直到h[t] == null</span></span><br><span class="line">    <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        t ++ ;</span><br><span class="line">        <span class="comment">//如果t走到尽头没找到有空位的位置，则从头开始找</span></span><br><span class="line">        <span class="keyword">if</span> (t == N) t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//while循环一定会结束，因为哈希表数组容量是数据范围的两倍</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//首先需要将哈希表中的所有数字全部初始化为null</span></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> h);	<span class="comment">//因为memset是按照字节来初始化的，0x3f3f3f3f的一个字节就是0x3f</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;I&#x27;</span>) h[<span class="built_in">find</span>(x)] = x; 	<span class="comment">//插入元素</span></span><br><span class="line">        <span class="keyword">else</span>	<span class="comment">//查询一个元素是否出现在哈希表中出现过</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//出现哈希冲突的概率很小，所以当h[find(x)]等于null的时候，认为x没有出现过</span></span><br><span class="line">            <span class="keyword">if</span> (h[<span class="built_in">find</span>(x)] == null) <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="字符串哈希">字符串哈希</h5>
<ul>
<li>一种特殊的哈希方式，对一个长字符串进行哈希处理，将其所有前缀映射成一个P进制的数，通过这个P进制的哈希值，可以很快地比较两个字符串是否相等</li>
<li>将所有前缀映射成哈希值的好处：可以快速求得下一个前缀的哈希值，类似数组的前缀和
<ul>
<li>例如：已知 "ABCDEF" 的哈希值和 "ABC" 的哈希值，可以求得 "DEF"
的哈希值</li>
</ul></li>
<li>映射过程：P进制的每个位上表示当前字符的ASCII码值，最后对这个P进制数取余数即为该前缀的哈希值</li>
<li>解决冲突：设置 P 为 131 或者 13331，Q 取
2<sup>64</sup>，此时冲突率最低，99.99%几率不冲突</li>
<li>注意：任意字符不能映射成0</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	题目，给定一个字符串，要求判断主串中的两个子串是否相等</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, P = <span class="number">131</span>;	<span class="comment">//经验上P取 131 或 13331 Q 取 2^64 此时冲突率最低，99.99%几率不冲突</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[N];	<span class="comment">//用于接收字符串</span></span><br><span class="line">ULL h[N], p[N];	<span class="comment">//h[1]表示str第一个字符的哈希值，以此类推；p[1]表示 p的1次方</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//计算区间子字符串哈希值的公式</span></span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];	<span class="comment">//返回区间[l, r]子字符串的哈希值</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	解释一下公式：目标字符串哈希值：[l, r]位置子字符串的哈希值</span></span><br><span class="line"><span class="comment">    	已知[1, r] 和 [1, l] 的哈希值</span></span><br><span class="line"><span class="comment">    	过程：先将短串向左移动使其与长串最高位对其，移动的位数为 (r-1) - ((l-1) - 1) = r - l + 1</span></span><br><span class="line"><span class="comment">    	类似十进制数 12345672 - 1235600 = 72</span></span><br><span class="line"><span class="comment">    	相当于乘上p的(r - l + 1)次方，其中(l-1)表示的是l的前一位</span></span><br><span class="line"><span class="comment">    	取模的过程在h[]数组接收int数据将其转换为ULL时已经完成，ULL最大可表示2^64，超过其范围会自动取模</span></span><br><span class="line"><span class="comment">    	而本题的Q恰好为2^64。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;	<span class="comment">//初始化，p的0次方为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//先将P进制数h[i - 1]向左移动一位，再加上当前位的值，最后总的再取模，因为h是ULL类型数组。 </span></span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] * P + str[i];	<span class="comment">//+str[i]加的是str[i]的ASCII值 </span></span><br><span class="line">        p[i] = P * p[i - <span class="number">1</span>];	<span class="comment">//构建p数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l1, r1, l2, r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">query</span>(l1, r1) == <span class="built_in">query</span>(l2, r2)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="树状数组和线段树">树状数组和线段树</h4>
<p><strong>关系</strong></p>
<ul>
<li>线段树包含了树状数组，树状数组能解决的问题，线段树也能解决，但是线段树解决问题的范围更大</li>
</ul>
<h5 id="树状数组">树状数组</h5>
<p><strong>核心功能</strong></p>
<ol type="1">
<li><p>使数组的指定位置 x 上加上一个数 v 时间复杂度：O(logn)</p></li>
<li><p>快速查询数组的某个前缀和 [1, r] 时间复杂度：O(logn)</p></li>
</ol>
<p><strong>注意：树状数组，原数组的下标必须从1开始</strong></p>
<p><strong>模型介绍</strong></p>
<p><img src="/images/树状数组.png" /></p>
<ul>
<li>设树状数组为 C(n), 原数组为 A(n)</li>
<li>n 为奇数时，C(n) = a(n)</li>
<li>含义：C[x]表示的是原数组 (x - lowbit(x), x] 该区间的和</li>
</ul>
<p><strong>核心函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N];	<span class="comment">//原数组</span></span><br><span class="line"><span class="type">int</span> tr[N];	<span class="comment">//树状数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span>	<span class="comment">//返回x的最后一位1对应的数字， 例如 lowbit(3) == 1 (3)2 = 11</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>	<span class="comment">//表示向原数组的x位置上加上一个数，对应的tr数组也必须跟着改变</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// i + lowbit(i) 表示的就是i的上一级，x位置上加上了一个数，则与其关联的tr都必须相应改变</span></span><br><span class="line">    <span class="comment">//n表示的是树状数组的最大下标是多少，这点非常重要</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) tr[i] += y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//定义：tr[x] 中存放的是 (x-lobit(i), x]的和</span></span><br><span class="line">    <span class="comment">//想要得到S[1, x] 则必须将所有片段都累加，才能得到S[1, x]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &gt; <span class="number">0</span>; i -= <span class="built_in">lowbit</span>(i)) res += tr[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="线段树">线段树</h5>
<p><strong>模型介绍</strong></p>
<p><img src="/images/线段树.png" /></p>
<p><strong>核心功能</strong></p>
<ol type="1">
<li>使数组指定位置 x 加上一个数 时间复杂度 O(logn)</li>
<li>快速查询数组的某个区间的和 [l, r] 时间复杂度：O(logn)</li>
</ol>
<p><strong>与线段数组的异同</strong></p>
<ul>
<li>功能差不多，但是线段树可以求<strong>某个区间内的最大值</strong>，树状数组做不到</li>
<li>一般来说，线段树的执行效率要比树状数组慢</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个节点存储的信息有：当前区间[l,r] 当前区间和sum</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];	<span class="comment">//一般需要开四倍的空间，总节点数 &lt;= 4n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线段树的存储与heap类似，设当前节点为u，则tr[u&lt;&lt;1]存储u的左儿子节点，tr[u&lt;&lt;1|1]存储u的右儿子节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//更新某个节点的sum：用子节点l和子节点r的和来更新</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].sum = tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//当l == r表示当前区间只有一个数，则直接赋当前节点为&#123;l, r, w[l]&#125;</span></span><br><span class="line">    <span class="keyword">if</span>(l == r) tr[u] = &#123;l, r, w[l]&#125;;	<span class="comment">//注意不是w[u]，血的教训！</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid);	<span class="comment">//递归建立左儿子节点</span></span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);	<span class="comment">//递归建立右儿子节点</span></span><br><span class="line">        <span class="built_in">push_up</span>(u);	<span class="comment">//建完左儿子和右儿子后需要更新当前节点的sum</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> <span class="comment">//[l, r]表示查询区间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果查询区间完全包含了当前区间，则直接返回即可</span></span><br><span class="line">    <span class="keyword">if</span>(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//否则需要判断，查询区间与当前区间的那一半边有交集</span></span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果与左半边有交集，则查询u的左儿子节点</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) sum += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="comment">//如果与右半边有交集，则查询u的右儿子节点</span></span><br><span class="line">    <span class="keyword">if</span>(r &gt;= mid + <span class="number">1</span>) sum += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l , r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span> <span class="comment">//表示向根节点为u的，x位置上的值加上一个数v</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(tr[u].l == tr[u].r) tr[u].sum += v;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果修改位置在左边，则前往左边修改</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v); 	<span class="comment">//否则修改右边</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//凡是涉及值的变动，都需要更新一下当前节点的父节点</span></span><br><span class="line">        <span class="built_in">push_up</span>(u);	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);	<span class="comment">//建树的过程</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;k, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, x, y));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="number">1</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/b32e57d2/" rel="prev" title="基础算法">
                  <i class="fa fa-angle-left"></i> 基础算法
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/374e1302/" rel="next" title="数学知识">
                  数学知识 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">sabersnt</span>
  </div>

    </div>
  </footer>

  

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
