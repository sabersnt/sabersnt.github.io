<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/red-32x32.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/red-16x16.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"在这里输入你要搜索的内容","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="DFS、BFS、双向BFS、图、深度优先遍历、广度优先遍历、拓扑排序、最短路问题、最小生成树、二分图、树的直径">
<meta property="og:type" content="article">
<meta property="og:title" content="搜索与图论">
<meta property="og:url" content="http://example.com/posts/f7a7d551/index.html">
<meta property="og:site_name" content="Alcatraz Island">
<meta property="og:description" content="DFS、BFS、双向BFS、图、深度优先遍历、广度优先遍历、拓扑排序、最短路问题、最小生成树、二分图、树的直径">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-11-05T14:35:56.574Z">
<meta property="article:modified_time" content="2023-12-03T04:47:40.777Z">
<meta property="article:author" content="sabersnt">
<meta property="article:tag" content="搜索与图论">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/posts/f7a7d551/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/posts/f7a7d551/","path":"posts/f7a7d551/","title":"搜索与图论"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>搜索与图论 | Alcatraz Island</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Alcatraz Island</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="在这里输入你要搜索的内容" spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#dfs"><span class="nav-text">DFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bfs"><span class="nav-text">BFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E5%90%91bfs"><span class="nav-text">双向BFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-text">图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-text">树与图的深度优先遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-text">树与图的广度优先遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98"><span class="nav-text">最短路问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%B4%E7%B4%A0dijkstra%E7%AE%97%E6%B3%95"><span class="nav-text">朴素Dijkstra算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A0%86%E4%BC%98%E5%8C%96%E7%89%88dijkstra%E7%AE%97%E6%B3%95"><span class="nav-text">堆优化版dijkstra算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89%E8%BE%B9%E6%95%B0%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98"><span class="nav-text">有边数限制的最短路问题</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#bellman_ford%E7%AE%97%E6%B3%95"><span class="nav-text">Bellman_ford算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96%E7%89%88%E7%9A%84bellman_ford%E7%AE%97%E6%B3%95"><span class="nav-text">队列优化版的Bellman_ford算法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#spfa%E7%AE%97%E6%B3%95"><span class="nav-text">spfa算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#spfa%E5%88%A4%E6%96%AD%E8%B4%9F%E7%8E%AF"><span class="nav-text">spfa判断负环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#floyd%E7%AE%97%E6%B3%95"><span class="nav-text">floyd算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98"><span class="nav-text">最小生成树问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#prime%E7%AE%97%E6%B3%95"><span class="nav-text">prime算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#kruskal%E7%AE%97%E6%B3%95"><span class="nav-text">kruskal算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="nav-text">二分图</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%93%E8%89%B2%E6%B3%95%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="nav-text">染色法判断二分图是否存在</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95"><span class="nav-text">匈牙利算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="nav-text">树的直径</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E6%AC%A1dfs%E6%B1%82%E7%9B%B4%E5%BE%84"><span class="nav-text">两次dfs求直径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%91%E5%BD%A2dp%E6%B1%82%E7%9B%B4%E5%BE%84"><span class="nav-text">树形dp求直径</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83"><span class="nav-text">树的重心</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="sabersnt"
      src="/images/ygyt.png">
  <p class="site-author-name" itemprop="name">sabersnt</p>
  <div class="site-description" itemprop="description">莫听穿林打叶声，何妨吟啸且徐行</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/f7a7d551/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ygyt.png">
      <meta itemprop="name" content="sabersnt">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alcatraz Island">
      <meta itemprop="description" content="莫听穿林打叶声，何妨吟啸且徐行">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="搜索与图论 | Alcatraz Island">
      <meta itemprop="description" content="DFS、BFS、双向BFS、图、深度优先遍历、广度优先遍历、拓扑排序、最短路问题、最小生成树、二分图、树的直径">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          搜索与图论
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-05 22:35:56" itemprop="dateCreated datePublished" datetime="2023-11-05T22:35:56+08:00">2023-11-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-12-03 12:47:40" itemprop="dateModified" datetime="2023-12-03T12:47:40+08:00">2023-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">DFS、BFS、双向BFS、图、深度优先遍历、广度优先遍历、拓扑排序、最短路问题、最小生成树、二分图、树的直径</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h4 id="dfs">DFS</h4>
<p><strong>定义</strong></p>
<ul>
<li>深度优先算法：从根节点出发，只要到达的节点有子节点就一直走下去，直到走到没有根节点的节点为止；然后再向上回溯</li>
<li>继续从父节点的另一个子节点(平级节点)出发，直到走到最后层的最后一个节点</li>
</ul>
<p><strong>应用</strong></p>
<ul>
<li>DFS其实就是把所有可能的情况全部都模拟一遍，只是其顺序是深度搜索</li>
<li>例如求一个数的全排列：1 2 3，1 3 2，2 1 3，2 3 1，3 1 2，3 2 1</li>
</ul>
<p><strong>排列组合I</strong></p>
<p><a
target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/844/">原题链接</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	输入一个数，按字典序输出其全排列，每个方案占一行。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> path[N];	<span class="comment">//表示排列方案</span></span><br><span class="line"><span class="type">bool</span> mak[N];	<span class="comment">//表示 1 ~ n 中的数是否被用过</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == n)	<span class="comment">//如果x为n，表示已经走到第n位了，因为是从0开始的，可以输出了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, path[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)	<span class="comment">//x位上可以填1 ~ n中的数</span></span><br><span class="line">        <span class="keyword">if</span>(!mak[i])</span><br><span class="line">        &#123;</span><br><span class="line">            path[x] = i;</span><br><span class="line">            mak[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(x + <span class="number">1</span>);	<span class="comment">//进行x+1的数字填写</span></span><br><span class="line">            mak[i] = <span class="literal">false</span>;	<span class="comment">//第x位要换数字了，重新洗牌</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>排列组合II</strong></p>
<ul>
<li>给定一个可包含重复数字的整数集合nums，按任意顺序返回它所有不重复的全排列。</li>
</ul>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/7p8L0Z/description/">原题链接</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; hash;    <span class="comment">//放入当前位置x所对应的值,如果重复则直接跳过</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.<span class="built_in">count</span>(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            hash.<span class="built_in">emplace</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i != x)<span class="built_in">swap</span>(nums[x], nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(x + <span class="number">1</span>, nums);</span><br><span class="line">            <span class="keyword">if</span>(i != x)<span class="built_in">swap</span>(nums[x], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>例题</strong></p>
<ul>
<li>n-皇后问题：将 n个皇后放在 n×n
的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历顺序1：每个格子都遍历</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> row[N], col[N], dg[N], udg[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> s)</span>	<span class="comment">//x表示第x+1行，y表示第y+1列，s表示当前已放皇后的个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y == n)	<span class="comment">//如果y走到尽头，则将&quot;指针&quot;移动至下一行</span></span><br><span class="line">    &#123;</span><br><span class="line">        y = <span class="number">0</span>;	</span><br><span class="line">        x ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == n)	<span class="comment">//表示x已经遍历至最后一行</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == n)	<span class="comment">//当全部皇后已放完则为一种分法</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">puts</span>(g[i]);	<span class="comment">//输出char[][]中的每一行</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//每次dfs都有两个选择</span></span><br><span class="line">    <span class="comment">//1.不放皇后：直接往下一列搜索</span></span><br><span class="line">    <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.放皇后则需要满足同行同列同对角线没有皇后</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	棋盘上在同一条正对角线(斜率为正)的点满足性质：x + y = C (C为一个定值)</span></span><br><span class="line"><span class="comment">    	棋盘上在同一条反对角线(斜率为负)的点满足性质：x - y = C (C为一个定值)</span></span><br><span class="line"><span class="comment">    	可以根据此性质将其映射至数组下标表示其线上有无皇后</span></span><br><span class="line"><span class="comment">    	但x - y可能出现负数，数组中不存在负数下标，所以需要将其映射成 x - y + n = C</span></span><br><span class="line"><span class="comment">    	-n &lt;= x - y, 因此+n可以保证其为正数</span></span><br><span class="line"><span class="comment">    	</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[x - y + n])</span><br><span class="line">    &#123;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;Q&#x27;</span>;	<span class="comment">//当前位置(x, y)存放皇后</span></span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">true</span>;	<span class="comment">//标记(x, y)已放皇后</span></span><br><span class="line">        <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, s + <span class="number">1</span>);	<span class="comment">//递归进行下一列的搜索</span></span><br><span class="line">        <span class="comment">//当下一列的搜索所有的不满足的时候，需要将其原来的行数往前移动一单位，char数组中的&#x27;Q&#x27;需要还原</span></span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">false</span>;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;.&#x27;</span>;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//预处理：将char数组中所有字符都赋值成&#x27;.&#x27;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);	<span class="comment">//从(0, 0)位置开始搜索，初始存放皇后为0</span></span><br><span class="line">       </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历顺序2：优化后的版本，从每一行开始搜索，同一行或同一列只能有一个皇后</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="comment">//由于从每一行开始遍历，所以不需要row数组，对角线数组的下标可能取到2n，所以数组大小开两倍</span></span><br><span class="line"><span class="type">bool</span> col[N], dg[N], udg[N];	</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span>	<span class="comment">//x表示当前行(下标从0开始)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == n)	<span class="comment">//表示已经搜索到最后一层，则输出答案</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">puts</span>(g[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)	<span class="comment">//对指定一行的每一列进行遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!col[i] &amp;&amp; !udg[i + x] &amp;&amp; !dg[x - i + n])	</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//x表示的是行，i表示的是列</span></span><br><span class="line">            g[x][i] = <span class="string">&#x27;Q&#x27;</span>;	<span class="comment">//满足条件则在当前位置插入‘Q’</span></span><br><span class="line">            col[i] = udg[i + x] = dg[x - i + n] = <span class="literal">true</span>;	<span class="comment">//标记当前位置已放皇后</span></span><br><span class="line">            <span class="built_in">dfs</span>(x + <span class="number">1</span>);	<span class="comment">//继续向下一行开始搜索</span></span><br><span class="line">            <span class="comment">//如果下一行所有位置均不满足，则表明当前[x][i]的位置不能放皇后，进入到[x][i+1]开始判定</span></span><br><span class="line">            col[i] = udg[i + x] = dg[x - i + n] = <span class="literal">false</span>;  </span><br><span class="line">            g[x][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//预处理：将char数组中所有字符都赋值成&#x27;.&#x27;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bfs">BFS</h4>
<p><strong>定义</strong></p>
<ul>
<li>广度优先算法：从根节点出发，先搜索距离根节点为1的点，将所有距离为1的点搜索完后再继续搜索距离为2的点，以此类推</li>
</ul>
<p><strong>模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//bfs中没有递归调用</span></span><br><span class="line"><span class="keyword">while</span>(队列不为空)</span><br><span class="line">&#123;</span><br><span class="line">	取出对头元素</span><br><span class="line">	对对头元素进行扩展</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>例题</strong></p>
<ol type="1">
<li>走迷宫：给定一个 n×m的二维整数数组，用来表示一个迷宫，数组中只包含 0
或 1，其中 0 表示可以走的路，1
表示不可通过的墙壁。最初，有一个人位于左上角
(1,1)处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。请问，该人从左上角移动至右下角
(n,m)处，至少需要移动多少次。数据保证 (1,1)处和 (n,m)处的数字为 0
，且一定至少存在一条通路</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;	<span class="comment">//pair类型用来存储每个点的坐标</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> mp[N][N];	<span class="comment">//表示地图</span></span><br><span class="line"><span class="type">int</span> d[N][N];	<span class="comment">//表示从起点走到坐标(x, y)的步数</span></span><br><span class="line">queue&lt;PII&gt; q;	<span class="comment">//queue存储的是每一步走到的点</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);	<span class="comment">//初始化将所有点的步数为-1，表示该点没有走过</span></span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;	<span class="comment">//起始点到起始点的步数为0</span></span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);	<span class="comment">//插入起始点，从起始点开始走</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;	<span class="comment">//dx, dy组合表示当前点的上下左右的偏移量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())	<span class="comment">//bfs的一个模板</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();	</span><br><span class="line">        q.<span class="built_in">pop</span>();	<span class="comment">//取出对头元素并且对头出队</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;	</span><br><span class="line">            <span class="type">int</span> x = t.first + dx[i], y = t.second + dy[i];		<span class="comment">//(x, y)表示对头位置的下一个点</span></span><br><span class="line">            <span class="comment">//如果(x, y)没有超出边界并且mp[x][y]为0(表示可以走),且d[x][y]=-1,(表示没有走过)</span></span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; mp[x][y] == <span class="number">0</span> &amp;&amp; d[x][y] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                d[x][y] = d[t.first][t.second] + <span class="number">1</span>;	<span class="comment">//更新该点走的步数</span></span><br><span class="line">                mp[x][y] = <span class="number">1</span>;	<span class="comment">//标记当前点已经被走过</span></span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x, y&#125;);	<span class="comment">//当前点入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//(n-1, m-1)表示的是最右下角的点，d[n - 1][m - 1]则表示到达最后一个点走的步数，由于第一个到达该点后其他点不能到达，</span></span><br><span class="line"><span class="comment">//所以d[n - 1][m - 1]表示的就是从起始点到最后一个点的最短路径</span></span><br><span class="line">    <span class="keyword">return</span> d[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(mp, <span class="number">1</span>, <span class="keyword">sizeof</span> mp);	<span class="comment">//初始化地图，为地图打上边界 1 </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;mp[i][j]);		<span class="comment">//读取题目给的地图</span></span><br><span class="line">            </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">bfs</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<ol start="2" type="1">
<li>八数码：在一个 3×3 的网格中，1∼8 这 8 个数字和一个 x
恰好不重不漏地分布在这 3×3 的网格中，在游戏过程中，可以把 x
与其上、下、左、右四个方向之一的数字交换（如果存在）。我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：1
2 3 4 5 6 7 8 x</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	思路：用字符串来表示每一次字符串转换的状态，需要将字符串中的下标与矩阵中的下标进行转换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">queue&lt;string&gt; q;	<span class="comment">//维护的是每一个字符串转换后的状态</span></span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; d;	<span class="comment">//表示从初始状态到当前状态的步数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(str);	<span class="comment">//初始状态入队</span></span><br><span class="line">    d[str] = <span class="number">0</span>;		<span class="comment">//初始状态的步数为0</span></span><br><span class="line">    string res = <span class="string">&quot;12345678x&quot;</span>;	<span class="comment">//用于与对头元素判断是否到达最终目标状态</span></span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;	<span class="comment">//表示每一步的偏移量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())	</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();		</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> k = t.<span class="built_in">find</span>(<span class="string">&#x27;x&#x27;</span>);	<span class="comment">//k存储对头元素中&#x27;x&#x27;的位置</span></span><br><span class="line">        <span class="type">int</span> x = k / <span class="number">3</span>, y = k % <span class="number">3</span>;	<span class="comment">//将&#x27;x&#x27;的下标转换成矩阵中的下标</span></span><br><span class="line">        <span class="type">int</span> dist = d[t];	<span class="comment">//dist表示对头元素的步数</span></span><br><span class="line">        <span class="keyword">if</span>(t == res) <span class="keyword">return</span> dist; 	<span class="comment">//如果对头元素符合最终状态，则返回距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)	<span class="comment">//对对头元素进行偏移</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = x + dx[i], b = y + dy[i];	<span class="comment">//(a, b)表示对头元素偏移量在数组中的下标</span></span><br><span class="line">            <span class="keyword">if</span>(a &gt;= <span class="number">0</span> &amp;&amp; a &lt; <span class="number">3</span> &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; <span class="number">3</span>)	<span class="comment">//判断(a, b)是否超出矩阵边界</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(t[k], t[a * <span class="number">3</span> + b]);	<span class="comment">//未超出则交换&#x27;x&#x27;与(a, b)上的字符，矩阵坐标(a,b)映射成字符串下标：a * 3 + b</span></span><br><span class="line">                <span class="keyword">if</span>(!d.<span class="built_in">count</span>(t))		<span class="comment">//如果交换完后的字符串没有出现过</span></span><br><span class="line">                &#123;</span><br><span class="line">                    d[t] = dist + <span class="number">1</span>;	<span class="comment">//更新交换完后字符串的距离</span></span><br><span class="line">                    q.<span class="built_in">push</span>(t);		<span class="comment">//交换完后的状态入队</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">swap</span>(t[k], t[a * <span class="number">3</span> + b]);	<span class="comment">//还原后进行其余方向(上下左右)的交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//所有路都走完了，没有目标状态，则返回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>; i++)	<span class="comment">//读取字符串的初始状态</span></span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        str += op[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>(str) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="双向bfs">双向BFS</h4>
<p><strong>内容</strong></p>
<ul>
<li>针对bfs的一个优化，大大提高搜索效率和降低空间的开销</li>
</ul>
<p><strong>适用</strong></p>
<ul>
<li>从初始状态开始向目标状态开始进行深度优先遍历，两个状态相遇时即停止</li>
<li>节点数量较多时，可以大大减少空间的开销</li>
</ul>
<p><strong>模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">_Ty <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;_Ty&gt; q1, q2;</span><br><span class="line">	unordered_map&lt;_T1, _T2&gt; m1, m2; 	<span class="comment">//_T1为需要操作的每个状态，_T2表示该状态的某些属性</span></span><br><span class="line">	<span class="keyword">while</span>(q1.<span class="built_in">size</span>() &amp;&amp; q2.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">    	_Ty res = 初始值;</span><br><span class="line">        <span class="keyword">if</span>(q1.<span class="built_in">size</span>() &lt;= q2.<span class="built_in">size</span>())</span><br><span class="line">            res = <span class="built_in">operate</span>(q1);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            res = <span class="built_in">operate</span>(q2);</span><br><span class="line">       	<span class="keyword">if</span>(res != 初始值) <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> 特定的值;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">_Ty <span class="title">operate</span><span class="params">(queue&lt;_T&gt; q, unordered_map&lt;_T1, _T2&gt;&amp; cur, unordered_map&lt;_T1, _T2&gt;&amp; other)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sz = q.<span class="built_in">size</span>(); </span><br><span class="line">    <span class="keyword">while</span>(sz--)	<span class="comment">//如果对于层数有着严格的要求的，则必须逐层遍历，否则可以不用。例如求状态转移的步数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        根据题目要求，拓展对头元素 设新元素为s</span></span><br><span class="line"><span class="comment">        如果新状态入队过st[t] == true，则continue</span></span><br><span class="line"><span class="comment">        如果新状态在另一个q中入队过，则可以返回 cur[s] + 1 + other[s]</span></span><br><span class="line"><span class="comment">        否则则 cur[s] = cur[t] + 1;</span></span><br><span class="line"><span class="comment">        最后不要忘记将st[t]设为true</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有在上面的代码中返回，则表示无解</span></span><br><span class="line">    <span class="keyword">return</span> 无解对应的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="图">图</h4>
<p><strong>定义</strong></p>
<ul>
<li>用于表示多对多的关系，任意两个节点之间可以形成一条边</li>
</ul>
<p><strong>分类</strong></p>
<ul>
<li>按有无环
<ul>
<li>有环图</li>
<li>无环图</li>
</ul></li>
<li>按边的类型
<ul>
<li>有向图：规定了边的指定方向：a -&gt; b</li>
<li>无向图：边的指定方向未指定：a -&gt; b, b -&gt; a</li>
</ul></li>
</ul>
<p><strong>图的存储</strong></p>
<ol type="1">
<li>邻接表法：为每个元素开一个单链表，链表中存储的是该元素可以指到的位置，
<strong>适用于稀疏图</strong>
<ol type="1">
<li>一般使用头插法为表中添加元素</li>
</ol></li>
<li>临接矩阵法：<strong>适用于稠密图</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表的插入模板</span></span><br><span class="line"><span class="type">int</span> e[N], ne[N], h[N], idx;	<span class="comment">//h[]表示每个节点对应的头结点，初始指向-1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>	<span class="comment">//为图中添加一条a指向b的边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="树与图的深度优先遍历">树与图的深度优先遍历</h4>
<p><strong>定义</strong></p>
<ul>
<li>一条路走到尽头，函数递归调用</li>
</ul>
<p><strong>作用</strong></p>
<ul>
<li>求出树所有节点个数</li>
</ul>
<p><strong>模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>;	<span class="comment">//标记当前点已经走过</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])	<span class="comment">//对当前点进行拓展</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(st[j]) <span class="keyword">continue</span>;	<span class="comment">//如果子节点已经走过，则跳过</span></span><br><span class="line">       	<span class="built_in">dfs</span>(j);	<span class="comment">//继续遍历未走过的子节点，重复上面的流程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>例题</strong></p>
<ul>
<li>给定一颗树，树中包含 n 个结点（编号 1∼n）和
n−1条无向边。请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值</li>
<li>重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点的数量的最大值最小，那么这个节点被称为树的重心。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = N * <span class="number">2</span>;	<span class="comment">//由于是无向边，所以需要开两倍的数组</span></span><br><span class="line"><span class="type">int</span> e[M], h[N], ne[M], idx;	<span class="comment">//邻接表法</span></span><br><span class="line"><span class="type">bool</span> st[N];		<span class="comment">//判断当前点是否走过</span></span><br><span class="line"><span class="type">int</span> n, ans = N;	<span class="comment">//记录答案ans, ans的最大可能的值为N</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加边a -&gt; b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dfs()的作用是寻找以 u 为根节点，树的节点总个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>;	<span class="comment">//标记当前点已经走过</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>, res = <span class="number">0</span>;	<span class="comment">//sum表示当前树的节点个数，res表示去掉根节点u后，每个连通块的子节点的个数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])	<span class="comment">//遍历根节点u的所有子节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];	<span class="comment">//h[] 和 ne[]存储的都是下标，e[]中存储的是真实的编号</span></span><br><span class="line">        <span class="keyword">if</span>(st[j]) <span class="keyword">continue</span>;		<span class="comment">//如果j点遍历过则跳到下一个节点</span></span><br><span class="line">        <span class="type">int</span> s = <span class="built_in">dfs</span>(j);	<span class="comment">//递归调用，s接收以 j 为根节点，树的节点总个数</span></span><br><span class="line">        sum += s;	<span class="comment">//根节点 + 子树节点个数</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, s);		<span class="comment">//更新res,目的是求所有连通块的节点数的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    res = <span class="built_in">max</span>(res, n - sum);	<span class="comment">//最后res还要与出去u为根这颗树之外的树作比较，总数为n，u的节点数为sum</span></span><br><span class="line">    ans = <span class="built_in">min</span>(ans, res);	<span class="comment">//答案需要对每个节点数的最大值求最小</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum;		<span class="comment">//返回根为u的树的节点总数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);	<span class="comment">//初始化单链表</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">2</span>);	<span class="comment">//dfs(1), dfs(2)都可以，因为图是连通的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="树与图的广度优先遍历">树与图的广度优先遍历</h4>
<p><strong>定义</strong></p>
<ul>
<li><p>现将能第一层节点遍历完在遍历第二层</p></li>
<li><p>例如：a-&gt;b, a-&gt;c, b-&gt;d, d-&gt;s 先遍历 b、c 再遍历 d
最后遍历 s</p></li>
</ul>
<p><strong>作用</strong></p>
<ul>
<li>求出子节点到根节点之间的最短距离</li>
</ul>
<p><strong>模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//其实就是宽搜框架：用一个队列来维护，每次取出队头元素进行拓展</span></span><br><span class="line">    <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(d[j] == <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(j); </span><br><span class="line">        		d[j] = d[t] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>例题</strong></p>
<ul>
<li>给定一个 n 个点 m
条边的有向图，图中可能存在重边和自环。所有边的长度都是 1，点的编号为
1∼n。请你求出 1号点到 n号点的最短距离，如果从1号点无法走到n号点，输出
−1。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> e[N], ne[N], h[N], idx;	<span class="comment">//模拟单链表</span></span><br><span class="line"><span class="type">int</span> q[N], d[N];	<span class="comment">//模拟队列</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    q[++tt] = <span class="number">1</span>;	<span class="comment">//编号为1的节点入队</span></span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);	<span class="comment">//初始化d[]: 所有点到根节点的距离为-1</span></span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;	<span class="comment">//根节点到根节点的距离为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)	<span class="comment">//只要队列不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];	<span class="comment">//取出队头元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])	<span class="comment">//遍历队头子节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];	<span class="comment">//j表示编号为j的子节点</span></span><br><span class="line">            <span class="keyword">if</span>(d[j] == <span class="number">-1</span>)	<span class="comment">//子节点没有被遍历</span></span><br><span class="line">            &#123;</span><br><span class="line">                d[j] = d[t] + <span class="number">1</span>;	<span class="comment">//子节点距离+1</span></span><br><span class="line">                q[++tt] = j;	<span class="comment">//子节点入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);	<span class="comment">//单链表的初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">bfs</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="拓扑排序">拓扑排序</h4>
<p><strong>定义</strong></p>
<ul>
<li>将各个节点进行排序，每两个节点之间边的指向不能为从后往前</li>
<li>原图：1-&gt;2 , 2-&gt;3, 3-&gt;4, 1-&gt;3，拓扑序列：1 2 3 4</li>
</ul>
<p><strong>充要条件</strong></p>
<ul>
<li>原图必须是有向无环图</li>
</ul>
<p><strong>例题</strong></p>
<ul>
<li>给定一个 n 个点 m 条边的有向图，点的编号是 1 到
n，图中可能存在重边和自环。请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出
−1。若一个由图中所有点构成的序列 A 满足：对于图中的每条边 (x,y)，x 在 A
中都出现在 y 之前，则称 A 是该图的一个拓扑序列。</li>
</ul>
<p><strong>思路</strong></p>
<ul>
<li>求拓扑排序：维护一个队列 ( STL要用双端队列 deque
)，首先找到任意一个入度为0的点将其入队</li>
<li>然后删除该点 pop_front( )
以及其指向的所有节点的边删除，且各节点的入度减1，接着重复上一步的操作找入度为0的点入队。若所有节点都能被删除，则表示此图可以进行拓扑排序，否则不行</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> e[N], ne[N], h[N], idx;</span><br><span class="line"><span class="type">int</span> q[N], d[N];	<span class="comment">//d[i]表示编号为i的点的入度(有多少条边指向i)</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topo</span><span class="params">()</span>	<span class="comment">//若能够形成一个拓扑序列，则返回true，否则返回false</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;	<span class="comment">//队列的初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将所有入度为0的点入队，从它们开始突破</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(d[i] == <span class="number">0</span>)</span><br><span class="line">            q[++tt] = i; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];	<span class="comment">//取出队头元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="comment">//--d[j]操作就是将t 与 j 之间的边删掉</span></span><br><span class="line">            <span class="comment">//删除t指向j的边后如果入度为0，则入队，可能不止一个点指向j</span></span><br><span class="line">            <span class="keyword">if</span>(--d[j] == <span class="number">0</span>) q[++tt] = j;	</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果每个节点都已经入队，则表示该图可以进行拓扑排序</span></span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">        d[b]++;	<span class="comment">//a-&gt;b 的有向边，b的入度+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">topo</span>()) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最短路问题">最短路问题</h4>
<p><strong>概念</strong></p>
<ul>
<li>最短路问题即是寻找同一个网络中的两个节点之间的一条通路，使“消耗”在这条通路上的权重最小的问题，这里的权重可替换为最小距离、最短时间、最小成本等。</li>
</ul>
<p><strong>分类</strong></p>
<ul>
<li>单源最短路
<ul>
<li>所有边权都为正数
<ul>
<li>朴素Dijkstra算法：o(n ^ 2)</li>
<li>堆优化版Dijkstra算法：o(mlogn)</li>
</ul></li>
<li>存在负边
<ul>
<li>Bellman_ford算法：o(n*m)</li>
<li>SPFA算法：一般o(m), 最坏 o(n*m)</li>
</ul></li>
</ul></li>
<li>多源最短路
<ul>
<li>Floyd算法：o(n^3)</li>
</ul></li>
</ul>
<h5 id="朴素dijkstra算法">朴素Dijkstra算法</h5>
<p><strong>使用条件</strong></p>
<ul>
<li>所有边权必须为正数：如果边权为负数则违背了贪心原则</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g[N][N];	<span class="comment">//使用临接矩阵的方式来存储图，g[1][2] = 3，表示从1号点到2号点的边权为3</span></span><br><span class="line"><span class="type">int</span> n, m;	<span class="comment">//n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> dist[N];	<span class="comment">//dist[x]，表示x号点到原点的距离，其在dijkstra中是不断更新的</span></span><br><span class="line"><span class="type">bool</span> st[N];	<span class="comment">//st[x] 表示x点的状态：x点到原点的距离是否确定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);	<span class="comment">//初始化，每个点到原点的距离为 无穷大</span></span><br><span class="line">    </span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;	<span class="comment">//初次迭代，1号点到1号点的距离为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)		<span class="comment">//一共有n个点，需要遍历n次(也可以只遍历n-1次)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;		<span class="comment">//t表示当前走到的点的编号</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)	<span class="comment">//遍历编号为1~n的所有的点</span></span><br><span class="line">            <span class="comment">//if是用来寻找没有走过的点中的边权最小的点</span></span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))	</span><br><span class="line">                t = j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)	<span class="comment">//更新编号为1~n的所有的点到原点的距离 dist[j]</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + g[t][j])		<span class="comment">//需要取最短路径</span></span><br><span class="line">                dist[j] = dist[t] + g[t][j];</span><br><span class="line">                </span><br><span class="line">        st[t] = <span class="literal">true</span>;	<span class="comment">//标记t到原点的距离已经确定</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//若dist[n]没有被改动，则到达不了n这个点</span></span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        g[a][b] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dijkstra</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="堆优化版dijkstra算法">堆优化版dijkstra算法</h5>
<p><strong>优化</strong></p>
<ul>
<li>在朴素版的寻找没有走过的点中的边权最小的点的过程中，每次都需要遍历每一个点，时间复杂度较大</li>
<li>堆优化就是利用小根堆，每次能够快速的找到边权最小的点</li>
<li>使用STL中的priority_queue来优化</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;	<span class="comment">//存储(距离，编号)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[N], ne[N], h[N], w[N], idx;	<span class="comment">//稀疏图用临接表来存储，w[]用来存储边权</span></span><br><span class="line"><span class="type">int</span> dist[N];	</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span>	<span class="comment">//常规的插入操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx, w[idx++] = c;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//默认是大根堆，定义小根堆需要写全</span></span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);	<span class="comment">//dist数组初始化为0x3f3f3f3f</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    heap.<span class="built_in">emplace</span>(<span class="number">0</span>, <span class="number">1</span>);	<span class="comment">//往堆中插入一号点和距离</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())	<span class="comment">//有点像bfs的模板hh</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();	<span class="comment">//取出队头并队头出队</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> id = t.second, d = t.first;	<span class="comment">//id表示队头的编号，d表示队头到原点的距离</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(st[id]) <span class="keyword">continue</span>;	<span class="comment">//t已经确定距离，则跳到下一个点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[id]; i != <span class="number">-1</span>; i = ne[i])	<span class="comment">//更新t点能走到的点到原点的距离</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[id] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[id] + w[i];	<span class="comment">//j点入队</span></span><br><span class="line">                heap.<span class="built_in">emplace</span>(dist[j], j);	<span class="comment">//emplace(a, b) 等价于 push(&#123;a, b&#125;)，前者效率更高</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        st[id] = <span class="literal">true</span>;	<span class="comment">//t点的距离已经确定</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dijkstra</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="有边数限制的最短路问题">有边数限制的最短路问题</h5>
<h6 id="bellman_ford算法">Bellman_ford算法</h6>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;	<span class="comment">//N表示最大顶点数，M表示最大边数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">&#125;edges[M];	<span class="comment">//使用结构体数组来存储图，abc表示 a到b的边权为c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> dist[N], backup[N];	<span class="comment">//backup为dist的备份数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);	<span class="comment">//dist数组初始化为无穷大</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    	</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)	<span class="comment">//k表示 经过不超过k条边使n到1号点的距离最小</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(backup, dist, <span class="keyword">sizeof</span> dist);	<span class="comment">//每次只更新一层的边(一步), 为了防止串联而开的备份数组</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> e = edges[j];</span><br><span class="line">            dist[e.b] = <span class="built_in">min</span>(dist[e.b], backup[e.a] + e.c);	<span class="comment">//注意用的是备份数组 backup[e.a]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        edges[i] = &#123;a, b, c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bellman_ford</span>();</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//不能使用判断条件：dist[n] == 0x3f3f3f3f 因为存在负权边，例如dist[n] = 0x3f3f3f3f - 1; 虽然小于0x3f3f3f3f但该结果仍然表示无解</span></span><br><span class="line">    <span class="keyword">if</span>(dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dist[n]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="队列优化版的bellman_ford算法">队列优化版的Bellman_ford算法</h6>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[M], ne[M], h[N], w[M], idx;	</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx, w[idx++] = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">emplace</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//类似BFS的一个模板，k表示最多经过的边数</span></span><br><span class="line">    <span class="keyword">while</span>(k-- &amp;&amp; q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(n--)	<span class="comment">//类似层序遍历中对当前层的所有节点都进行一个遍历 必须这样做，while循环不能去掉</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> [x, p] = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//遍历所有对头元素所能到的点，更新它们的dist值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j = e[i]; <span class="comment">//i对应的是邻接表的下标，j对应的是节点的编号，p表示上一步操作的dist[x]</span></span><br><span class="line">                <span class="keyword">if</span>(dist[j] &gt; w[i] + p)</span><br><span class="line">                &#123;</span><br><span class="line">                    dist[j] = w[i] + p;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(j, dist[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dist[n]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="spfa算法">spfa算法</h5>
<ul>
<li>Bellman_ford算法每次对每一条边都进行修改，但其中修改不一定都是有效的</li>
<li>spfa算法则是只对修改过的边进行修改，大大提高了效率</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//spfa求最短路</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[N], ne[N], w[N], h[N], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">bool</span> st[N];		<span class="comment">//st数组用来表示当前点是否已经入队</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx, w[idx++] = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];	<span class="comment">//对队头的每一条出边进行更新</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])	<span class="comment">//如果j不在队列中且被修改过，将其入队</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不需要 &gt; 0x3f3f3f3f / 2, 因为spfa不是对每一条边进行修改，只有连通的边才会被修改到</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>() == <span class="number">0x3f3f3f3f</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">spfa</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="spfa判断负环">spfa判断负环</h5>
<ul>
<li><p>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，
边权可能为负数。请你判断图中是否存在负权回路。</p></li>
<li><p>负权回路：一个回路，并且转一圈后的边权之和为负数</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>, M = <span class="number">10010</span>;	<span class="comment">//N为点树，M为边数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> e[M], ne[M], h[N], w[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];	<span class="comment">//cnt[x] 表示走到x点所经过的边数</span></span><br><span class="line"><span class="type">bool</span> st[N];		<span class="comment">//判断点是否已经入队</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx, w[idx++] = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//dist不需要初始化为无穷大：因为dist数组不是存的最短路径，而是用来判断负权边的</span></span><br><span class="line">    <span class="comment">//首先需要将所有点入队，因为负环可能不在从起点到终点的路上</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对队头的出边进行拓展</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果t点上存在负环，则会一直在循环里面转圈</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;	<span class="comment">//到j点的边数 + 1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//t点上没有负环的情况下，cnt[j]是不会超过 n-1 的</span></span><br><span class="line">                <span class="comment">//如果cnt[j]超过了n-1则表示一定存在负环</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//若j没有入队，则将其入队</span></span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>()) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="floyd算法">floyd算法</h5>
<ul>
<li><p>一个基于动态规划原理的算法，用来求任意两点间的最短距离</p></li>
<li><p>d[k, i, j] 表示经过 1~ k 的点从 i 到 j
的最短距离，其无非就两种情况</p>
<ol type="1">
<li>不经过k这个点，从 i 到 j ：d[k-1, i, j]</li>
<li>经过k这个点，从 i 到 j：d[k-1, i, k] + d[k-1, k, j]</li>
</ol></li>
<li><p>由此得出 d[k, i, j] = min( d[k-1, i, j], d[k-1, i, k] + d[k-1, k,
j])</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>, INF = <span class="number">1e9</span>;	<span class="comment">//N表示点数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[N][N];	<span class="comment">//用一个二维数组来边权 d[a][b] = c 表示 a 到 b 的边权为 c</span></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][k] + d[k][j], d[i][j]);	<span class="comment">//这里的d[i][j] 就是d[k-1, i, j]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)	<span class="comment">//为什么不初始化为0x3f3f3f3f?：多源汇最短路问题可能需要求自己到自己的距离</span></span><br><span class="line">            <span class="keyword">if</span>(i == j) d[i][j] = <span class="number">0</span>;		<span class="comment">//d[i][j] = 0目的是干掉自环</span></span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        d[a][b] = <span class="built_in">min</span>(d[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">floyd</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="comment">//floyd算法是对每一条边进行操作，所有是有可能出现 INF - 1 的情况的，所以需要 INF / 2</span></span><br><span class="line">        <span class="keyword">if</span>(d[x][y] &gt; INF / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d[x][y]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最小生成树问题">最小生成树问题</h4>
<p><strong>概念</strong></p>
<ul>
<li>将一个图中的所有节点连接起来，并且使得所有边的边权之和最小</li>
<li>一般只用于无向图</li>
</ul>
<p><strong>实用场景</strong></p>
<ul>
<li>在若干个城市之间铺路，各个路段可以交叉，如何铺路使得铺路成本最小</li>
</ul>
<h5 id="prime算法">prime算法</h5>
<ul>
<li>与Dijkstra算法十分相似，同样也有堆优化的版本</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g[N][N];	<span class="comment">//邻接矩阵存储边</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dist[N];	<span class="comment">//dist[x]表示x到最小树集合的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];		<span class="comment">//st[x]表示x是否已经加入最小树集合中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;	<span class="comment">//挑取第一个点为起点</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;	<span class="comment">//记录最小树的边权之和</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;		<span class="comment">//t表示所有没入集合的点中距离集合最近的点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;	<span class="comment">//筛选t</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dist[t] == INF) <span class="keyword">return</span> INF;	<span class="comment">//如果距离最近的点t到集合的距离都是INF的话说明存在点不与树连通的点，一定不存在最小生成树</span></span><br><span class="line">        </span><br><span class="line">        res += dist[t];	<span class="comment">//边权加到res中</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注意要先更新res，再更新dist[j]，否则会将负的子环边更新到dist[t]中，最终导致加到res中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">            </span><br><span class="line">        st[t] = <span class="literal">true</span>;	<span class="comment">//t入集合</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">prim</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(t == INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="kruskal算法">kruskal算法</h5>
<p><strong>思路</strong></p>
<ul>
<li>先将所有边按照边权从小到大排序</li>
<li>再将所有顶点看做单独一个集合</li>
<li>再根据顺序对每个顶点进行并查集的操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Edge &amp;e) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; e.w; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[N];	<span class="comment">//结构体数组存储边</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, cnt;	<span class="comment">//cnt记录最小生成树中的边数</span></span><br><span class="line"><span class="type">int</span> p[N];	<span class="comment">//p[x] 表示x的祖宗节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>		<span class="comment">//并查集的模板	</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruscal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;	<span class="comment">//记录边权总和</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;	<span class="comment">//p数组的初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);	<span class="comment">//按照边权从小到大对每一条边进行排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)	<span class="comment">//按照顺序对每一条边进行并查集操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);	</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pa != pb)	<span class="comment">//如果两个点不在同一个集合中，则将其加入到同一集合中</span></span><br><span class="line">        &#123;				<span class="comment">//如果两个点在同一个集合中，则跳过</span></span><br><span class="line">            p[pa] = pb;</span><br><span class="line">            res += w;	<span class="comment">//边权相加</span></span><br><span class="line">            cnt++;		<span class="comment">//树的边数+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;	<span class="comment">//连通n个点，需要n-1条边，如果小于n-1 则表明所有点不连通</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        edges[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">kruscal</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(t == INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二分图">二分图</h4>
<p><strong>概念</strong></p>
<ul>
<li>二分图是一类特殊的图，它可以被划分为两个部分，每个部分内的点互不相</li>
<li>二分图的每一条边都是从一个集合指向另一个集合</li>
<li>二分图一定不存在奇数环</li>
</ul>
<h5 id="染色法判断二分图是否存在">染色法判断二分图是否存在</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[M], ne[M], h[N], idx;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> color[N];	<span class="comment">//存储当前点的颜色，值只有1和2两种情况</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span>	<span class="comment">//染色法其实就是一个深度优先遍历的过程，规定如果u节点对应的链表上存在有颜色冲突的节点</span></span></span><br><span class="line"><span class="function"></span>&#123;						<span class="comment">//则返回false，不存在则放回true</span></span><br><span class="line">    color[u] = c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])	<span class="comment">//深搜的一个过程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];	</span><br><span class="line">        <span class="keyword">if</span>(!color[j])	<span class="comment">//如果当前j节点没有染色(全局变量初始化为0),j有可能在其他树中被染过色了</span></span><br><span class="line">        &#123;</span><br><span class="line">           	<span class="comment">//因为颜色只用1和2表示，所有进行下一次染色可以用3-c表示染不同颜色</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(j, <span class="number">3</span> - c)) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//简化了代码 原：bool res = dfs(j, 3 - c);if(res == flase) return false;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果j节点的颜色与当前节点相同，则表示产生了颜色冲突，return false</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;	<span class="comment">//打个标记</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对每一条分支进行遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//i节点没染色才染色，否则不需要 i有可能在其他树中被染过色了</span></span><br><span class="line">        <span class="keyword">if</span>(!color[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(i, <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//只要有一条分支有颜色冲突，其他的不用看了，直接判定不存在二分图</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="匈牙利算法">匈牙利算法</h5>
<p><strong>用途</strong></p>
<ul>
<li>解决二分图的完全匹配的最大个数</li>
</ul>
<p><strong>例题</strong></p>
<ul>
<li>二分图的最大匹配：二分图的两个集合中 [不相同并且存在边] 的点 的数量
最大</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n1, n2, m;</span><br><span class="line"><span class="type">int</span> e[M], ne[M], h[N], idx;</span><br><span class="line"><span class="type">bool</span> st[N];		<span class="comment">//st[]表示女孩有没有被遍历过，如果没有st[]数组标记则会陷入死循环</span></span><br><span class="line"><span class="type">int</span> match[N];	<span class="comment">//match[]表示女孩的约定的男孩</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])	<span class="comment">//对x这个男孩心意的所有女孩进行遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];	<span class="comment">//j表示其中一个女孩</span></span><br><span class="line">        <span class="keyword">if</span>(!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(!match[j] || <span class="built_in">find</span>(match[j]))	<span class="comment">//如果j女孩名花无主或者女孩约定的男孩能找到其他女孩进行匹配</span></span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;	<span class="comment">//则当前女孩与当前男孩约定，则可以返回true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//实在不行就只能返回false了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n1, &amp;n2, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);	<span class="comment">//st是全局数组，每个男孩进行匹配女孩的过程所有女孩都必须先初始化为false</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(i)) res++;	<span class="comment">//男孩匹配成功则结果+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="树的直径">树的直径</h4>
<p><strong>定义</strong></p>
<ul>
<li>树上最远的两个节点之间的距离就被称为树的直径</li>
</ul>
<h5 id="两次dfs求直径">两次dfs求直径</h5>
<ul>
<li>在树上任意取一点 a，找到距离其最远的点 b；再从 b
出发，找到距离其最远的点 c</li>
<li>此时，b 与 c 之间的距离就是树的直径</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="comment">//由于树是双向边：所以需要开两倍的空间</span></span><br><span class="line"><span class="type">int</span> e[N * <span class="number">2</span>], ne[N * <span class="number">2</span>], h[N], w[N * <span class="number">2</span>], idx;</span><br><span class="line"><span class="type">int</span> mxu, mxd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span>	<span class="comment">//邻接表存储图(树)，也叫链式向前星</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx, w[idx++] = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f, <span class="type">int</span> d)</span>	<span class="comment">//u表示当前节点，f表示其父节点，d表示当前已走距离</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//u代表的是真实的节点值，h[u]存的是树中节点的下标，e[]中存储的才是真实的节点值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])	<span class="comment">//遍历u能到的所有点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="type">int</span> v = w[i];	</span><br><span class="line">        <span class="keyword">if</span>(j == f) <span class="keyword">continue</span>;	<span class="comment">//避免死循环，因为是双向边，遇到其父节点需要直接跳过</span></span><br><span class="line">        <span class="keyword">if</span>(v + d &gt; mxd)	<span class="comment">//如果路径距离大于当前的mxd，则更新节点和最大距离值</span></span><br><span class="line">        &#123;</span><br><span class="line">            mxu = j;</span><br><span class="line">            mxd = v + d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(j, u, d + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">        <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    mxd = <span class="number">0</span>;	<span class="comment">//理论上必须重置为0， 但不重置也能ac</span></span><br><span class="line">    <span class="built_in">dfs</span>(mxu, <span class="number">-1</span>, <span class="number">0</span>);	<span class="comment">//在此次dfs完后可以求出树的直径mxd</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//求出树的直径后根据题意输出即可</span></span><br><span class="line">    <span class="comment">//mxd即为树的直径</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, mxd * <span class="number">10</span> + (((<span class="number">1ll</span> + mxd) * mxd) &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="树形dp求直径">树形dp求直径</h5>
<ul>
<li>将任意一个节点作为根节点出发，依次找出该节点往下走的最长路径和次最长路径，分别用
d1、d2 来表示</li>
<li>树的直径则是所有节点的 d1 + d2 的最大值</li>
<li>如何判断一个节点是否在树的直径上，只需要看 d1[u]、d2[u]、up[u]
中两数之和的最大值是否等于树的直径即可</li>
<li>d1[u] 表示以当前节点 u 为根节点往下走的最长路径, d2[u]
表示以当前节点 u 为根节点往下走的次最长路径，up[u] 表示以当前节点 u
为根节点往上走的最长路径</li>
<li>拓展：求树的直径上的所有节点 <a
target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1080/">传送门</a></li>
</ul>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = N * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> e[M], ne[M], h[N], w[M], idx;</span><br><span class="line"><span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx, w[idx++] = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fu)</span>	<span class="comment">//求以u为根节点，往下走的最长路径，返回值是最长路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> d1 = <span class="number">0</span>, d2 = <span class="number">0</span>;	<span class="comment">//d1为最长路径，d2为次最长路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j == fu) <span class="keyword">continue</span>;	<span class="comment">//避免走回头路</span></span><br><span class="line">        <span class="comment">//dfs(j, u)返回的是子节点j往下走的最长路径，加上当前边长w[i]，即有可能成为u节点往下走的最长路径</span></span><br><span class="line">        <span class="type">int</span> dist = <span class="built_in">dfs</span>(j, u) + w[i];	</span><br><span class="line">        <span class="keyword">if</span>(dist &gt; d1) d2 = d1, d1 = dist;	<span class="comment">//如果dist大于当前d1,则更新d1，同时更新d2</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dist &gt; d2) d2 = dist;	<span class="comment">//如果dist不大于d1但大于d2，则更新d2</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    res = <span class="built_in">max</span>(res, d1 + d2);	<span class="comment">//更新完d1，d2后需要将其和与res更新</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> d1;	<span class="comment">//返回最长路径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">        <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);	<span class="comment">//res即为树的直径</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="树的重心">树的重心</h4>
<p><strong>重心的定义</strong></p>
<ul>
<li>重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中，节点数的最大值最小，那么这个节点被称为树的重心</li>
</ul>
<p><strong>问题描述</strong></p>
<ol type="1">
<li>求树的重心是哪个节点</li>
<li>求将重心删除后，剩余各个连通块中，节点数的最大值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一次搞定两个要求</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = N * <span class="number">2</span>;  <span class="comment">//注意双向边，开两倍</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, a, b, ans = N;</span><br><span class="line"><span class="type">int</span> mid;</span><br><span class="line"><span class="type">int</span> e[M], ne[M], h[N], idx;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//sum表示以当前节点为根节点的联通块的节点数量，初始为1</span></span><br><span class="line">    <span class="comment">//res表示删除当前节点后，以其子节点为根节点的联通块的数量的最大值</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(st[j]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> s = <span class="built_in">dfs</span>(j);</span><br><span class="line">        sum += s;</span><br><span class="line">        res = <span class="built_in">max</span>(res, s);	<span class="comment">//取删除后子联通块的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除后还会形成一个联通块，就是u的父节点形成的联通块，其数量为 n - sum</span></span><br><span class="line">    res = <span class="built_in">max</span>(res, n - sum);	</span><br><span class="line">    <span class="comment">//在求联通块的最大</span></span><br><span class="line">    <span class="keyword">if</span>(res &lt; ans || (res == ans) &amp;&amp; mid &gt; u)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = res;	<span class="comment">//树的重心的定义：联通块的最大值的最小，因此取最小值</span></span><br><span class="line">        mid = u;	<span class="comment">//记录重心点，若存在两个，则取编号最小的那个</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">        <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//本来是无根树，现在将其变为以1为根节点的有根树</span></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, ans, mid);  <span class="comment">//输出最大数量以及重心</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/" rel="tag"># 搜索与图论</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/374e1302/" rel="prev" title="数学知识">
                  <i class="fa fa-angle-left"></i> 数学知识
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/a80d0031/" rel="next" title="动态规划">
                  动态规划 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">sabersnt</span>
  </div>

    </div>
  </footer>

  

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
