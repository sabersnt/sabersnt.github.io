<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/red-32x32.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/red-16x16.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"在这里输入你要搜索的内容","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="闫式dp法、背包问题、线性dp、区间dp、计数类dp、状态压缩dp、树型dp、记忆化搜索">
<meta property="og:type" content="article">
<meta property="og:title" content="动态规划">
<meta property="og:url" content="http://example.com/posts/a80d0031/index.html">
<meta property="og:site_name" content="Alcatraz Island">
<meta property="og:description" content="闫式dp法、背包问题、线性dp、区间dp、计数类dp、状态压缩dp、树型dp、记忆化搜索">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/dp%E6%80%9D%E8%B7%AF.png">
<meta property="article:published_time" content="2023-11-05T14:41:14.509Z">
<meta property="article:modified_time" content="2023-12-08T01:04:57.926Z">
<meta property="article:author" content="sabersnt">
<meta property="article:tag" content="动态规划">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/dp%E6%80%9D%E8%B7%AF.png">


<link rel="canonical" href="http://example.com/posts/a80d0031/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/posts/a80d0031/","path":"posts/a80d0031/","title":"动态规划"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>动态规划 | Alcatraz Island</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Alcatraz Island</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="在这里输入你要搜索的内容" spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="nav-text">动态规划的基本思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-text">背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-1"><span class="nav-text">01背包问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-text">完全背包问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-text">多重背包问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98ii"><span class="nav-text">多重背包问题II</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-text">分组背包问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%B0%8F%E7%BB%93"><span class="nav-text">背包问题的小结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7dp"><span class="nav-text">线性DP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="nav-text">数字三角形</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text">最长上升子序列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97-ii"><span class="nav-text">最长上升子序列 II</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text">最长公共子序列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="nav-text">最短编辑距离</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4dp"><span class="nav-text">区间DP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6"><span class="nav-text">石子合并</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E7%B1%BBdp"><span class="nav-text">计数类DP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%9A%84%E5%88%92%E5%88%86"><span class="nav-text">数的划分</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp"><span class="nav-text">状态压缩DP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%92%99%E5%BE%B7%E9%87%8C%E5%AE%89%E7%9A%84%E6%A2%A6%E6%83%B3"><span class="nav-text">蒙德里安的梦想</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E7%9F%ADhamilton%E8%B7%AF%E5%BE%84"><span class="nav-text">最短Hamilton路径</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E5%BD%A2dp"><span class="nav-text">树形DP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A"><span class="nav-text">没有上司的舞会</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2"><span class="nav-text">记忆化搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%BB%91%E9%9B%AA"><span class="nav-text">滑雪</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="sabersnt"
      src="/images/ygyt.png">
  <p class="site-author-name" itemprop="name">sabersnt</p>
  <div class="site-description" itemprop="description">莫听穿林打叶声，何妨吟啸且徐行</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/a80d0031/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ygyt.png">
      <meta itemprop="name" content="sabersnt">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alcatraz Island">
      <meta itemprop="description" content="莫听穿林打叶声，何妨吟啸且徐行">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="动态规划 | Alcatraz Island">
      <meta itemprop="description" content="闫式dp法、背包问题、线性dp、区间dp、计数类dp、状态压缩dp、树型dp、记忆化搜索">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          动态规划
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-05 22:41:14" itemprop="dateCreated datePublished" datetime="2023-11-05T22:41:14+08:00">2023-11-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-12-08 09:04:57" itemprop="dateModified" datetime="2023-12-08T09:04:57+08:00">2023-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">闫式dp法、背包问题、线性dp、区间dp、计数类dp、状态压缩dp、树型dp、记忆化搜索</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h4 id="动态规划的基本思路">动态规划的基本思路</h4>
<p><img src="/images/dp思路.png" /></p>
<h4 id="背包问题">背包问题</h4>
<h5 id="背包问题-1">01背包问题</h5>
<p><strong>概述</strong></p>
<ul>
<li>n件物品，背包体积为m，每件物品只能被拿一次或者不拿，求背包能装物品的最大价值是多少</li>
<li>用f[i][j]表示从编号为1~i的物品中拿，物品的总体积最大为j，的最大价值</li>
</ul>
<p><strong>状态计算</strong></p>
<ul>
<li>f [i][j] = max (f[i-1][j]，f[i-1][j-v[i]] + w[i])</li>
</ul>
<p><strong>优化</strong></p>
<ul>
<li>由于 i 只与 i-1 有关，所以可以将 i
作外层循环来计算，但是必须从大到小开始更新</li>
<li>因为，j - v[i] &lt; j，所以在到 f[j]之前 f [j - v[i]]
已经被更新过了，但我们需要的是未更新之前的值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化前的代码：二维数组</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= v[i]) </span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化后的代码：一维数组</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v[i]; j--)  <span class="comment">//注意是循环到v[i]就结束</span></span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">            </span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="完全背包问题">完全背包问题</h5>
<p><strong>概述</strong></p>
<ul>
<li>基本条件与01背包问题一致，只是每个物品可以不拿或者拿无限个(不超过背包容量)</li>
</ul>
<p><strong>状态计算</strong></p>
<ul>
<li><p>f [i][j] = max (f[i-1][j-k*v[i]] + w[i])</p></li>
<li><p>g[i][j]集合能被分为若干个部分，即拿 0 个 i 物品，1个 i
物品，...，k个 i 物品</p></li>
<li><p>因此f[i][j] 就为这些若干个部分的价值的最大值</p></li>
</ul>
<p><strong>优化</strong></p>
<ul>
<li>已知：f[i][j] = max (f[i-1][j]，f[i-1][j-v] + w，f [i-1][j-2 * v] +
2 * w，...)</li>
<li>令 j = j - v，则有：f[i][j-v] = max (f[i-1][j-v]，f[i-1][j-2*v] +
w，f[i-1][j-3*v] + 2*w, ...)</li>
<li>可以发现：f[i][j] = max(f[i-1][j]，f[i][j-v] + w)</li>
<li>其可以变换为与k无关的式子</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">        	<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k * v[i] &lt;= j; k++)</span><br><span class="line">                <span class="comment">//f[i][j]初始化为0，所以可以在max中与自己比</span></span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j - k * v[i]] + k * w[i]);</span><br><span class="line">           </span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化版本：去k版</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(v[i] &lt;= j)	<span class="comment">//第 i 种能放进去，</span></span><br><span class="line">            	f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j], f[i][j-v[i]] + w[i]);</span><br><span class="line">            <span class="keyword">else</span>			<span class="comment">//如果第 i 件物品不能放进去</span></span><br><span class="line">                f[i][j] = f[i<span class="number">-1</span>][j];	<span class="comment">//拿i的集合不一定存在</span></span><br><span class="line">        &#125;</span><br><span class="line">             </span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化版本：去k版 + 一维</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	在之前的去k版的优化中可以看到最终代码与01背包问题十分相似，因此在完全背包中也可以降为一维</span></span><br><span class="line"><span class="comment">	由于完全背包问题中使用的是第i层的状态而非i-1层的状态，所以不能从大到小更新，必须从小大更新</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i&lt;=n ;i++)</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> j = v[i] ; j &lt;= m ;j ++)</span><br><span class="line">        	f[j] = <span class="built_in">max</span>(f[j], f[j-v[i]] + w[i]);	<span class="comment">//必须从小大更新</span></span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="多重背包问题">多重背包问题</h5>
<p><strong>题目</strong></p>
<ul>
<li>n 个物品，每个物品最多有 s<sub>i</sub>
件，s的值可能相同也可能不相同</li>
<li>时间复杂度：O(n * m * k)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;	</span><br><span class="line"><span class="type">int</span> v[N], w[N], s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="comment">//无优化版本：二维版本</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;v[i], &amp;w[i], &amp;s[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;   f[i][j] = f[i - <span class="number">1</span>][j];	<span class="comment">//下面的拿k个的集合不一定存在</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i]; k++)</span><br><span class="line">                    <span class="keyword">if</span>(k * v[i] &lt;= j) </span><br><span class="line">                        f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i]); </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n][m]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化成一维：类似01背包问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> v[N], w[N], s[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;v[i], &amp;w[i], &amp;s[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--)	<span class="comment">//因为用到的是上一层的数据，所以需要从大到小遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i]; k++)</span><br><span class="line">                <span class="keyword">if</span>(k * v[i] &lt;= j) </span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j], f[j - k * v[i]] + k * w[i]); </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[m]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="多重背包问题ii">多重背包问题II</h5>
<p><strong>题目</strong></p>
<ul>
<li>s的数据范围比较大，用上面一种方法会超时</li>
<li>使用二进制优化法对算法进行优化</li>
<li>核心思想：任意一个数 x 可以由 1, 2, 4, 8, ... , 2<sup>k</sup>, c
这些数字组合相加而成，其中 c = x - (1 + 2 + 4 + 8 +...+
2<sup>k</sup>)</li>
<li>当n比较大时，我们就可以让 1, 2, 4, 8, ... , 2<sup>k</sup>, c
这些数字相加来表示 n，从而转化为01背包问题</li>
<li>例如：要求在一堆苹果选出n个苹果。我们传统的思维是一个一个地去选，选够n个苹果就停止。这样选择的次数就是n次
现在给出一堆苹果和10个箱子，选出n个苹果。将这一堆苹果分别按照1,2,4,8,16,.....512分到10个箱子里，那么由于任何一个数字x∈[0,1023]都可以从这10个箱子里的苹果数量表示出来，但是这样选择的次数就是
≤10次</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">11010</span>, M = <span class="number">2010</span>;	<span class="comment">//注意开辟空间，每个s最多被分为log(s)个箱子，所以小箱子的总数为n*log(s)</span></span><br><span class="line"><span class="type">int</span> v[N], w[N];					<span class="comment">//=1000 * log(2000) ≈ 11000</span></span><br><span class="line"><span class="type">int</span> f[M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;	</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)		<span class="comment">//相当于把原来的一个大箱子(每一个s都相当于一个大箱子)分成了多个小箱子，大箱子中的任意个数可以由小箱子中的数组合而成，从而转换成小箱子选哪些的问题</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b, s;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;s);	</span><br><span class="line">            <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(k &lt;= s)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                v[cnt] = a * k, w[cnt] = b * k;	<span class="comment">//第cnt堆的总体积为 a*k, 总价值为 a * k </span></span><br><span class="line">                s -= k;</span><br><span class="line">                k *= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s &gt; <span class="number">0</span>)	<span class="comment">//因为在前面每次s将k的值减去，因此若 s &gt; 0则表示其就为拆分的最后一个常数</span></span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                v[cnt] = a * s, w[cnt] = b * s;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;	</span><br><span class="line">    </span><br><span class="line">    n = cnt;	<span class="comment">//更新完后，v[]的大小变成cnt了</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//01背包问题的板子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v[i]; j--)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[m]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="分组背包问题">分组背包问题</h5>
<p><strong>题目</strong></p>
<ul>
<li>每组物品有若干个，同一组内的物品最多只能选一个，每组内的每件物品的体积和价值可能相同也可能不同</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二维版本</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="type">int</span> v[N][N], w[N][N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s[i]; j++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;v[i][j], &amp;w[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;   f[i][j] = f[i<span class="number">-1</span>][j];	<span class="comment">//下面情况所属的集合不一定存在</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i]; k++)</span><br><span class="line">                <span class="keyword">if</span>(v[i][k] &lt;= j) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j-v[i][k]] + w[i][k]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n][m]);	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化：一维版本</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="type">int</span> f[N], v[N][N], w[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s[i]; j++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;v[i][j], &amp;w[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--)	<span class="comment">//使用上一层的数据，需要从大到小更新</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i]; k++)</span><br><span class="line">                <span class="keyword">if</span>(v[i][k] &lt;= j)</span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[m]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="背包问题的小结">背包问题的小结</h5>
<ul>
<li><p>状态表示</p>
<ol type="1">
<li>01背包问题：<span
class="math inline">\(f[i][j]表示从前i个物品中挑选物品，总体积不超过j\)</span></li>
<li>完全背包问题和多重背包问题的状态表示与01背包问题一致</li>
<li>分组背包问题：<span
class="math inline">\(f[i][j]表示从前i组物品中挑选物品，总体积不超过j\)</span></li>
</ol></li>
<li><p>状态计算</p>
<ol type="1">
<li>01背包问题：<span
class="math inline">\(f[i][j]=max(f[i-1][j],f[i-1][j-v[i]])\)</span>，表示拿与不拿第i个物品</li>
<li>完全背包问题：<span
class="math inline">\(f[i][j]=max(f[i-1][j-k*v]+w)\)</span>，表示第 i
个物品拿多少个用k来表示</li>
<li>分组背包问题：<span
class="math inline">\(f[i][j]=max(f[i-1][j],f[i-1][j-k*v]+w)\)</span>，表示第
i 组中的物品拿哪一个，或者不拿第 i 组中的物品</li>
</ol></li>
<li><p>优化</p>
<ol type="1">
<li><p>降低维度</p></li>
<li><p>看利用的是上一层的数据还是同层的数据，上一层则从大到小更新；同层则从小到大更新</p></li>
</ol></li>
</ul>
<h4 id="线性dp">线性DP</h4>
<h5 id="数字三角形">数字三角形</h5>
<p><strong>题目</strong></p>
<ul>
<li>给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大</li>
</ul>
<p>​ 7</p>
<p>​ 3 8</p>
<p>8 1 8</p>
<p><strong>集合表示</strong></p>
<ul>
<li>f(i, j) 表示到点 (i,j) 的所有路径</li>
<li>f[i][j] 表示到点 (i,j) 的所有路径的中最大的数值和</li>
</ul>
<p><strong>集合划分</strong></p>
<ul>
<li><p>按照上一个点是谁来划分</p></li>
<li><p>f[i][j] = max(f[i-1][j-1], f[i-1][j]) + a[i][j]</p></li>
<li><p>每个点可以从其左上和右上的点走到，两条路径中最大数值和+点 (i, j)
的值就为最大数值和</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][N], a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="comment">//数字金字塔的读入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理边界问题，位于金字塔边缘的点可能会向上访问到f数组的边界        </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n + <span class="number">1</span>; j++)</span><br><span class="line">            f[i][j] = -INF;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先把一开始就能知道的值先赋上</span></span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从第2行开始，进行状态转移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            <span class="comment">//每次左上与右上两个点进行比较</span></span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j], f[i<span class="number">-1</span>][j<span class="number">-1</span>]) + a[i][j];</span><br><span class="line">            </span><br><span class="line">    <span class="type">int</span> res = -INF;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//要使数值和最大，则一定会到达最后一层的点，但不知道是哪一个点，所以对最后一层的点遍历取得最终答案</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res = <span class="built_in">max</span>(res, f[n][i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最长上升子序列">最长上升子序列</h5>
<p><strong>题目</strong></p>
<ul>
<li>给定一个长度为 N
的数列，求数值严格单调递增的子序列的长度最长是多少。</li>
<li><span class="math inline">\(1\le N\le 1000\)</span></li>
</ul>
<p><strong>集合表示</strong></p>
<ul>
<li>f(i) 表示以 i 结尾子序列</li>
<li>f[i] 表示以 i 结尾的子序列中的长度最大值</li>
</ul>
<p><strong>集合划分</strong></p>
<ul>
<li>依据子序列中第 i -1 个数是多少来划分</li>
<li>f[i] = max{ f[1], f[2], ... , f[i-1] }</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N], a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="comment">//数据的读入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//枚举每一个点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            <span class="comment">//a[i] &gt; a[j]时，a[i]才能接在a[j]的后面</span></span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[j])</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最长上升子序列-ii">最长上升子序列 II</h5>
<p><strong>题目</strong></p>
<ul>
<li>给定一个长度为 N
的数列，求数值严格单调递增的子序列的长度最长是多少。</li>
<li><span class="math inline">\(1\le N\le 100000\)</span></li>
</ul>
<p><strong>思路</strong></p>
<ul>
<li>由于数据范围比较大，所以用贪心+二分来做</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], q[N];	<span class="comment">//q数组中存放的就是最大上升子序列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;	<span class="comment">//表示q数组的长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line">        <span class="comment">//利用二分，从q数组中找到小于a[i]的最大的数</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(q[mid] &lt; a[i]) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//r + 1 表示加上a[i]后的q数组的长度，需要与原来长度取个最大值</span></span><br><span class="line">        len = <span class="built_in">max</span>(len, r + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将a[i]插入到q数组的末尾，注意q数组的下标是从1开始的</span></span><br><span class="line">        q[r + <span class="number">1</span>] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出q数组的长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, len);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最长公共子序列">最长公共子序列</h5>
<p><strong>题目</strong></p>
<ul>
<li>给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B
的子序列的字符串长度最长是多少</li>
</ul>
<p><strong>集合表示</strong></p>
<ul>
<li>f(i)(j) 表示既在 A 的前 i 个字母中，又在 B 的前 j
个字母中的字符串</li>
<li>f[i][j] 表示集合中的字符串的最大长度</li>
</ul>
<p><strong>集合划分</strong></p>
<ul>
<li>依据是否包含 A 的第 i 个字符以及是否包含 B 的第 j 个字符来划分</li>
<li>0表示不包含，1表示包含：则有 00， 01，10，11</li>
<li>对应的状态为：f[i-1][j- 1]、f[i-1][j]、f[i][j-1]、f[i-1][j-1] +
1</li>
<li>01,10对应的状态不一定等价于 f[i-1][j]、f[i][j-1]
但其一定包含在其中，但我们要求的是最大值，所以可以重复计算</li>
<li>11的状态不一定存在，只有当 a[i] == b[j]
时，才成立，而f[i-1][j-1]又包含在f[i-1][j]、f[i][j-1]状态中，因此只需要计算三种状态即可</li>
<li>f[i][j] = max{ f[i-1][j]、f[i][j-1]、f[i-1][j-1] + 1 }</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="comment">//因为涉及到i-1和j-1，所以从1开始读取字符串</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j], f[i][j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j])	<span class="comment">//最后一种情况只有当a[i]==b[j]的时候才成立</span></span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n][m]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最短编辑距离">最短编辑距离</h5>
<p><strong>题目</strong></p>
<ul>
<li><p>给定两个字符串 A 和 B，现在要将 A 经过若干操作变为
B，可进行的操作有：</p>
<ul>
<li>删除–将字符串 A 中的某个字符删除。</li>
<li>插入–在字符串 A 的某个位置插入某个字符。</li>
<li>替换–将字符串 A 中的某个字符替换为另一个字符。</li>
</ul>
<p>现在请你求出，将 A 变为 B 至少需要进行多少次操作。</p></li>
</ul>
<p><strong>集合表示</strong></p>
<ul>
<li>f (i)(j) 表示由 a[1~i] 转变成 b [1~i] 所需要的编辑步数</li>
<li>f [i][j] 表示由 a[1~i] 转变成 b [1~i] 所需要的最小编辑步数</li>
</ul>
<p><strong>集合划分</strong></p>
<ul>
<li><p>依据每次对最后一个字符的操作方式进行划分(增、删、改)</p></li>
<li><p>属性：min：最小值</p></li>
<li><p>增：f [i][j-1] + 1，先将a[1 ~ i] 变成 b[1 ~
j-1]，再在末尾添加一个字符就变成了b[j]</p></li>
<li><p>删：f[i-1][j] + 1，由a[1 ~ i-1] 变成
b[j]，再将a的末尾删除一个字符得到</p></li>
<li><p>改：f[i-1][j-1] + (a[i] != b [j])，由a[1 ~ i-1] 变成 b[j -
1]，如果最后一个字符相同，则不用修改；不同则需要修改</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s%d%s&quot;</span>, &amp;n, a + <span class="number">1</span>, &amp;m, b + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) f[<span class="number">0</span>][i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i<span class="number">-1</span>][j] + <span class="number">1</span>, f[i][j<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i][j], f[i<span class="number">-1</span>][j<span class="number">-1</span>] + (a[i] != b[j]));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n][m]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="区间dp">区间DP</h4>
<h5 id="石子合并">石子合并</h5>
<p>力扣原题：<a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-cost-to-merge-stones/">合并石头的最低成本</a></p>
<p><strong>题目</strong></p>
<ul>
<li>设有 N 堆石子排成一排，其编号为
1,2,3,…,N1,2,3,…,。每堆石子有一定的质量，可以用一个整数来描述，现在要将这
N
堆石子合并成为一堆。每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。例如有
44 堆石子分别为 <code>1 3 5 2</code>， 我们可以先合并 1、21、2
堆，代价为 44，得到 <code>4 5 2</code>， 又合并 1、21、2 堆，代价为
99，得到 <code>9 2</code> ，再合并得到 1111，总代价为
4+9+11=244+9+11=24；如果第二步是先合并 2、32、3 堆，则代价为 77，得到
<code>4 7</code>，最后一次合并代价为 1111，总代价为
4+7+11=224+7+11=22。问题是：找出一种合理的方法，使总的代价最小，输出最小代价。</li>
</ul>
<p><strong>集合表示</strong></p>
<ul>
<li>f(i)(j) 表示将第 i 堆石子到第 j 堆石子合并成一堆的所有方法</li>
<li>f[i][j] 表示将第 i 堆石子到第 j
堆石子合并成一堆所需要的最小代价</li>
</ul>
<p><strong>集合划分</strong></p>
<ul>
<li><p>区间dp的集合划分一般是以区间的边界来划分</p></li>
<li><p>以左边石堆的边界划分：先将 i ~ j 堆石子分成两堆 —— f[i][k] 和
f[k+1][j] , (i &lt;= k &lt; j)，最后再加上这两堆石子的总重量即是 合并第
i 到 j 堆石子的总重量</p></li>
<li><p>f [i][j] = min{ f[i][j], f[i][k] + f[k+1][j] + s[j] - s[i -
1]}</p></li>
<li><p>其中s[j] - s[i-1]表示第 i 堆石子到第 j 堆石子的总重量</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">        s[i] += s[i<span class="number">-1</span>];	<span class="comment">//读入数据的同时，求出所有前缀和</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);	<span class="comment">//因为求的是最小值，首先进行一个初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; len++) <span class="comment">//从长度开始遍历，因为再进行状态转移的过程中，所用到的都是已计算过的状态，因此必须依据长度开始遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++)	<span class="comment">//i表示的是左边界</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = i + len - <span class="number">1</span>;	<span class="comment">//j表示在长度	为len的情况下的右边界</span></span><br><span class="line">            <span class="keyword">if</span>(len == <span class="number">1</span>)	<span class="comment">//当len == 1 时，i = j，合并成一堆的代价为0</span></span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt; j; k++)	<span class="comment">//状态转移方程，i &lt;= k &lt; j</span></span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i][j], f[i][k] + f[k+<span class="number">1</span>][j] + s[j] - s[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[<span class="number">1</span>][n]);	<span class="comment">//f[1][n]表示将1~n堆的石子合并</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="计数类dp">计数类DP</h4>
<h5 id="数的划分">数的划分</h5>
<p><strong>题目</strong></p>
<ul>
<li>一个正整数 n 可以表示成若干个正整数之和，形如：n = n1+n2+…+nk = 1 +
2 + … + nk，其中 n1 ≥ n2 ≥ … ≥ nk, k &gt;=
1。我们将这样的一种表示称为正整数 n 的一种划分。现在给定一个正整数
n，请你求出 n 共有多少种不同的划分方法。</li>
<li>由于答案可能很大，输出结果请对 109+7109+7 取模。</li>
</ul>
<p><strong>集合表示</strong></p>
<ul>
<li>f[i][j] 表示从1 ~ i 中选，且总和等于 j 的方案总数</li>
<li>和完全背包非常相似，只是背包的体积必须为 j</li>
</ul>
<p><strong>集合划分</strong></p>
<ul>
<li><p>依据选或不选数字 i 来划分，f[i][j]的方案数等于所有 选
0个i，1个i，2个i ... 的方案总数全部相加</p></li>
<li><p>f[i][j] = f[i-1][j] + f[i-1][j-i] + f[i-1][j-2i] + ...</p></li>
<li><p>f[i][j-i] = f[i-1][j-i] + f[i-1][j-2i] + ...</p></li>
<li><p>f[i][j] = f[i-1][j] + f[i][j-i]</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二维版本</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从1~i中选择数，且总和为0，只有一种方法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;    </span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j] % mod;	<span class="comment">//选0个i</span></span><br><span class="line">            <span class="keyword">if</span>(j &gt;= i)	<span class="comment">//j - i的集合不一定存在，当j &gt;= i的时候才存在</span></span><br><span class="line">                f[i][j] = (f[i<span class="number">-1</span>][j] + f[i][j-i]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n][n]);	<span class="comment">//从1~n中选，使总和恰好为n的方案总数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一维版本</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= n; j++)    </span><br><span class="line">            <span class="keyword">if</span>(j &gt;= i)</span><br><span class="line">                f[j] = (f[j] + f[j-i]) % mod;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="状态压缩dp">状态压缩DP</h4>
<h5 id="蒙德里安的梦想">蒙德里安的梦想</h5>
<p><strong>题目</strong></p>
<ul>
<li>求把 N × M 的棋盘分割成若干个 1×2 的长方形，有多少种方案。</li>
</ul>
<p><strong>集合表示</strong></p>
<ul>
<li><p>思路：先考虑放横着的方块，再用竖着的方块填充每一列</p></li>
<li><p>这就要求，每一列中连续空着的方块必须是偶数个，且第 i - 1
列不能伸到第 i 列的 1 的位置</p></li>
<li><p>f (i)(j)表示从第 i - 1 列伸出到第 i 列状态为 j 的方案数</p></li>
<li><p>j 的情况一共有 1 &lt;&lt; 列 种，表示
1表示当前行伸出，0则表示没有伸出</p></li>
</ul>
<p><strong>集合划分</strong></p>
<ul>
<li>由于第 i 列怎么摆放的已经由 f[i][j]中的 j 决定了，所以只需要确定第
i-1 列之前的是怎么摆的就行了</li>
<li>f[i][j] = f[i][j] + f[i-1][k]</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化版本，预处理法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12</span>, M = <span class="number">1</span> &lt;&lt; N;	<span class="comment">//N表示列数，M表示每一列的伸出情况</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[N][M];	<span class="comment">//方案数可能很大，所以用long long 来存</span></span><br><span class="line"><span class="type">bool</span> st[M];	<span class="comment">//表示当前列的状态的连续0的个数是否为偶数个</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; state[M];	<span class="comment">//记录第i行中的状态可以由哪些状态合法地转移过来：两行不冲突，且连续0的个数要为偶数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m, n || m)	<span class="comment">//连续读入多个询问</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++)	<span class="comment">//预处理st数组：枚举每一个状态</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;	<span class="comment">//记录连续0的个数</span></span><br><span class="line">            <span class="type">bool</span> is_valid = <span class="literal">true</span>;	<span class="comment">//判断标记</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)	<span class="comment">//遍历i的每一位，一共有n位</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>)	<span class="comment">//如果当前位上为1</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>)	<span class="comment">//0的个数为奇数</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        is_valid = <span class="literal">false</span>;	<span class="comment">//直接判定为false</span></span><br><span class="line">                        <span class="keyword">break</span>;	<span class="comment">//退出循环，不用在判断后面的位数了</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    cnt = <span class="number">0</span>;	<span class="comment">//cnt为偶数，则重新计算第j位后面的0的个数</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> cnt++;	<span class="comment">//否则的话cnt++</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>) is_valid = <span class="literal">false</span>;	<span class="comment">//如果j后面的0的个数为奇数，判断也是为false</span></span><br><span class="line">            st[i] = is_valid;	<span class="comment">//最终处理st[i]，表示i状态是否合法</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//预处理哪些状态能被成功转移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//有多组数据，但是只有一个数组，所以每次操作前需要对其清空</span></span><br><span class="line">            state[i].<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span>((i &amp; j) == <span class="number">0</span> &amp;&amp; st[i | j])	<span class="comment">// (i &amp; j) == 0 表示第i-1列伸出到第i后会不会与其发生冲突</span></span><br><span class="line">                    state[i].<span class="built_in">push_back</span>(j);		<span class="comment">//st[i | j] 表示第i-1列伸出后是否合法</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//有多组数据，但是只有一个数组，所以每次操作前需要对其清空</span></span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;	<span class="comment">//从第0列的前一行没有伸出到第0列的方案总数为1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//DP过程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)	<span class="comment">//枚举每一列，列数是从(0,m-1)因为厦门用到了i-1所以从1开始枚举</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; j++)	<span class="comment">//枚举每一列的状态</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> k : state[j])	<span class="comment">//枚举每一列可以由前一列的哪些状态转移过来，将他们全部相加即可</span></span><br><span class="line">                    f[i][j] += f[i<span class="number">-1</span>][k];</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; f[m][<span class="number">0</span>] &lt;&lt; endl;	<span class="comment">//f[m][0]表示从m-1列伸出到m列的块数为0，即所有棋盘划分完毕的状态</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最短hamilton路径">最短Hamilton路径</h5>
<p><strong>题目</strong></p>
<ul>
<li>给定一张 n 个点的带权无向图，点从 0∼n−1 标号，求起点 0 到终点 n−1
的最短 Hamilton 路径。Hamilton 路径的定义是从 0到 n−1
不重不漏地经过每个点恰好一次。</li>
</ul>
<p><strong>集合表示</strong></p>
<ul>
<li><p>f(i)(j) 表示当前路径为 i，最后的落脚点为 j 的路径长度，其中 i
用二进制数来表示，0 表示不走当前点，1表示走当前点</p></li>
<li><p>f[i][j] 表示当前路径为 i，最后的落脚点为 j
的最短路径长度</p></li>
</ul>
<p><strong>集合划分</strong></p>
<ul>
<li><p>i 中的任何一个点都可以由 i 中其他的点 k 走到，可以先从起点走到
k，再从 k 走到终点</p></li>
<li><p>f[i][j] = min(f[i][j], f[i-(1 &lt;&lt; j)][k] +
map[k][j])</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[M][N];	</span><br><span class="line"><span class="type">int</span> a[N][N];	<span class="comment">//存储地图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);	<span class="comment">//读入地图</span></span><br><span class="line">            </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);	<span class="comment">//求最小值，先初始化为无穷大</span></span><br><span class="line">    </span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;	<span class="comment">//从0点出发到0的路径为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++)	<span class="comment">//枚举每一个路径</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)	<span class="comment">//枚举路径中的每个点</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>)	<span class="comment">//如果j点包含在路径i中，则先走到其他点k</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)	</span><br><span class="line">                    <span class="keyword">if</span>(i &gt;&gt; k &amp; <span class="number">1</span>)	<span class="comment">//如果k包含在路径中，则先走到k，再走到j</span></span><br><span class="line">                        f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - (<span class="number">1</span> &lt;&lt; j)][k] + a[k][j]);</span><br><span class="line">    								<span class="comment">//f[i - (1 &lt;&lt; j)][k]表示新路径中不包括j这个点</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n - <span class="number">1</span>]);	<span class="comment">//f[(1 &lt;&lt; n) - 1][n - 1]表示所有点走走过(每一位均为1)，终点为n-1的最短路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="树形dp">树形DP</h4>
<h5 id="没有上司的舞会">没有上司的舞会</h5>
<p><strong>题目</strong></p>
<ul>
<li>Ural 大学有 N 名职员，编号为
1∼N。他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。每个职员有一个快乐指数，用整数
Hi 给出，其中
1≤i≤N。现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。</li>
</ul>
<p><strong>集合表示</strong></p>
<ul>
<li>f(i)(1) 表示以 i 为根节点，且 i 去的 happy 最大值</li>
<li>f(i)(0) 表示以 i 为根节点，且 i 不去的 happy 最大值</li>
</ul>
<p><strong>集合划分</strong></p>
<ul>
<li>f(i)(1) 表示上司去，则其子节点下属一定不能去 因此 f[i][1] = happy[i]
+ 其所有子节点 j 的 f[j][0]</li>
<li>f(i)(0) 表示上司不去，则其子节点下属可去可不去 因此 f[i][0] =
所有子节点 j 的max(f[j][0], f[j][1])</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> happy[N];	<span class="comment">//表示每个职员的快乐指数</span></span><br><span class="line"><span class="type">int</span> e[N], ne[N], h[N], idx;	<span class="comment">//存储树</span></span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>];	<span class="comment">//存储每一颗树的去或不去的最大值</span></span><br><span class="line"><span class="type">int</span> hf[N];	<span class="comment">//判断每个员工是否有父节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[u][<span class="number">1</span>] = happy[u];	<span class="comment">//f[u][1]在开始前先加上自己的快乐指数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])	<span class="comment">//遍历根节点的每一个子节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j);	<span class="comment">//先计算子节点的f[j][0] 和 f[j][1]</span></span><br><span class="line">        f[u][<span class="number">1</span>] += f[j][<span class="number">0</span>];		<span class="comment">//计算根节点的f[u][1]</span></span><br><span class="line">        f[u][<span class="number">0</span>] += <span class="built_in">max</span>(f[j][<span class="number">0</span>], f[j][<span class="number">1</span>]);	<span class="comment">//计算根节点的f[u][0]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;happy[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);	<span class="comment">//初始化h数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n <span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(b, a);	<span class="comment">//插入边 b -&gt; a</span></span><br><span class="line">        hf[a] = <span class="literal">true</span>;	<span class="comment">//表示a有父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> root = <span class="number">1</span>;	<span class="comment">//寻找根节点——没有父节点的节点</span></span><br><span class="line">    <span class="keyword">while</span>(hf[root]) root++;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(root);	<span class="comment">//求f[root][0] 和 f[root][1]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出最大值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">max</span>(f[root][<span class="number">0</span>], f[root][<span class="number">1</span>]));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="记忆化搜索">记忆化搜索</h4>
<h5 id="滑雪">滑雪</h5>
<p><strong>题目</strong></p>
<ul>
<li>给定一个 R 行 C 列的矩阵，表示一个矩形网格滑雪场。矩阵中第 i 行第 j
列的点表示滑雪场的第 i 行第 j
列区域的高度。一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。</li>
</ul>
<p><strong>集合表示</strong></p>
<ul>
<li>f(i)(j) 从点 (i, j) 开始滑雪的路径</li>
<li>f[i][j] 表示所有从点 (i, j) 开始滑雪的路径中的路径长度最大值</li>
</ul>
<p><strong>集合划分</strong></p>
<ul>
<li>每个路径可以依据下一步往哪走划分为四个不同的类型（上下左右）</li>
<li>f[i][j] = max(上下左右路径长度 + 1)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> map[N][N];	<span class="comment">//表示滑雪场的地图</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>	<span class="comment">//记忆化搜索的模板，返回的是f[a][b]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>&amp; v = f[a][b];	<span class="comment">//用引用来代替f[a][b]</span></span><br><span class="line">    <span class="keyword">if</span>(v != <span class="number">-1</span>) <span class="keyword">return</span> v;	<span class="comment">//如果f[a][b]已经存在，则直接返回</span></span><br><span class="line">    v = <span class="number">1</span>;	<span class="comment">//再不济，v最小也是1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)	<span class="comment">//遍历四个方向</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = a + dx[i], y = b + dy[i];	<span class="comment">//获取四个方向的行列数</span></span><br><span class="line">        <span class="comment">//四个方向的行数x必须小于等于n，列数必须小于等于m，且新坐标的高等必须小于原坐标的高度才能滑动</span></span><br><span class="line">        <span class="keyword">if</span>(x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= m &amp;&amp; map[a][b] &gt; map[x][y])</span><br><span class="line">            v = <span class="built_in">max</span>(<span class="built_in">dp</span>(x, y) + <span class="number">1</span>, v);	<span class="comment">//dp(x,y)返回新坐标的f数组值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="comment">//读入高度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;map[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义res为答案</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化f数组为-1</span></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最长路径可能从任何一个点出发，所以需要每一个点都计算一次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">dp</span>(i, j));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag"># 动态规划</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/f7a7d551/" rel="prev" title="搜索与图论">
                  <i class="fa fa-angle-left"></i> 搜索与图论
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">sabersnt</span>
  </div>

    </div>
  </footer>

  

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
